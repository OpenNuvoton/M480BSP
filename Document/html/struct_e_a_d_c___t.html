<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.3"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>M480 BSP: EADC_T Struct Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectlogo"><img alt="Logo" src="m4.jpg"/></td>
  <td id="projectalign">
   <div id="projectname">M480 BSP<span id="projectnumber">&#160;V3.0.7000</span>
   </div>
   <div id="projectbrief">The Board Support Package for M480 Series</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.3 -->
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',false,false,'search.php','Search');
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-attribs">Data Fields</a>  </div>
  <div class="headertitle"><div class="title">EADC_T Struct Reference<div class="ingroups"><a class="el" href="group___r_e_g_i_s_t_e_r.html">Control Register</a></div></div></div>
</div><!--header-->
<div class="contents">

<p><code>#include &lt;<a class="el" href="eadc__reg_8h_source.html">eadc_reg.h</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-attribs" name="pub-attribs"></a>
Data Fields</h2></td></tr>
<tr class="memitem:ae08422cdf827e60c01f5f02739b9f73b"><td class="memItemLeft" align="right" valign="top">__I uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_e_a_d_c___t.html#ae08422cdf827e60c01f5f02739b9f73b">DAT</a> [19]</td></tr>
<tr class="separator:ae08422cdf827e60c01f5f02739b9f73b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4b17364060fa7ab412af48ca123970ef"><td class="memItemLeft" align="right" valign="top">__I uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_e_a_d_c___t.html#a4b17364060fa7ab412af48ca123970ef">CURDAT</a></td></tr>
<tr class="separator:a4b17364060fa7ab412af48ca123970ef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0f76b976320e1043f00cf1ba06974843"><td class="memItemLeft" align="right" valign="top">__IO uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_e_a_d_c___t.html#a0f76b976320e1043f00cf1ba06974843">CTL</a></td></tr>
<tr class="separator:a0f76b976320e1043f00cf1ba06974843"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adbadd7fc24373ee59089a73dde2cabee"><td class="memItemLeft" align="right" valign="top">__O uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_e_a_d_c___t.html#adbadd7fc24373ee59089a73dde2cabee">SWTRG</a></td></tr>
<tr class="separator:adbadd7fc24373ee59089a73dde2cabee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a22ae13b8f046a4c754c80ac5b80390fc"><td class="memItemLeft" align="right" valign="top">__IO uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_e_a_d_c___t.html#a22ae13b8f046a4c754c80ac5b80390fc">PENDSTS</a></td></tr>
<tr class="separator:a22ae13b8f046a4c754c80ac5b80390fc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3574d759cf426bd6e97fd09d11641243"><td class="memItemLeft" align="right" valign="top">__IO uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_e_a_d_c___t.html#a3574d759cf426bd6e97fd09d11641243">OVSTS</a></td></tr>
<tr class="separator:a3574d759cf426bd6e97fd09d11641243"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4d8cf5624bc60516291cc2a463453bf2"><td class="memItemLeft" align="right" valign="top">__IO uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_e_a_d_c___t.html#a4d8cf5624bc60516291cc2a463453bf2">SCTL</a> [19]</td></tr>
<tr class="separator:a4d8cf5624bc60516291cc2a463453bf2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7f787dd71e5c75856a8c503b01bfde0a"><td class="memItemLeft" align="right" valign="top">__IO uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_e_a_d_c___t.html#a7f787dd71e5c75856a8c503b01bfde0a">INTSRC</a> [4]</td></tr>
<tr class="separator:a7f787dd71e5c75856a8c503b01bfde0a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3875d55e72a93cd3c87cd29a12a3e010"><td class="memItemLeft" align="right" valign="top">__IO uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_e_a_d_c___t.html#a3875d55e72a93cd3c87cd29a12a3e010">CMP</a> [4]</td></tr>
<tr class="separator:a3875d55e72a93cd3c87cd29a12a3e010"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3a9e9eae753312ea434da7d544bbf808"><td class="memItemLeft" align="right" valign="top">__I uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_e_a_d_c___t.html#a3a9e9eae753312ea434da7d544bbf808">STATUS0</a></td></tr>
<tr class="separator:a3a9e9eae753312ea434da7d544bbf808"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab5ccb62b13782cf82084dc2c2a4bcdc7"><td class="memItemLeft" align="right" valign="top">__I uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_e_a_d_c___t.html#ab5ccb62b13782cf82084dc2c2a4bcdc7">STATUS1</a></td></tr>
<tr class="separator:ab5ccb62b13782cf82084dc2c2a4bcdc7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a81ef3b5f47e896bade83e833837fcd37"><td class="memItemLeft" align="right" valign="top">__IO uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_e_a_d_c___t.html#a81ef3b5f47e896bade83e833837fcd37">STATUS2</a></td></tr>
<tr class="separator:a81ef3b5f47e896bade83e833837fcd37"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa2a9209b1d93bce63d901632c57d5e81"><td class="memItemLeft" align="right" valign="top">__I uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_e_a_d_c___t.html#aa2a9209b1d93bce63d901632c57d5e81">STATUS3</a></td></tr>
<tr class="separator:aa2a9209b1d93bce63d901632c57d5e81"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0ae891b9a1166fc03da63ddb9fe522bf"><td class="memItemLeft" align="right" valign="top">__I uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_e_a_d_c___t.html#a0ae891b9a1166fc03da63ddb9fe522bf">DDAT</a> [4]</td></tr>
<tr class="separator:a0ae891b9a1166fc03da63ddb9fe522bf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a576cf54b48083876e84cfad506a7747c"><td class="memItemLeft" align="right" valign="top">__IO uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_e_a_d_c___t.html#a576cf54b48083876e84cfad506a7747c">PWRM</a></td></tr>
<tr class="separator:a576cf54b48083876e84cfad506a7747c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a111ab0c1ad1ab0b31bf5d50cbd4c3dd7"><td class="memItemLeft" align="right" valign="top">__IO uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_e_a_d_c___t.html#a111ab0c1ad1ab0b31bf5d50cbd4c3dd7">CALCTL</a></td></tr>
<tr class="separator:a111ab0c1ad1ab0b31bf5d50cbd4c3dd7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a56b42e1c6119043f6a1291c4b1125b03"><td class="memItemLeft" align="right" valign="top">__IO uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_e_a_d_c___t.html#a56b42e1c6119043f6a1291c4b1125b03">CALDWRD</a></td></tr>
<tr class="separator:a56b42e1c6119043f6a1291c4b1125b03"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a88fe84ec9fc872f8963781d5fd49c988"><td class="memItemLeft" align="right" valign="top">__IO uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_e_a_d_c___t.html#a88fe84ec9fc872f8963781d5fd49c988">PDMACTL</a></td></tr>
<tr class="separator:a88fe84ec9fc872f8963781d5fd49c988"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><pre class="fragment">@addtogroup EADC Enhanced Analog to Digital Converter(EADC)
Memory Mapped Structure for EADC Controller
</pre> 
<p class="definition">Definition at line <a class="el" href="eadc__reg_8h_source.html#l00026">26</a> of file <a class="el" href="eadc__reg_8h_source.html">eadc_reg.h</a>.</p>
</div><h2 class="groupheader">Field Documentation</h2>
<a id="a111ab0c1ad1ab0b31bf5d50cbd4c3dd7" name="a111ab0c1ad1ab0b31bf5d50cbd4c3dd7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a111ab0c1ad1ab0b31bf5d50cbd4c3dd7">&#9670;&nbsp;</a></span>CALCTL</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">EADC_T::CALCTL</td>
        </tr>
      </table>
</div><div class="memdoc">
<p >[0x0114] ADC Calibration Control Register <br  />
</p>
<p > 

<html><table class="fixed" border="1" style="border-collapse:collapse;" borderColor=black ><col width="75px" /><col width="125px" /><col width="700px" /><caption align="left"><font size="3">CALCTL
</font><br><p> <font size="2">
Offset: 0x114  ADC Calibration Control Register
</font></caption><thread><tr bgcolor="#8A0808" ><td><font color=white><b>Bits</b></font></td><td><font color=white><b>Field</b></font></td><td><font color=white><b>Descriptions</b></font></td></tr></thread><tbody>
<tr><td>
[1]</td><td>CALSTART</td><td><div style="word-wrap: break-word;"><b>Calibration Functional Block Start
</b><br>
0 = Stops calibration functional block.
<br>
1 = Starts calibration functional block.
<br>
Note: This bit is set by SW and clear by HW after re-calibration finish
<br>
</div></td></tr><tr><td>
[2]</td><td>CALDONE</td><td><div style="word-wrap: break-word;"><b>Calibration Functional Block Complete (Read Only)
</b><br>
0 = During a calibration.
<br>
1 = Calibration is completed.
<br>
</div></td></tr><tr><td>
[3]</td><td>CALSEL</td><td><div style="word-wrap: break-word;"><b>Select Calibration Functional Block
</b><br>
0 = Load calibration word when calibration functional block is active.
<br>
1 = Execute calibration when calibration functional block is active.
<br>
</div></td></tr></tbody></table></html>

 </p>

<p class="definition">Definition at line <a class="el" href="eadc__reg_8h_source.html#l01219">1219</a> of file <a class="el" href="eadc__reg_8h_source.html">eadc_reg.h</a>.</p>

</div>
</div>
<a id="a56b42e1c6119043f6a1291c4b1125b03" name="a56b42e1c6119043f6a1291c4b1125b03"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a56b42e1c6119043f6a1291c4b1125b03">&#9670;&nbsp;</a></span>CALDWRD</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">EADC_T::CALDWRD</td>
        </tr>
      </table>
</div><div class="memdoc">
<p >[0x0118] ADC Calibration Load Word Register <br  />
</p>
<p > 

<html><table class="fixed" border="1" style="border-collapse:collapse;" borderColor=black ><col width="75px" /><col width="125px" /><col width="700px" /><caption align="left"><font size="3">CALDWRD
</font><br><p> <font size="2">
Offset: 0x118  ADC Calibration Load Word Register
</font></caption><thread><tr bgcolor="#8A0808" ><td><font color=white><b>Bits</b></font></td><td><font color=white><b>Field</b></font></td><td><font color=white><b>Descriptions</b></font></td></tr></thread><tbody>
<tr><td>
[6:0]</td><td>CALWORD</td><td><div style="word-wrap: break-word;"><b>Calibration Word Bits
</b><br>
Write to this register with the previous calibration word before load calibration action.
<br>
Read this register after calibration done.
<br>
Note: The calibration block contains two parts CALIBRATION and LOAD CALIBRATION; if the calibration block configure as CALIBRATION; then this register represent the result of calibration when calibration is completed; if configure as LOAD CALIBRATION ; configure this register before loading calibration action, after loading calibration complete, the laoded calibration word will apply to the ADC; while in loading calibration function the loaded value will not be equal to the original CALWORD until calibration is done.
<br>
</div></td></tr></tbody></table></html>

 </p>

<p class="definition">Definition at line <a class="el" href="eadc__reg_8h_source.html#l01220">1220</a> of file <a class="el" href="eadc__reg_8h_source.html">eadc_reg.h</a>.</p>

</div>
</div>
<a id="a3875d55e72a93cd3c87cd29a12a3e010" name="a3875d55e72a93cd3c87cd29a12a3e010"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3875d55e72a93cd3c87cd29a12a3e010">&#9670;&nbsp;</a></span>CMP</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">EADC_T::CMP[4]</td>
        </tr>
      </table>
</div><div class="memdoc">
<p >[0x00e0] ADC Result Compare Register 0~3 <br  />
</p>
<p > 

<html><table class="fixed" border="1" style="border-collapse:collapse;" borderColor=black ><col width="75px" /><col width="125px" /><col width="700px" /><caption align="left"><font size="3">CMP[4]
</font><br><p> <font size="2">
Offset: 0xE0  ADC Result Compare Register 0~3
</font></caption><thread><tr bgcolor="#8A0808" ><td><font color=white><b>Bits</b></font></td><td><font color=white><b>Field</b></font></td><td><font color=white><b>Descriptions</b></font></td></tr></thread><tbody>
<tr><td>
[0]</td><td>ADCMPEN</td><td><div style="word-wrap: break-word;"><b>ADC Result Compare Enable Bit
</b><br>
0 = Compare Disabled.
<br>
1 = Compare Enabled.
<br>
Set this bit to 1 to enable compare CMPDAT (EADC_CMPn[27:16], n=0~3) with specified sample module conversion result when converted data is loaded into EADC_DAT register.
<br>
</div></td></tr><tr><td>
[1]</td><td>ADCMPIE</td><td><div style="word-wrap: break-word;"><b>ADC Result Compare Interrupt Enable Bit
</b><br>
0 = Compare function interrupt Disabled.
<br>
1 = Compare function interrupt Enabled.
<br>
If the compare function is enabled and the compare condition matches the setting of CMPCOND (EADC_CMPn[2], n=0~3) and CMPMCNT (EADC_CMPn[11:8], n=0~3), ADCMPFn (EADC_STATUS2[7:4], n=0~3) will be asserted, in the meanwhile, if ADCMPIE is set to 1, a compare interrupt request is generated.
<br>
</div></td></tr><tr><td>
[2]</td><td>CMPCOND</td><td><div style="word-wrap: break-word;"><b>Compare Condition
</b><br>
0= Set the compare condition as that when a 12-bit ADC conversion result is less than the 12-bit CMPDAT (EADC_CMPn [27:16]), the internal match counter will increase one.
<br>
1= Set the compare condition as that when a 12-bit ADC conversion result is greater or equal to the 12-bit CMPDAT (EADC_CMPn [27:16]), the internal match counter will increase one.
<br>
Note: When the internal counter reaches the value to (CMPMCNT (EADC_CMPn[11:8], n=0~3) +1), the CMPF bit will be set.
<br>
</div></td></tr><tr><td>
[7:3]</td><td>CMPSPL</td><td><div style="word-wrap: break-word;"><b>Compare Sample Module Selection
</b><br>
00000 = Sample Module 0 conversion result EADC_DAT0 is selected to be compared.
<br>
00001 = Sample Module 1 conversion result EADC_DAT1 is selected to be compared.
<br>
00010 = Sample Module 2 conversion result EADC_DAT2 is selected to be compared.
<br>
00011 = Sample Module 3 conversion result EADC_DAT3 is selected to be compared.
<br>
00100 = Sample Module 4 conversion result EADC_DAT4 is selected to be compared.
<br>
00101 = Sample Module 5 conversion result EADC_DAT5 is selected to be compared.
<br>
00110 = Sample Module 6 conversion result EADC_DAT6 is selected to be compared.
<br>
00111 = Sample Module 7 conversion result EADC_DAT7 is selected to be compared.
<br>
01000 = Sample Module 8 conversion result EADC_DAT8 is selected to be compared.
<br>
01001 = Sample Module 9 conversion result EADC_DAT9 is selected to be compared.
<br>
01010 = Sample Module 10 conversion result EADC_DAT10 is selected to be compared.
<br>
01011 = Sample Module 11 conversion result EADC_DAT11 is selected to be compared.
<br>
01100 = Sample Module 12 conversion result EADC_DAT12 is selected to be compared.
<br>
01101 = Sample Module 13 conversion result EADC_DAT13 is selected to be compared.
<br>
01110 = Sample Module 14 conversion result EADC_DAT14 is selected to be compared.
<br>
01111 = Sample Module 15 conversion result EADC_DAT15 is selected to be compared.
<br>
10000 = Sample Module 16 conversion result EADC_DAT16 is selected to be compared.
<br>
10001 = Sample Module 17 conversion result EADC_DAT17 is selected to be compared.
<br>
10010 = Sample Module 18 conversion result EADC_DAT18 is selected to be compared.
<br>
</div></td></tr><tr><td>
[11:8]</td><td>CMPMCNT</td><td><div style="word-wrap: break-word;"><b>Compare Match Count
</b><br>
When the specified ADC sample module analog conversion result matches the compare condition defined by CMPCOND (EADC_CMPn[2], n=0~3), the internal match counter will increase 1
<br>
If the compare result does not meet the compare condition, the internal compare match counter will reset to 0
<br>
When the internal counter reaches the value to (CMPMCNT +1), the ADCMPFn (EADC_STATUS2[7:4], n=0~3) will be set.
<br>
</div></td></tr><tr><td>
[15]</td><td>CMPWEN</td><td><div style="word-wrap: break-word;"><b>Compare Window Mode Enable Bit
</b><br>
0 = ADCMPF0 (EADC_STATUS2[4]) will be set when EADC_CMP0 compared condition matched
<br>
ADCMPF2 (EADC_STATUS2[6]) will be set when EADC_CMP2 compared condition matched
<br>
1 = ADCMPF0 (EADC_STATUS2[4]) will be set when both EADC_CMP0 and EADC_CMP1 compared condition matched
<br>
ADCMPF2 (EADC_STATUS2[6]) will be set when both EADC_CMP2 and EADC_CMP3 compared condition matched.
<br>
Note: This bit is only present in EADC_CMP0 and EADC_CMP2 register.
<br>
</div></td></tr><tr><td>
[27:16]</td><td>CMPDAT</td><td><div style="word-wrap: break-word;"><b>Comparison Data
</b><br>
The 12 bits data is used to compare with conversion result of specified sample module
<br>
User can use it to monitor the external analog input pin voltage transition without imposing a load on software.
<br>
</div></td></tr></tbody></table></html>

 </p>

<p class="definition">Definition at line <a class="el" href="eadc__reg_8h_source.html#l01212">1212</a> of file <a class="el" href="eadc__reg_8h_source.html">eadc_reg.h</a>.</p>

</div>
</div>
<a id="a0f76b976320e1043f00cf1ba06974843" name="a0f76b976320e1043f00cf1ba06974843"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0f76b976320e1043f00cf1ba06974843">&#9670;&nbsp;</a></span>CTL</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">EADC_T::CTL</td>
        </tr>
      </table>
</div><div class="memdoc">
<p >[0x0050] ADC Control Register <br  />
</p>
<p > 

<html><table class="fixed" border="1" style="border-collapse:collapse;" borderColor=black ><col width="75px" /><col width="125px" /><col width="700px" /><caption align="left"><font size="3">CTL
</font><br><p> <font size="2">
Offset: 0x50  ADC Control Register
</font></caption><thread><tr bgcolor="#8A0808" ><td><font color=white><b>Bits</b></font></td><td><font color=white><b>Field</b></font></td><td><font color=white><b>Descriptions</b></font></td></tr></thread><tbody>
<tr><td>
[0]</td><td>ADCEN</td><td><div style="word-wrap: break-word;"><b>ADC Converter Enable Bit
</b><br>
0 = Disabled EADC.
<br>
1 = Enabled EADC.
<br>
Note: Before starting ADC conversion function, this bit should be set to 1
<br>
Clear it to 0 to disable ADC converter analog circuit power consumption.
<br>
</div></td></tr><tr><td>
[1]</td><td>ADCRST</td><td><div style="word-wrap: break-word;"><b>ADC Converter Control Circuits Reset
</b><br>
0 = No effect.
<br>
1 = Cause ADC control circuits reset to initial state, but not change the ADC registers value.
<br>
Note: ADCRST bit remains 1 during ADC reset, when ADC reset end, the ADCRST bit is automatically cleared to 0.
<br>
</div></td></tr><tr><td>
[2]</td><td>ADCIEN0</td><td><div style="word-wrap: break-word;"><b>Specific Sample Module ADC ADINT0 Interrupt Enable Bit
</b><br>
The ADC converter generates a conversion end ADIF0 (EADC_STATUS2[0]) upon the end of specific sample module ADC conversion
<br>
If ADCIEN0 bit is set then conversion end interrupt request ADINT0 is generated.
<br>
0 = Specific sample module ADC ADINT0 interrupt function Disabled.
<br>
1 = Specific sample module ADC ADINT0 interrupt function Enabled.
<br>
</div></td></tr><tr><td>
[3]</td><td>ADCIEN1</td><td><div style="word-wrap: break-word;"><b>Specific Sample Module ADC ADINT1 Interrupt Enable Bit
</b><br>
The ADC converter generates a conversion end ADIF1 (EADC_STATUS2[1]) upon the end of specific sample module ADC conversion
<br>
If ADCIEN1 bit is set then conversion end interrupt request ADINT1 is generated.
<br>
0 = Specific sample module ADC ADINT1 interrupt function Disabled.
<br>
1 = Specific sample module ADC ADINT1 interrupt function Enabled.
<br>
</div></td></tr><tr><td>
[4]</td><td>ADCIEN2</td><td><div style="word-wrap: break-word;"><b>Specific Sample Module ADC ADINT2 Interrupt Enable Bit
</b><br>
The ADC converter generates a conversion end ADIF2 (EADC_STATUS2[2]) upon the end of specific sample module ADC conversion
<br>
If ADCIEN2 bit is set then conversion end interrupt request ADINT2 is generated.
<br>
0 = Specific sample module ADC ADINT2 interrupt function Disabled.
<br>
1 = Specific sample module ADC ADINT2 interrupt function Enabled.
<br>
</div></td></tr><tr><td>
[5]</td><td>ADCIEN3</td><td><div style="word-wrap: break-word;"><b>Specific Sample Module ADC ADINT3 Interrupt Enable Bit
</b><br>
The ADC converter generates a conversion end ADIF3 (EADC_STATUS2[3]) upon the end of specific sample module ADC conversion
<br>
If ADCIEN3 bit is set then conversion end interrupt request ADINT3 is generated.
<br>
0 = Specific sample module ADC ADINT3 interrupt function Disabled.
<br>
1 = Specific sample module ADC ADINT3 interrupt function Enabled.
<br>
</div></td></tr><tr><td>
[7:6]</td><td>RESSEL</td><td><div style="word-wrap: break-word;"><b>Resolution Selection
</b><br>
00 = 6-bit ADC result will be put at RESULT (EADC_DATn[5:0]).
<br>
01 = 8-bit ADC result will be put at RESULT (EADC_DATn[7:0]).
<br>
10 = 10-bit ADC result will be put at RESULT (EADC_DATn[9:0]).
<br>
11 = 12-bit ADC result will be put at RESULT (EADC_DATn[11:0]).
<br>
</div></td></tr><tr><td>
[8]</td><td>DIFFEN</td><td><div style="word-wrap: break-word;"><b>Differential Analog Input Mode Enable Bit
</b><br>
0 = Single-end analog input mode.
<br>
1 = Differential analog input mode.
<br>
</div></td></tr><tr><td>
[9]</td><td>DMOF</td><td><div style="word-wrap: break-word;"><b>ADC Differential Input Mode Output Format
</b><br>
0 = ADC conversion result will be filled in RESULT (EADC_DATn[15:0] , n= 0 ~18) with unsigned format.
<br>
1 = ADC conversion result will be filled in RESULT (EADC_DATn[15:0] , n= 0 ~18) with 2'complement format.
<br>
</div></td></tr><tr><td>
[11]</td><td>PDMAEN</td><td><div style="word-wrap: break-word;"><b>PDMA Transfer Enable Bit
</b><br>
When ADC conversion is completed, the converted data is loaded into EADC_DATn (n: 0 ~ 18) register, user can enable this bit to generate a PDMA data transfer request.
<br>
0 = PDMA data transfer Disabled.
<br>
1 = PDMA data transfer Enabled.
<br>
Note: When set this bit field to 1, user must set ADCIENn (EADC_CTL[5:2], n=0~3) = 0 to disable interrupt.
<br>
</div></td></tr></tbody></table></html>

 </p>

<p class="definition">Definition at line <a class="el" href="eadc__reg_8h_source.html#l01200">1200</a> of file <a class="el" href="eadc__reg_8h_source.html">eadc_reg.h</a>.</p>

</div>
</div>
<a id="a4b17364060fa7ab412af48ca123970ef" name="a4b17364060fa7ab412af48ca123970ef"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4b17364060fa7ab412af48ca123970ef">&#9670;&nbsp;</a></span>CURDAT</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">EADC_T::CURDAT</td>
        </tr>
      </table>
</div><div class="memdoc">
<p >[0x004c] ADC PDMA Current Transfer Data Register <br  />
</p>
<p > 

<html><table class="fixed" border="1" style="border-collapse:collapse;" borderColor=black ><col width="75px" /><col width="125px" /><col width="700px" /><caption align="left"><font size="3">CURDAT
</font><br><p> <font size="2">
Offset: 0x4C  ADC PDMA Current Transfer Data Register
</font></caption><thread><tr bgcolor="#8A0808" ><td><font color=white><b>Bits</b></font></td><td><font color=white><b>Field</b></font></td><td><font color=white><b>Descriptions</b></font></td></tr></thread><tbody>
<tr><td>
[17:0]</td><td>CURDAT</td><td><div style="word-wrap: break-word;"><b>ADC PDMA Current Transfer Data Register
</b><br>
This register is a shadow register of EADC_DATn (n=0~18) for PDMA support.
<br>
This is a read only register.
<br>
</div></td></tr></tbody></table></html>

 </p>

<p class="definition">Definition at line <a class="el" href="eadc__reg_8h_source.html#l01199">1199</a> of file <a class="el" href="eadc__reg_8h_source.html">eadc_reg.h</a>.</p>

</div>
</div>
<a id="ae08422cdf827e60c01f5f02739b9f73b" name="ae08422cdf827e60c01f5f02739b9f73b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae08422cdf827e60c01f5f02739b9f73b">&#9670;&nbsp;</a></span>DAT</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">EADC_T::DAT[19]</td>
        </tr>
      </table>
</div><div class="memdoc">
<p >[0x0000] ADC Data Register 0~18 for Sample Module 0~18 <br  />
</p>
<p > 

<html><table class="fixed" border="1" style="border-collapse:collapse;" borderColor=black ><col width="75px" /><col width="125px" /><col width="700px" /><caption align="left"><font size="3">DAT[19]
</font><br><p> <font size="2">
Offset: 0x00  ADC Data Register 0~18 for Sample Module 0~18
</font></caption><thread><tr bgcolor="#8A0808" ><td><font color=white><b>Bits</b></font></td><td><font color=white><b>Field</b></font></td><td><font color=white><b>Descriptions</b></font></td></tr></thread><tbody>
<tr><td>
[15:0]</td><td>RESULT</td><td><div style="word-wrap: break-word;"><b>ADC Conversion Result
</b><br>
This field contains 12 bits conversion result.
<br>
When DMOF (EADC_CTL[9]) is set to 0, 12-bit ADC conversion result with unsigned format will be filled in RESULT[11:0] and zero will be filled in RESULT[15:12].
<br>
When DMOF (EADC_CTL[9]) set to 1, 12-bit ADC conversion result with 2'complement format will be filled in RESULT[11:0] and signed bits to will be filled in RESULT[15:12].
<br>
</div></td></tr><tr><td>
[16]</td><td>OV</td><td><div style="word-wrap: break-word;"><b>Overrun Flag
</b><br>
If converted data in RESULT[11:0] has not been read before new conversion result is loaded to this register, OV is set to 1.
<br>
0 = Data in RESULT[11:0] is recent conversion result.
<br>
1 = Data in RESULT[11:0] is overwrite.
<br>
Note: It is cleared by hardware after EADC_DAT register is read.
<br>
</div></td></tr><tr><td>
[17]</td><td>VALID</td><td><div style="word-wrap: break-word;"><b>Valid Flag
</b><br>
This bit is set to 1 when corresponding sample module channel analog input conversion is completed and cleared by hardware after EADC_DAT register is read.
<br>
0 = Data in RESULT[11:0] bits is not valid.
<br>
1 = Data in RESULT[11:0] bits is valid.
<br>
</div></td></tr></tbody></table></html>

 </p>

<p class="definition">Definition at line <a class="el" href="eadc__reg_8h_source.html#l01198">1198</a> of file <a class="el" href="eadc__reg_8h_source.html">eadc_reg.h</a>.</p>

</div>
</div>
<a id="a0ae891b9a1166fc03da63ddb9fe522bf" name="a0ae891b9a1166fc03da63ddb9fe522bf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0ae891b9a1166fc03da63ddb9fe522bf">&#9670;&nbsp;</a></span>DDAT</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">EADC_T::DDAT[4]</td>
        </tr>
      </table>
</div><div class="memdoc">
<p >[0x0100] ADC Double Data Register 0~3 for Sample Module 0~3 <br  />
</p>
<p > 

<html><table class="fixed" border="1" style="border-collapse:collapse;" borderColor=black ><col width="75px" /><col width="125px" /><col width="700px" /><caption align="left"><font size="3">DDAT[4]
</font><br><p> <font size="2">
Offset: 0x100  ADC Double Data Register 0 for Sample Module 0
</font></caption><thread><tr bgcolor="#8A0808" ><td><font color=white><b>Bits</b></font></td><td><font color=white><b>Field</b></font></td><td><font color=white><b>Descriptions</b></font></td></tr></thread><tbody>
<tr><td>
[15:0]</td><td>RESULT</td><td><div style="word-wrap: break-word;"><b>ADC Conversion Results
</b><br>
This field contains 12 bits conversion results.
<br>
When the DMOF (EADC_CTL[9]) is set to 0, 12-bit ADC conversion result with unsigned format will be filled in RESULT [11:0] and zero will be filled in RESULT [15:12].
<br>
When DMOF (EADC_CTL[9]) set to 1, 12-bit ADC conversion result with 2'complement format will be filled in RESULT [11:0] and signed bits to will be filled in RESULT [15:12].
<br>
</div></td></tr><tr><td>
[16]</td><td>OV</td><td><div style="word-wrap: break-word;"><b>Overrun Flag
</b><br>
0 = Data in RESULT (EADC_DATn[15:0], n=0~3) is recent conversion result.
<br>
1 = Data in RESULT (EADC_DATn[15:0], n=0~3) is overwrite.
<br>
If converted data in RESULT[15:0] has not been read before new conversion result is loaded to this register, OV is set to 1
<br>
It is cleared by hardware after EADC_DDAT register is read.
<br>
</div></td></tr><tr><td>
[17]</td><td>VALID</td><td><div style="word-wrap: break-word;"><b>Valid Flag
</b><br>
0 = Double data in RESULT (EADC_DDATn[15:0]) is not valid.
<br>
1 = Double data in RESULT (EADC_DDATn[15:0]) is valid.
<br>
This bit is set to 1 when corresponding sample module channel analog input conversion is completed and cleared by hardware after EADC_DDATn register is read
<br>
(n=0~3).
<br>
</div></td></tr></tbody></table></html>

 </p>

<p class="definition">Definition at line <a class="el" href="eadc__reg_8h_source.html#l01217">1217</a> of file <a class="el" href="eadc__reg_8h_source.html">eadc_reg.h</a>.</p>

</div>
</div>
<a id="a7f787dd71e5c75856a8c503b01bfde0a" name="a7f787dd71e5c75856a8c503b01bfde0a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7f787dd71e5c75856a8c503b01bfde0a">&#9670;&nbsp;</a></span>INTSRC</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">EADC_T::INTSRC[4]</td>
        </tr>
      </table>
</div><div class="memdoc">
<p >[0x00d0] ADC interrupt 0~3 Source Enable Control Register. <br  />
</p>
<p > 

<html><table class="fixed" border="1" style="border-collapse:collapse;" borderColor=black ><col width="75px" /><col width="125px" /><col width="700px" /><caption align="left"><font size="3">INTSRC[4]
</font><br><p> <font size="2">
Offset: 0xD0  ADC interrupt 0~3 Source Enable Control Register.
</font></caption><thread><tr bgcolor="#8A0808" ><td><font color=white><b>Bits</b></font></td><td><font color=white><b>Field</b></font></td><td><font color=white><b>Descriptions</b></font></td></tr></thread><tbody>
<tr><td>
[0]</td><td>SPLIE0</td><td><div style="word-wrap: break-word;"><b>Sample Module 0 Interrupt Enable Bit
</b><br>
0 = Sample Module 0 interrupt Disabled.
<br>
1 = Sample Module 0 interrupt Enabled.
<br>
</div></td></tr><tr><td>
[1]</td><td>SPLIE1</td><td><div style="word-wrap: break-word;"><b>Sample Module 1 Interrupt Enable Bit
</b><br>
0 = Sample Module 1 interrupt Disabled.
<br>
1 = Sample Module 1 interrupt Enabled.
<br>
</div></td></tr><tr><td>
[2]</td><td>SPLIE2</td><td><div style="word-wrap: break-word;"><b>Sample Module 2 Interrupt Enable Bit
</b><br>
0 = Sample Module 2 interrupt Disabled.
<br>
1 = Sample Module 2 interrupt Enabled.
<br>
</div></td></tr><tr><td>
[3]</td><td>SPLIE3</td><td><div style="word-wrap: break-word;"><b>Sample Module 3 Interrupt Enable Bit
</b><br>
0 = Sample Module 3 interrupt Disabled.
<br>
1 = Sample Module 3 interrupt Enabled.
<br>
</div></td></tr><tr><td>
[4]</td><td>SPLIE4</td><td><div style="word-wrap: break-word;"><b>Sample Module 4 Interrupt Enable Bit
</b><br>
0 = Sample Module 4 interrupt Disabled.
<br>
1 = Sample Module 4 interrupt Enabled.
<br>
</div></td></tr><tr><td>
[5]</td><td>SPLIE5</td><td><div style="word-wrap: break-word;"><b>Sample Module 5 Interrupt Enable Bit
</b><br>
0 = Sample Module 5 interrupt Disabled.
<br>
1 = Sample Module 5 interrupt Enabled.
<br>
</div></td></tr><tr><td>
[6]</td><td>SPLIE6</td><td><div style="word-wrap: break-word;"><b>Sample Module 6 Interrupt Enable Bit
</b><br>
0 = Sample Module 6 interrupt Disabled.
<br>
1 = Sample Module 6 interrupt Enabled.
<br>
</div></td></tr><tr><td>
[7]</td><td>SPLIE7</td><td><div style="word-wrap: break-word;"><b>Sample Module 7 Interrupt Enable Bit
</b><br>
0 = Sample Module 7 interrupt Disabled.
<br>
1 = Sample Module 7 interrupt Enabled.
<br>
</div></td></tr><tr><td>
[8]</td><td>SPLIE8</td><td><div style="word-wrap: break-word;"><b>Sample Module 8 Interrupt Enable Bit
</b><br>
0 = Sample Module 8 interrupt Disabled.
<br>
1 = Sample Module 8 interrupt Enabled.
<br>
</div></td></tr><tr><td>
[9]</td><td>SPLIE9</td><td><div style="word-wrap: break-word;"><b>Sample Module 9 Interrupt Enable Bit
</b><br>
0 = Sample Module 9 interrupt Disabled.
<br>
1 = Sample Module 9 interrupt Enabled.
<br>
</div></td></tr><tr><td>
[10]</td><td>SPLIE10</td><td><div style="word-wrap: break-word;"><b>Sample Module 10 Interrupt Enable Bit
</b><br>
0 = Sample Module 10 interrupt Disabled.
<br>
1 = Sample Module 10 interrupt Enabled.
<br>
</div></td></tr><tr><td>
[11]</td><td>SPLIE11</td><td><div style="word-wrap: break-word;"><b>Sample Module 11 Interrupt Enable Bit
</b><br>
0 = Sample Module 11 interrupt Disabled.
<br>
1 = Sample Module 11 interrupt Enabled.
<br>
</div></td></tr><tr><td>
[12]</td><td>SPLIE12</td><td><div style="word-wrap: break-word;"><b>Sample Module 12 Interrupt Enable Bit
</b><br>
0 = Sample Module 12 interrupt Disabled.
<br>
1 = Sample Module 12 interrupt Enabled.
<br>
</div></td></tr><tr><td>
[13]</td><td>SPLIE13</td><td><div style="word-wrap: break-word;"><b>Sample Module 13 Interrupt Enable Bit
</b><br>
0 = Sample Module 13 interrupt Disabled.
<br>
1 = Sample Module 13 interrupt Enabled.
<br>
</div></td></tr><tr><td>
[14]</td><td>SPLIE14</td><td><div style="word-wrap: break-word;"><b>Sample Module 14 Interrupt Enable Bit
</b><br>
0 = Sample Module 14 interrupt Disabled.
<br>
1 = Sample Module 14 interrupt Enabled.
<br>
</div></td></tr><tr><td>
[15]</td><td>SPLIE15</td><td><div style="word-wrap: break-word;"><b>Sample Module 15 Interrupt Enable Bit
</b><br>
0 = Sample Module 15 interrupt Disabled.
<br>
1 = Sample Module 15 interrupt Enabled.
<br>
</div></td></tr><tr><td>
[16]</td><td>SPLIE16</td><td><div style="word-wrap: break-word;"><b>Sample Module 16 Interrupt Enable Bit
</b><br>
0 = Sample Module 16 interrupt Disabled.
<br>
1 = Sample Module 16 interrupt Enabled.
<br>
</div></td></tr><tr><td>
[17]</td><td>SPLIE17</td><td><div style="word-wrap: break-word;"><b>Sample Module 17 Interrupt Enable Bit
</b><br>
0 = Sample Module 17 interrupt Disabled.
<br>
1 = Sample Module 17 interrupt Enabled.
<br>
</div></td></tr><tr><td>
[18]</td><td>SPLIE18</td><td><div style="word-wrap: break-word;"><b>Sample Module 18 Interrupt Enable Bit
</b><br>
0 = Sample Module 18 interrupt Disabled.
<br>
1 = Sample Module 18 interrupt Enabled.
<br>
</div></td></tr></tbody></table></html>

 </p>

<p class="definition">Definition at line <a class="el" href="eadc__reg_8h_source.html#l01211">1211</a> of file <a class="el" href="eadc__reg_8h_source.html">eadc_reg.h</a>.</p>

</div>
</div>
<a id="a3574d759cf426bd6e97fd09d11641243" name="a3574d759cf426bd6e97fd09d11641243"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3574d759cf426bd6e97fd09d11641243">&#9670;&nbsp;</a></span>OVSTS</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">EADC_T::OVSTS</td>
        </tr>
      </table>
</div><div class="memdoc">
<p >[0x005c] ADC Sample Module Start of Conversion Overrun Flag Register <br  />
</p>
<p > 

<html><table class="fixed" border="1" style="border-collapse:collapse;" borderColor=black ><col width="75px" /><col width="125px" /><col width="700px" /><caption align="left"><font size="3">OVSTS
</font><br><p> <font size="2">
Offset: 0x5C  ADC Sample Module Start of Conversion Overrun Flag Register
</font></caption><thread><tr bgcolor="#8A0808" ><td><font color=white><b>Bits</b></font></td><td><font color=white><b>Field</b></font></td><td><font color=white><b>Descriptions</b></font></td></tr></thread><tbody>
<tr><td>
[18:0]</td><td>SPOVF</td><td><div style="word-wrap: break-word;"><b>ADC SAMPLE0~18 Overrun Flag
</b><br>
0 = No sample module event overrun.
<br>
1 = Indicates a new sample module event is generated while an old one event is pending.
<br>
Note: This bit is cleared by writing 1 to it.
<br>
</div></td></tr></tbody></table></html>

 </p>

<p class="definition">Definition at line <a class="el" href="eadc__reg_8h_source.html#l01203">1203</a> of file <a class="el" href="eadc__reg_8h_source.html">eadc_reg.h</a>.</p>

</div>
</div>
<a id="a88fe84ec9fc872f8963781d5fd49c988" name="a88fe84ec9fc872f8963781d5fd49c988"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a88fe84ec9fc872f8963781d5fd49c988">&#9670;&nbsp;</a></span>PDMACTL</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__IO uint32_t EADC_T::PDMACTL</td>
        </tr>
      </table>
</div><div class="memdoc">
<p >[0x0130] ADC PDMA Control Register <br  />
 </p>

<p class="definition">Definition at line <a class="el" href="eadc__reg_8h_source.html#l01224">1224</a> of file <a class="el" href="eadc__reg_8h_source.html">eadc_reg.h</a>.</p>

</div>
</div>
<a id="a22ae13b8f046a4c754c80ac5b80390fc" name="a22ae13b8f046a4c754c80ac5b80390fc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a22ae13b8f046a4c754c80ac5b80390fc">&#9670;&nbsp;</a></span>PENDSTS</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">EADC_T::PENDSTS</td>
        </tr>
      </table>
</div><div class="memdoc">
<p >[0x0058] ADC Start of Conversion Pending Flag Register <br  />
</p>
<p > 

<html><table class="fixed" border="1" style="border-collapse:collapse;" borderColor=black ><col width="75px" /><col width="125px" /><col width="700px" /><caption align="left"><font size="3">PENDSTS
</font><br><p> <font size="2">
Offset: 0x58  ADC Start of Conversion Pending Flag Register
</font></caption><thread><tr bgcolor="#8A0808" ><td><font color=white><b>Bits</b></font></td><td><font color=white><b>Field</b></font></td><td><font color=white><b>Descriptions</b></font></td></tr></thread><tbody>
<tr><td>
[18:0]</td><td>STPF</td><td><div style="word-wrap: break-word;"><b>ADC Sample Module 0~18 Start of Conversion Pending Flag
</b><br>
Read:
<br>
0 = There is no pending conversion for sample module.
<br>
1 = Sample module ADC start of conversion is pending.
<br>
Write:
<br>
1 = clear pending flag & cancel the conversion for sample module.
<br>
Note: This bit remains 1 during pending state, when the respective ADC conversion is end, the STPFn (n=0~18) bit is automatically cleared to 0
<br>
</div></td></tr></tbody></table></html>

 </p>

<p class="definition">Definition at line <a class="el" href="eadc__reg_8h_source.html#l01202">1202</a> of file <a class="el" href="eadc__reg_8h_source.html">eadc_reg.h</a>.</p>

</div>
</div>
<a id="a576cf54b48083876e84cfad506a7747c" name="a576cf54b48083876e84cfad506a7747c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a576cf54b48083876e84cfad506a7747c">&#9670;&nbsp;</a></span>PWRM</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">EADC_T::PWRM</td>
        </tr>
      </table>
</div><div class="memdoc">
<p >[0x0110] ADC Power Management Register <br  />
</p>
<p > 

<html><table class="fixed" border="1" style="border-collapse:collapse;" borderColor=black ><col width="75px" /><col width="125px" /><col width="700px" /><caption align="left"><font size="3">PWRM
</font><br><p> <font size="2">
Offset: 0x110  ADC Power Management Register
</font></caption><thread><tr bgcolor="#8A0808" ><td><font color=white><b>Bits</b></font></td><td><font color=white><b>Field</b></font></td><td><font color=white><b>Descriptions</b></font></td></tr></thread><tbody>
<tr><td>
[0]</td><td>PWUPRDY</td><td><div style="word-wrap: break-word;"><b>ADC Power-up Sequence Completed and Ready for Conversion (Read Only)
</b><br>
0 = ADC is not ready for conversion may be in power down state or in the progress of start up.
<br>
1 = ADC is ready for conversion.
<br>
</div></td></tr><tr><td>
[1]</td><td>PWUCALEN</td><td><div style="word-wrap: break-word;"><b>Power Up Calibration Function Enable Control
</b><br>
0 = Disable the function of calibration at power up.
<br>
1 = Enable the function of calibration at power up.
<br>
Note: This bit work together with CALSEL (EADC_CALCTL [3]), see the following
<br>
{PWUCALEN, CALSEL } Description:
<br>
PWUCALEN is 0 and CALSEL is 0: No need to calibrate.
<br>
PWUCALEN is 0 and CALSEL is 1: No need to calibrate.
<br>
PWUCALEN is 1 and CALSEL is 0: Load calibration word when power up.
<br>
PWUCALEN is 1 and CALSEL is 1: Calibrate when power up.
<br>
</div></td></tr><tr><td>
[3:2]</td><td>PWDMOD</td><td><div style="word-wrap: break-word;"><b>ADC Power-down Mode
</b><br>
Set this bit fields to select ADC power down mode when system power-down.
<br>
00 = ADC Deep power down mode.
<br>
01 = ADC Power down.
<br>
10 = ADC Standby mode.
<br>
11 = ADC Deep power down mode.
<br>
Note: Different PWDMOD has different power down/up sequence, in order to avoid ADC powering up with wrong sequence; user must keep PWMOD consistent each time in power down and start up
<br>
</div></td></tr><tr><td>
[19:8]</td><td>LDOSUT</td><td><div style="word-wrap: break-word;"><b>ADC Internal LDO Start-up Time
</b><br>
Set this bit fields to control LDO start-up time
<br>
The minimum required LDO start-up time is 20us
<br>
LDO start-up time = (1/ADC_CLK) x LDOSUT.
<br>
</div></td></tr></tbody></table></html>

 </p>

<p class="definition">Definition at line <a class="el" href="eadc__reg_8h_source.html#l01218">1218</a> of file <a class="el" href="eadc__reg_8h_source.html">eadc_reg.h</a>.</p>

</div>
</div>
<a id="a4d8cf5624bc60516291cc2a463453bf2" name="a4d8cf5624bc60516291cc2a463453bf2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4d8cf5624bc60516291cc2a463453bf2">&#9670;&nbsp;</a></span>SCTL</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">EADC_T::SCTL[19]</td>
        </tr>
      </table>
</div><div class="memdoc">
<p >[0x0080] ADC Sample Module 0~18 Control Register <br  />
</p>
<p > 

<html><table class="fixed" border="1" style="border-collapse:collapse;" borderColor=black ><col width="75px" /><col width="125px" /><col width="700px" /><caption align="left"><font size="3">SCTL[19]
</font><br><p> <font size="2">
Offset: 0x80  ADC Sample Module 0~18 Control Register
</font></caption><thread><tr bgcolor="#8A0808" ><td><font color=white><b>Bits</b></font></td><td><font color=white><b>Field</b></font></td><td><font color=white><b>Descriptions</b></font></td></tr></thread><tbody>
<tr><td>
[3:0]</td><td>CHSEL</td><td><div style="word-wrap: break-word;"><b>ADC Sample Module Channel Selection
</b><br>
00H = EADC_CH0 (slow channel).
<br>
01H = EADC_CH1 (slow channel).
<br>
02H = EADC_CH2 (slow channel).
<br>
03H = EADC_CH3 (slow channel).
<br>
04H = EADC_CH4 (slow channel).
<br>
05H = EADC_CH5 (slow channel).
<br>
06H = EADC_CH6 (slow channel).
<br>
07H = EADC_CH7 (slow channel).
<br>
08H = EADC_CH8 (slow channel).
<br>
09H = EADC_CH9 (slow channel).
<br>
0AH = EADC_CH10 (fast channel).
<br>
0BH = EADC_CH11 (fast channel).
<br>
0CH = EADC_CH12 (fast channel).
<br>
0DH = EADC_CH13 (fast channel).
<br>
0EH = EADC_CH14 (fast channel).
<br>
0FH = EADC_CH15 (fast channel).
<br>
</div></td></tr><tr><td>
[4]</td><td>EXTREN</td><td><div style="word-wrap: break-word;"><b>ADC External Trigger Rising Edge Enable Bit
</b><br>
0 = Rising edge Disabled when ADC selects EADC0_ST as trigger source.
<br>
1 = Rising edge Enabled when ADC selects EADC0_ST as trigger source.
<br>
</div></td></tr><tr><td>
[5]</td><td>EXTFEN</td><td><div style="word-wrap: break-word;"><b>ADC External Trigger Falling Edge Enable Bit
</b><br>
0 = Falling edge Disabled when ADC selects EADC0_ST as trigger source.
<br>
1 = Falling edge Enabled when ADC selects EADC0_ST as trigger source.
<br>
</div></td></tr><tr><td>
[7:6]</td><td>TRGDLYDIV</td><td><div style="word-wrap: break-word;"><b>ADC Sample Module Start of Conversion Trigger Delay Clock Divider Selection
</b><br>
Trigger delay clock frequency:
<br>
00 = ADC_CLK/1.
<br>
01 = ADC_CLK/2.
<br>
10 = ADC_CLK/4.
<br>
11 = ADC_CLK/16.
<br>
</div></td></tr><tr><td>
[15:8]</td><td>TRGDLYCNT</td><td><div style="word-wrap: break-word;"><b>ADC Sample Module Start of Conversion Trigger Delay Time
</b><br>
Trigger delay time = TRGDLYCNT x ADC_CLK x n (n=1,2,4,16 from TRGDLYDIV setting).
<br>
</div></td></tr><tr><td>
[20:16]</td><td>TRGSEL</td><td><div style="word-wrap: break-word;"><b>ADC Sample Module Start of Conversion Trigger Source Selection
</b><br>
0H = Disable trigger.
<br>
1H = External trigger from EADC0_ST pin input.
<br>
2H = ADC ADINT0 interrupt EOC (End of conversion) pulse trigger.
<br>
3H = ADC ADINT1 interrupt EOC (End of conversion) pulse trigger.
<br>
4H = Timer0 overflow pulse trigger.
<br>
5H = Timer1 overflow pulse trigger.
<br>
6H = Timer2 overflow pulse trigger.
<br>
7H = Timer3 overflow pulse trigger.
<br>
8H = EPWM0TG0.
<br>
9H = EPWM0TG1.
<br>
AH = EPWM0TG2.
<br>
BH = EPWM0TG3.
<br>
CH = EPWM0TG4.
<br>
DH = EPWM0TG5.
<br>
EH = EPWM1TG0.
<br>
FH = EPWM1TG1.
<br>
10H = EPWM1TG2.
<br>
11H = EPWM1TG3.
<br>
12H = EPWM1TG4.
<br>
13H = EPWM1TG5.
<br>
14H = BPWM0TG.
<br>
15H = BPWM1TG.
<br>
other = Reserved.
<br>
</div></td></tr><tr><td>
[22]</td><td>INTPOS</td><td><div style="word-wrap: break-word;"><b>Interrupt Flag Position Select
</b><br>
0 = Set ADIFn (EADC_STATUS2[n], n=0~3) at ADC end of conversion.
<br>
1 = Set ADIFn (EADC_STATUS2[n], n=0~3) at ADC start of conversion.
<br>
</div></td></tr><tr><td>
[23]</td><td>DBMEN</td><td><div style="word-wrap: break-word;"><b>Double Buffer Mode Enable Bit
</b><br>
0 = Sample has one sample result register. (default).
<br>
1 = Sample has two sample result registers.
<br>
</div></td></tr><tr><td>
[31:24]</td><td>EXTSMPT</td><td><div style="word-wrap: break-word;"><b>ADC Sampling Time Extend
</b><br>
When ADC converting at high conversion rate, the sampling time of analog input voltage may not enough if input channel loading is heavy, user can extend ADC sampling time after trigger source is coming to get enough sampling time.
<br>
The range of start delay time is from 0~255 ADC clock.
<br>
</div></td></tr></tbody></table></html>

 </p>

<p class="definition">Definition at line <a class="el" href="eadc__reg_8h_source.html#l01207">1207</a> of file <a class="el" href="eadc__reg_8h_source.html">eadc_reg.h</a>.</p>

</div>
</div>
<a id="a3a9e9eae753312ea434da7d544bbf808" name="a3a9e9eae753312ea434da7d544bbf808"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3a9e9eae753312ea434da7d544bbf808">&#9670;&nbsp;</a></span>STATUS0</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">EADC_T::STATUS0</td>
        </tr>
      </table>
</div><div class="memdoc">
<p >[0x00f0] ADC Status Register 0 <br  />
</p>
<p > 

<html><table class="fixed" border="1" style="border-collapse:collapse;" borderColor=black ><col width="75px" /><col width="125px" /><col width="700px" /><caption align="left"><font size="3">STATUS0
</font><br><p> <font size="2">
Offset: 0xF0  ADC Status Register 0
</font></caption><thread><tr bgcolor="#8A0808" ><td><font color=white><b>Bits</b></font></td><td><font color=white><b>Field</b></font></td><td><font color=white><b>Descriptions</b></font></td></tr></thread><tbody>
<tr><td>
[15:0]</td><td>VALID</td><td><div style="word-wrap: break-word;"><b>EADC_DAT0~15 Data Valid Flag
</b><br>
It is a mirror of VALID bit in sample module ADC result data register EADC_DATn. (n=0~18).
<br>
</div></td></tr><tr><td>
[31:16]</td><td>OV</td><td><div style="word-wrap: break-word;"><b>EADC_DAT0~15 Overrun Flag
</b><br>
It is a mirror to OV bit in sample module ADC result data register EADC_DATn. (n=0~18).
<br>
</div></td></tr></tbody></table></html>

 </p>

<p class="definition">Definition at line <a class="el" href="eadc__reg_8h_source.html#l01213">1213</a> of file <a class="el" href="eadc__reg_8h_source.html">eadc_reg.h</a>.</p>

</div>
</div>
<a id="ab5ccb62b13782cf82084dc2c2a4bcdc7" name="ab5ccb62b13782cf82084dc2c2a4bcdc7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab5ccb62b13782cf82084dc2c2a4bcdc7">&#9670;&nbsp;</a></span>STATUS1</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">EADC_T::STATUS1</td>
        </tr>
      </table>
</div><div class="memdoc">
<p >[0x00f4] ADC Status Register 1 <br  />
</p>
<p > 

<html><table class="fixed" border="1" style="border-collapse:collapse;" borderColor=black ><col width="75px" /><col width="125px" /><col width="700px" /><caption align="left"><font size="3">STATUS1
</font><br><p> <font size="2">
Offset: 0xF4  ADC Status Register 1
</font></caption><thread><tr bgcolor="#8A0808" ><td><font color=white><b>Bits</b></font></td><td><font color=white><b>Field</b></font></td><td><font color=white><b>Descriptions</b></font></td></tr></thread><tbody>
<tr><td>
[2:0]</td><td>VALID</td><td><div style="word-wrap: break-word;"><b>EADC_DAT16~18 Data Valid Flag
</b><br>
It is a mirror of VALID bit in sample module ADC result data register EADC_DATn. (n=0~18).
<br>
</div></td></tr><tr><td>
[18:16]</td><td>OV</td><td><div style="word-wrap: break-word;"><b>EADC_DAT16~18 Overrun Flag
</b><br>
It is a mirror to OV bit in sample module ADC result data register EADC_DATn. (n=0~18).
<br>
</div></td></tr></tbody></table></html>

 </p>

<p class="definition">Definition at line <a class="el" href="eadc__reg_8h_source.html#l01214">1214</a> of file <a class="el" href="eadc__reg_8h_source.html">eadc_reg.h</a>.</p>

</div>
</div>
<a id="a81ef3b5f47e896bade83e833837fcd37" name="a81ef3b5f47e896bade83e833837fcd37"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a81ef3b5f47e896bade83e833837fcd37">&#9670;&nbsp;</a></span>STATUS2</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">EADC_T::STATUS2</td>
        </tr>
      </table>
</div><div class="memdoc">
<p >[0x00f8] ADC Status Register 2 <br  />
</p>
<p > 

<html><table class="fixed" border="1" style="border-collapse:collapse;" borderColor=black ><col width="75px" /><col width="125px" /><col width="700px" /><caption align="left"><font size="3">STATUS2
</font><br><p> <font size="2">
Offset: 0xF8  ADC Status Register 2
</font></caption><thread><tr bgcolor="#8A0808" ><td><font color=white><b>Bits</b></font></td><td><font color=white><b>Field</b></font></td><td><font color=white><b>Descriptions</b></font></td></tr></thread><tbody>
<tr><td>
[0]</td><td>ADIF0</td><td><div style="word-wrap: break-word;"><b>ADC ADINT0 Interrupt Flag
</b><br>
0 = No ADINT0 interrupt pulse received.
<br>
1 = ADINT0 interrupt pulse has been received.
<br>
Note1: This bit is cleared by writing 1 to it.
<br>
Note2:This bit indicates whether an ADC conversion of specific sample module has been completed
<br>
</div></td></tr><tr><td>
[1]</td><td>ADIF1</td><td><div style="word-wrap: break-word;"><b>ADC ADINT1 Interrupt Flag
</b><br>
0 = No ADINT1 interrupt pulse received.
<br>
1 = ADINT1 interrupt pulse has been received.
<br>
Note1: This bit is cleared by writing 1 to it.
<br>
Note2:This bit indicates whether an ADC conversion of specific sample module has been completed
<br>
</div></td></tr><tr><td>
[2]</td><td>ADIF2</td><td><div style="word-wrap: break-word;"><b>ADC ADINT2 Interrupt Flag
</b><br>
0 = No ADINT2 interrupt pulse received.
<br>
1 = ADINT2 interrupt pulse has been received.
<br>
Note1: This bit is cleared by writing 1 to it.
<br>
Note2:This bit indicates whether an ADC conversion of specific sample module has been completed
<br>
</div></td></tr><tr><td>
[3]</td><td>ADIF3</td><td><div style="word-wrap: break-word;"><b>ADC ADINT3 Interrupt Flag
</b><br>
0 = No ADINT3 interrupt pulse received.
<br>
1 = ADINT3 interrupt pulse has been received.
<br>
Note1: This bit is cleared by writing 1 to it.
<br>
Note2:This bit indicates whether an ADC conversion of specific sample module has been completed
<br>
</div></td></tr><tr><td>
[4]</td><td>ADCMPF0</td><td><div style="word-wrap: break-word;"><b>ADC Compare 0 Flag
</b><br>
When the specific sample module ADC conversion result meets setting condition in EADC_CMP0 then this bit is set to 1.
<br>
0 = Conversion result in EADC_DAT does not meet EADC_CMP0 register setting.
<br>
1 = Conversion result in EADC_DAT meets EADC_CMP0 register setting.
<br>
Note: This bit is cleared by writing 1 to it.
<br>
</div></td></tr><tr><td>
[5]</td><td>ADCMPF1</td><td><div style="word-wrap: break-word;"><b>ADC Compare 1 Flag
</b><br>
When the specific sample module ADC conversion result meets setting condition in EADC_CMP1 then this bit is set to 1.
<br>
0 = Conversion result in EADC_DAT does not meet EADC_CMP1 register setting.
<br>
1 = Conversion result in EADC_DAT meets EADC_CMP1 register setting.
<br>
Note: This bit is cleared by writing 1 to it.
<br>
</div></td></tr><tr><td>
[6]</td><td>ADCMPF2</td><td><div style="word-wrap: break-word;"><b>ADC Compare 2 Flag
</b><br>
When the specific sample module ADC conversion result meets setting condition in EADC_CMP2 then this bit is set to 1.
<br>
0 = Conversion result in EADC_DAT does not meet EADC_CMP2 register setting.
<br>
1 = Conversion result in EADC_DAT meets EADC_CMP2 register setting.
<br>
Note: This bit is cleared by writing 1 to it.
<br>
</div></td></tr><tr><td>
[7]</td><td>ADCMPF3</td><td><div style="word-wrap: break-word;"><b>ADC Compare 3 Flag
</b><br>
When the specific sample module ADC conversion result meets setting condition in EADC_CMP3 then this bit is set to 1.
<br>
0 = Conversion result in EADC_DAT does not meet EADC_CMP3 register setting.
<br>
1 = Conversion result in EADC_DAT meets EADC_CMP3 register setting.
<br>
Note: This bit is cleared by writing 1 to it.
<br>
</div></td></tr><tr><td>
[8]</td><td>ADOVIF0</td><td><div style="word-wrap: break-word;"><b>ADC ADINT0 Interrupt Flag Overrun
</b><br>
0 = ADINT0 interrupt flag is not overwritten to 1.
<br>
1 = ADINT0 interrupt flag is overwritten to 1.
<br>
Note: This bit is cleared by writing 1 to it.
<br>
</div></td></tr><tr><td>
[9]</td><td>ADOVIF1</td><td><div style="word-wrap: break-word;"><b>ADC ADINT1 Interrupt Flag Overrun
</b><br>
0 = ADINT1 interrupt flag is not overwritten to 1.
<br>
1 = ADINT1 interrupt flag is overwritten to 1.
<br>
Note: This bit is cleared by writing 1 to it.
<br>
</div></td></tr><tr><td>
[10]</td><td>ADOVIF2</td><td><div style="word-wrap: break-word;"><b>ADC ADINT2 Interrupt Flag Overrun
</b><br>
0 = ADINT2 interrupt flag is not overwritten to 1.
<br>
1 = ADINT2 interrupt flag is s overwritten to 1.
<br>
Note: This bit is cleared by writing 1 to it.
<br>
</div></td></tr><tr><td>
[11]</td><td>ADOVIF3</td><td><div style="word-wrap: break-word;"><b>ADC ADINT3 Interrupt Flag Overrun
</b><br>
0 = ADINT3 interrupt flag is not overwritten to 1.
<br>
1 = ADINT3 interrupt flag is overwritten to 1.
<br>
Note: This bit is cleared by writing 1 to it.
<br>
</div></td></tr><tr><td>
[12]</td><td>ADCMPO0</td><td><div style="word-wrap: break-word;"><b>ADC Compare 0 Output Status (Read Only)
</b><br>
The 12 bits compare0 data CMPDAT0 (EADC_CMP0[27:16]) is used to compare with conversion result of specified sample module
<br>
User can use it to monitor the external analog input pin voltage status.
<br>
0 = Conversion result in EADC_DAT less than CMPDAT0 setting.
<br>
1 = Conversion result in EADC_DAT great than or equal CMPDAT0 setting.
<br>
</div></td></tr><tr><td>
[13]</td><td>ADCMPO1</td><td><div style="word-wrap: break-word;"><b>ADC Compare 1 Output Status (Read Only)
</b><br>
The 12 bits compare1 data CMPDAT1 (EADC_CMP1[27:16]) is used to compare with conversion result of specified sample module
<br>
User can use it to monitor the external analog input pin voltage status.
<br>
0 = Conversion result in EADC_DAT less than CMPDAT1 setting.
<br>
1 = Conversion result in EADC_DAT great than or equal CMPDAT1 setting.
<br>
</div></td></tr><tr><td>
[14]</td><td>ADCMPO2</td><td><div style="word-wrap: break-word;"><b>ADC Compare 2 Output Status (Read Only)
</b><br>
The 12 bits compare2 data CMPDAT2 (EADC_CMP2[27:16]) is used to compare with conversion result of specified sample module
<br>
User can use it to monitor the external analog input pin voltage status.
<br>
0 = Conversion result in EADC_DAT less than CMPDAT2 setting.
<br>
1 = Conversion result in EADC_DAT great than or equal CMPDAT2 setting.
<br>
</div></td></tr><tr><td>
[15]</td><td>ADCMPO3</td><td><div style="word-wrap: break-word;"><b>ADC Compare 3 Output Status (Read Only)
</b><br>
The 12 bits compare3 data CMPDAT3 (EADC_CMP3[27:16]) is used to compare with conversion result of specified sample module
<br>
User can use it to monitor the external analog input pin voltage status.
<br>
0 = Conversion result in EADC_DAT less than CMPDAT3 setting.
<br>
1 = Conversion result in EADC_DAT great than or equal CMPDAT3 setting.
<br>
</div></td></tr><tr><td>
[20:16]</td><td>CHANNEL</td><td><div style="word-wrap: break-word;"><b>Current Conversion Channel (Read Only)
</b><br>
This filed reflects ADC current conversion channel when BUSY=1.
<br>
It is read only.
<br>
00H = EADC_CH0.
<br>
01H = EADC_CH1.
<br>
02H = EADC_CH2.
<br>
03H = EADC_CH3.
<br>
04H = EADC_CH4.
<br>
05H = EADC_CH5.
<br>
06H = EADC_CH6.
<br>
07H = EADC_CH7.
<br>
08H = EADC_CH8.
<br>
09H = EADC_CH9.
<br>
0AH = EADC_CH10.
<br>
0BH = EADC_CH11.
<br>
0CH = EADC_CH12.
<br>
0DH = EADC_CH13.
<br>
0EH = EADC_CH14.
<br>
0FH = EADC_CH15.
<br>
10H = VBG.
<br>
11H = VTEMP.
<br>
12H = VBAT/4.
<br>
</div></td></tr><tr><td>
[23]</td><td>BUSY</td><td><div style="word-wrap: break-word;"><b>Busy/Idle (Read Only)
</b><br>
0 = EADC is in idle state.
<br>
1 = EADC is busy at conversion.
<br>
</div></td></tr><tr><td>
[24]</td><td>ADOVIF</td><td><div style="word-wrap: break-word;"><b>All ADC Interrupt Flag Overrun Bits Check (Read Only)
</b><br>
n=0~3.
<br>
0 = None of ADINT interrupt flag ADOVIFn (EADC_STATUS2[11:8]) is overwritten to 1.
<br>
1 = Any one of ADINT interrupt flag ADOVIFn (EADC_STATUS2[11:8]) is overwritten to 1.
<br>
Note: This bit will keep 1 when any ADOVIFn Flag is equal to 1.
<br>
</div></td></tr><tr><td>
[25]</td><td>STOVF</td><td><div style="word-wrap: break-word;"><b>for All ADC Sample Module Start of Conversion Overrun Flags Check (Read Only)
</b><br>
n=0~18.
<br>
0 = None of sample module event overrun flag SPOVFn (EADC_OVSTS[n]) is set to 1.
<br>
1 = Any one of sample module event overrun flag SPOVFn (EADC_OVSTS[n]) is set to 1.
<br>
Note: This bit will keep 1 when any SPOVFn Flag is equal to 1.
<br>
</div></td></tr><tr><td>
[26]</td><td>AVALID</td><td><div style="word-wrap: break-word;"><b>for All Sample Module ADC Result Data Register EADC_DAT Data Valid Flag Check (Read Only)
</b><br>
n=0~18.
<br>
0 = None of sample module data register valid flag VALIDn (EADC_DATn[17]) is set to 1.
<br>
1 = Any one of sample module data register valid flag VALIDn (EADC_DATn[17]) is set to 1.
<br>
Note: This bit will keep 1 when any VALIDn Flag is equal to 1.
<br>
</div></td></tr><tr><td>
[27]</td><td>AOV</td><td><div style="word-wrap: break-word;"><b>for All Sample Module ADC Result Data Register Overrun Flags Check (Read Only)
</b><br>
n=0~18.
<br>
0 = None of sample module data register overrun flag OVn (EADC_DATn[16]) is set to 1.
<br>
1 = Any one of sample module data register overrun flag OVn (EADC_DATn[16]) is set to 1.
<br>
Note: This bit will keep 1 when any OVn Flag is equal to 1.
<br>
</div></td></tr></tbody></table></html>

 </p>

<p class="definition">Definition at line <a class="el" href="eadc__reg_8h_source.html#l01215">1215</a> of file <a class="el" href="eadc__reg_8h_source.html">eadc_reg.h</a>.</p>

</div>
</div>
<a id="aa2a9209b1d93bce63d901632c57d5e81" name="aa2a9209b1d93bce63d901632c57d5e81"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa2a9209b1d93bce63d901632c57d5e81">&#9670;&nbsp;</a></span>STATUS3</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">EADC_T::STATUS3</td>
        </tr>
      </table>
</div><div class="memdoc">
<p >[0x00fc] ADC Status Register 3 <br  />
</p>
<p > 

<html><table class="fixed" border="1" style="border-collapse:collapse;" borderColor=black ><col width="75px" /><col width="125px" /><col width="700px" /><caption align="left"><font size="3">STATUS3
</font><br><p> <font size="2">
Offset: 0xFC  ADC Status Register 3
</font></caption><thread><tr bgcolor="#8A0808" ><td><font color=white><b>Bits</b></font></td><td><font color=white><b>Field</b></font></td><td><font color=white><b>Descriptions</b></font></td></tr></thread><tbody>
<tr><td>
[4:0]</td><td>CURSPL</td><td><div style="word-wrap: break-word;"><b>ADC Current Sample Module
</b><br>
This register show the current ADC is controlled by which sample module control logic modules.
<br>
If the ADC is Idle, this bit filed will set to 0x1F.
<br>
This is a read only register.
<br>
</div></td></tr></tbody></table></html>

 </p>

<p class="definition">Definition at line <a class="el" href="eadc__reg_8h_source.html#l01216">1216</a> of file <a class="el" href="eadc__reg_8h_source.html">eadc_reg.h</a>.</p>

</div>
</div>
<a id="adbadd7fc24373ee59089a73dde2cabee" name="adbadd7fc24373ee59089a73dde2cabee"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adbadd7fc24373ee59089a73dde2cabee">&#9670;&nbsp;</a></span>SWTRG</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">EADC_T::SWTRG</td>
        </tr>
      </table>
</div><div class="memdoc">
<p >[0x0054] ADC Sample Module Software Start Register <br  />
</p>
<p > 

<html><table class="fixed" border="1" style="border-collapse:collapse;" borderColor=black ><col width="75px" /><col width="125px" /><col width="700px" /><caption align="left"><font size="3">SWTRG
</font><br><p> <font size="2">
Offset: 0x54  ADC Sample Module Software Start Register
</font></caption><thread><tr bgcolor="#8A0808" ><td><font color=white><b>Bits</b></font></td><td><font color=white><b>Field</b></font></td><td><font color=white><b>Descriptions</b></font></td></tr></thread><tbody>
<tr><td>
[18:0]</td><td>SWTRG</td><td><div style="word-wrap: break-word;"><b>ADC Sample Module 0~18 Software Force to Start ADC Conversion
</b><br>
0 = No effect.
<br>
1 = Cause an ADC conversion when the priority is given to sample module.
<br>
Note: After write this register to start ADC conversion, the EADC_PENDSTS register will show which sample module will conversion
<br>
If user want to disable the conversion of the sample module, user can write EADC_PENDSTS register to clear it.
<br>
</div></td></tr></tbody></table></html>

 </p>

<p class="definition">Definition at line <a class="el" href="eadc__reg_8h_source.html#l01201">1201</a> of file <a class="el" href="eadc__reg_8h_source.html">eadc_reg.h</a>.</p>

</div>
</div>
<hr/>The documentation for this struct was generated from the following file:<ul>
<li>Library/Device/Nuvoton/M480/Include/<a class="el" href="eadc__reg_8h_source.html">eadc_reg.h</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Thu Sep 18 2025 10:07:26 for M480 BSP by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.3
</small></address>
</body>
</html>
