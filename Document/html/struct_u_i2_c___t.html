<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.3"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>M480 BSP: UI2C_T Struct Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectlogo"><img alt="Logo" src="m4.jpg"/></td>
  <td id="projectalign">
   <div id="projectname">M480 BSP<span id="projectnumber">&#160;V3.0.7000</span>
   </div>
   <div id="projectbrief">The Board Support Package for M480 Series</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.3 -->
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',false,false,'search.php','Search');
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-attribs">Data Fields</a>  </div>
  <div class="headertitle"><div class="title">UI2C_T Struct Reference<div class="ingroups"><a class="el" href="group___r_e_g_i_s_t_e_r.html">Control Register</a></div></div></div>
</div><!--header-->
<div class="contents">

<p><code>#include &lt;<a class="el" href="ui2c__reg_8h_source.html">ui2c_reg.h</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-attribs" name="pub-attribs"></a>
Data Fields</h2></td></tr>
<tr class="memitem:a810ab1775f8f48f96fb34e6a7a476552"><td class="memItemLeft" align="right" valign="top">__IO uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_u_i2_c___t.html#a810ab1775f8f48f96fb34e6a7a476552">CTL</a></td></tr>
<tr class="separator:a810ab1775f8f48f96fb34e6a7a476552"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a69f9e147f44b098bd64bb619f9507f0e"><td class="memItemLeft" align="right" valign="top">__IO uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_u_i2_c___t.html#a69f9e147f44b098bd64bb619f9507f0e">BRGEN</a></td></tr>
<tr class="separator:a69f9e147f44b098bd64bb619f9507f0e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a428be52d828557e9bca235ef57d506bf"><td class="memItemLeft" align="right" valign="top">__IO uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_u_i2_c___t.html#a428be52d828557e9bca235ef57d506bf">LINECTL</a></td></tr>
<tr class="separator:a428be52d828557e9bca235ef57d506bf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adb0614c8d5c4d1870a8589c650247f2d"><td class="memItemLeft" align="right" valign="top">__O uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_u_i2_c___t.html#adb0614c8d5c4d1870a8589c650247f2d">TXDAT</a></td></tr>
<tr class="separator:adb0614c8d5c4d1870a8589c650247f2d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3ee271dde56e3a144d7921e658066fcc"><td class="memItemLeft" align="right" valign="top">__I uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_u_i2_c___t.html#a3ee271dde56e3a144d7921e658066fcc">RXDAT</a></td></tr>
<tr class="separator:a3ee271dde56e3a144d7921e658066fcc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a67f9cb6e896b34b69175cb9e2b908cba"><td class="memItemLeft" align="right" valign="top">__IO uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_u_i2_c___t.html#a67f9cb6e896b34b69175cb9e2b908cba">DEVADDR0</a></td></tr>
<tr class="separator:a67f9cb6e896b34b69175cb9e2b908cba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a06969bf80a7ebb0afcdb63d9b5bfd508"><td class="memItemLeft" align="right" valign="top">__IO uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_u_i2_c___t.html#a06969bf80a7ebb0afcdb63d9b5bfd508">DEVADDR1</a></td></tr>
<tr class="separator:a06969bf80a7ebb0afcdb63d9b5bfd508"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2ed6fd5a21b466bc727194ca0d26512c"><td class="memItemLeft" align="right" valign="top">__IO uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_u_i2_c___t.html#a2ed6fd5a21b466bc727194ca0d26512c">ADDRMSK0</a></td></tr>
<tr class="separator:a2ed6fd5a21b466bc727194ca0d26512c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a72195fe8f0f7570f84d8085b58ef2e60"><td class="memItemLeft" align="right" valign="top">__IO uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_u_i2_c___t.html#a72195fe8f0f7570f84d8085b58ef2e60">ADDRMSK1</a></td></tr>
<tr class="separator:a72195fe8f0f7570f84d8085b58ef2e60"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2b48eac52f7512095abe983edf80d3c1"><td class="memItemLeft" align="right" valign="top">__IO uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_u_i2_c___t.html#a2b48eac52f7512095abe983edf80d3c1">WKCTL</a></td></tr>
<tr class="separator:a2b48eac52f7512095abe983edf80d3c1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7725466810a374986a99f9275a3f2a80"><td class="memItemLeft" align="right" valign="top">__IO uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_u_i2_c___t.html#a7725466810a374986a99f9275a3f2a80">WKSTS</a></td></tr>
<tr class="separator:a7725466810a374986a99f9275a3f2a80"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a420a3a2b6019bf7974b2a24a08978abc"><td class="memItemLeft" align="right" valign="top">__IO uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_u_i2_c___t.html#a420a3a2b6019bf7974b2a24a08978abc">PROTCTL</a></td></tr>
<tr class="separator:a420a3a2b6019bf7974b2a24a08978abc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab58d337f5a00e17f23c47a4fce873cee"><td class="memItemLeft" align="right" valign="top">__IO uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_u_i2_c___t.html#ab58d337f5a00e17f23c47a4fce873cee">PROTIEN</a></td></tr>
<tr class="separator:ab58d337f5a00e17f23c47a4fce873cee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1689cfe379c17e495e04c6834c322498"><td class="memItemLeft" align="right" valign="top">__IO uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_u_i2_c___t.html#a1689cfe379c17e495e04c6834c322498">PROTSTS</a></td></tr>
<tr class="separator:a1689cfe379c17e495e04c6834c322498"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3d7aa860bb0ff8d87f6e7ccdce2012b4"><td class="memItemLeft" align="right" valign="top">__IO uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_u_i2_c___t.html#a3d7aa860bb0ff8d87f6e7ccdce2012b4">ADMAT</a></td></tr>
<tr class="separator:a3d7aa860bb0ff8d87f6e7ccdce2012b4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae84984fd9c06318e2882ff68940d9095"><td class="memItemLeft" align="right" valign="top">__IO uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_u_i2_c___t.html#ae84984fd9c06318e2882ff68940d9095">TMCTL</a></td></tr>
<tr class="separator:ae84984fd9c06318e2882ff68940d9095"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><pre class="fragment">@addtogroup UI2C I2C Mode of USCI Controller(UI2C)
Memory Mapped Structure for UI2C Controller
</pre> 
<p class="definition">Definition at line <a class="el" href="ui2c__reg_8h_source.html#l00026">26</a> of file <a class="el" href="ui2c__reg_8h_source.html">ui2c_reg.h</a>.</p>
</div><h2 class="groupheader">Field Documentation</h2>
<a id="a2ed6fd5a21b466bc727194ca0d26512c" name="a2ed6fd5a21b466bc727194ca0d26512c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2ed6fd5a21b466bc727194ca0d26512c">&#9670;&nbsp;</a></span>ADDRMSK0</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UI2C_T::ADDRMSK0</td>
        </tr>
      </table>
</div><div class="memdoc">
<p >[0x004c] USCI Device Address Mask Register 0 <br  />
</p>
<p > 

<html><table class="fixed" border="1" style="border-collapse:collapse;" borderColor=black ><col width="75px" /><col width="125px" /><col width="700px" /><caption align="left"><font size="3">ADDRMSK0
</font><br><p> <font size="2">
Offset: 0x4C  USCI Device Address Mask Register 0
</font></caption><thread><tr bgcolor="#8A0808" ><td><font color=white><b>Bits</b></font></td><td><font color=white><b>Field</b></font></td><td><font color=white><b>Descriptions</b></font></td></tr></thread><tbody>
<tr><td>
[9:0]</td><td>ADDRMSK</td><td><div style="word-wrap: break-word;"><b>USCI Device Address Mask
</b><br>
0 = Mask Disabled (the received corresponding register bit should be exact the same as address register.).
<br>
1 = Mask Enabled (the received corresponding address bit is don't care.).
<br>
USCI support multiple address recognition with two address mask register
<br>
When the bit in the address mask register is set to one, it means the received corresponding address bit is don't-care
<br>
If the bit is set to zero, that means the received corresponding register bit should be exact the same as address register.
<br>
Note: The wake-up function can not use address mask.
<br>
</div></td></tr></tbody></table></html>

 </p>

<p class="definition">Definition at line <a class="el" href="ui2c__reg_8h_source.html#l00836">836</a> of file <a class="el" href="ui2c__reg_8h_source.html">ui2c_reg.h</a>.</p>

</div>
</div>
<a id="a72195fe8f0f7570f84d8085b58ef2e60" name="a72195fe8f0f7570f84d8085b58ef2e60"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a72195fe8f0f7570f84d8085b58ef2e60">&#9670;&nbsp;</a></span>ADDRMSK1</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UI2C_T::ADDRMSK1</td>
        </tr>
      </table>
</div><div class="memdoc">
<p >[0x0050] USCI Device Address Mask Register 1 <br  />
</p>
<p > 

<html><table class="fixed" border="1" style="border-collapse:collapse;" borderColor=black ><col width="75px" /><col width="125px" /><col width="700px" /><caption align="left"><font size="3">ADDRMSK1
</font><br><p> <font size="2">
Offset: 0x50  USCI Device Address Mask Register 1
</font></caption><thread><tr bgcolor="#8A0808" ><td><font color=white><b>Bits</b></font></td><td><font color=white><b>Field</b></font></td><td><font color=white><b>Descriptions</b></font></td></tr></thread><tbody>
<tr><td>
[9:0]</td><td>ADDRMSK</td><td><div style="word-wrap: break-word;"><b>USCI Device Address Mask
</b><br>
0 = Mask Disabled (the received corresponding register bit should be exact the same as address register.).
<br>
1 = Mask Enabled (the received corresponding address bit is don't care.).
<br>
USCI support multiple address recognition with two address mask register
<br>
When the bit in the address mask register is set to one, it means the received corresponding address bit is don't-care
<br>
If the bit is set to zero, that means the received corresponding register bit should be exact the same as address register.
<br>
Note: The wake-up function can not use address mask.
<br>
</div></td></tr></tbody></table></html>

 </p>

<p class="definition">Definition at line <a class="el" href="ui2c__reg_8h_source.html#l00837">837</a> of file <a class="el" href="ui2c__reg_8h_source.html">ui2c_reg.h</a>.</p>

</div>
</div>
<a id="a3d7aa860bb0ff8d87f6e7ccdce2012b4" name="a3d7aa860bb0ff8d87f6e7ccdce2012b4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3d7aa860bb0ff8d87f6e7ccdce2012b4">&#9670;&nbsp;</a></span>ADMAT</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UI2C_T::ADMAT</td>
        </tr>
      </table>
</div><div class="memdoc">
<p >[0x0088] I2C Slave Match Address Register <br  />
</p>
<p > 

<html><table class="fixed" border="1" style="border-collapse:collapse;" borderColor=black ><col width="75px" /><col width="125px" /><col width="700px" /><caption align="left"><font size="3">ADMAT
</font><br><p> <font size="2">
Offset: 0x88  I2C Slave Match Address Register
</font></caption><thread><tr bgcolor="#8A0808" ><td><font color=white><b>Bits</b></font></td><td><font color=white><b>Field</b></font></td><td><font color=white><b>Descriptions</b></font></td></tr></thread><tbody>
<tr><td>
[0]</td><td>ADMAT0</td><td><div style="word-wrap: break-word;"><b>USCI Address 0 Match Status Register
</b><br>
When address 0 is matched, hardware will inform which address used
<br>
This bit will set to 1, and software can write 1 to clear this bit.
<br>
</div></td></tr><tr><td>
[1]</td><td>ADMAT1</td><td><div style="word-wrap: break-word;"><b>USCI Address 1 Match Status Register
</b><br>
When address 1 is matched, hardware will inform which address used
<br>
This bit will set to 1, and software can write 1 to clear this bit.
<br>
</div></td></tr></tbody></table></html>

 </p>

<p class="definition">Definition at line <a class="el" href="ui2c__reg_8h_source.html#l00846">846</a> of file <a class="el" href="ui2c__reg_8h_source.html">ui2c_reg.h</a>.</p>

</div>
</div>
<a id="a69f9e147f44b098bd64bb619f9507f0e" name="a69f9e147f44b098bd64bb619f9507f0e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a69f9e147f44b098bd64bb619f9507f0e">&#9670;&nbsp;</a></span>BRGEN</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UI2C_T::BRGEN</td>
        </tr>
      </table>
</div><div class="memdoc">
<p >[0x0008] USCI Baud Rate Generator Register <br  />
</p>
<p > 

<html><table class="fixed" border="1" style="border-collapse:collapse;" borderColor=black ><col width="75px" /><col width="125px" /><col width="700px" /><caption align="left"><font size="3">BRGEN
</font><br><p> <font size="2">
Offset: 0x08  USCI Baud Rate Generator Register
</font></caption><thread><tr bgcolor="#8A0808" ><td><font color=white><b>Bits</b></font></td><td><font color=white><b>Field</b></font></td><td><font color=white><b>Descriptions</b></font></td></tr></thread><tbody>
<tr><td>
[0]</td><td>RCLKSEL</td><td><div style="word-wrap: break-word;"><b>Reference Clock Source Selection
</b><br>
This bit selects the source signal of reference clock (fREF_CLK).
<br>
0 = Peripheral device clock fPCLK.
<br>
1 = Reserved.
<br>
</div></td></tr><tr><td>
[1]</td><td>PTCLKSEL</td><td><div style="word-wrap: break-word;"><b>Protocol Clock Source Selection
</b><br>
This bit selects the source signal of protocol clock (fPROT_CLK).
<br>
0 = Reference clock fREF_CLK.
<br>
1 = fREF_CLK2 (its frequency is half of fREF_CLK).
<br>
</div></td></tr><tr><td>
[3:2]</td><td>SPCLKSEL</td><td><div style="word-wrap: break-word;"><b>Sample Clock Source Selection
</b><br>
This bit field used for the clock source selection of a sample clock (fSAMP_CLK) for the protocol processor.
<br>
00 = fSAMP_CLK = fDIV_CLK.
<br>
01 = fSAMP_CLK = fPROT_CLK.
<br>
10 = fSAMP_CLK = fSCLK.
<br>
11 = fSAMP_CLK = fREF_CLK.
<br>
</div></td></tr><tr><td>
[4]</td><td>TMCNTEN</td><td><div style="word-wrap: break-word;"><b>Time Measurement Counter Enable Bit
</b><br>
This bit enables the 10-bit timing measurement counter.
<br>
0 = Time measurement counter is Disabled.
<br>
1 = Time measurement counter is Enabled.
<br>
</div></td></tr><tr><td>
[5]</td><td>TMCNTSRC</td><td><div style="word-wrap: break-word;"><b>Time Measurement Counter Clock Source Selection
</b><br>
0 = Time measurement counter with fPROT_CLK.
<br>
1 = Time measurement counter with fDIV_CLK.
<br>
</div></td></tr><tr><td>
[9:8]</td><td>PDSCNT</td><td><div style="word-wrap: break-word;"><b>Pre-divider for Sample Counter
</b><br>
This bit field defines the divide ratio of the clock division from sample clock fSAMP_CLK
<br>
The divided frequency fPDS_CNT = fSAMP_CLK / (PDSCNT+1).
<br>
</div></td></tr><tr><td>
[14:10]</td><td>DSCNT</td><td><div style="word-wrap: break-word;"><b>Denominator for Sample Counter
</b><br>
This bit field defines the divide ratio of the sample clock fSAMP_CLK.
<br>
The divided frequency fDS_CNT = fPDS_CNT / (DSCNT+1).
<br>
Note: The maximum value of DSCNT is 0xF on UART mode and suggest to set over 4 to confirm the receiver data is sampled in right value
<br>
</div></td></tr><tr><td>
[25:16]</td><td>CLKDIV</td><td><div style="word-wrap: break-word;"><b>Clock Divider
</b><br>
This bit field defines the ratio between the protocol clock frequency fPROT_CLK and the clock divider frequency fDIV_CLK (fDIV_CLK = fPROT_CLK / (CLKDIV+1) ).
<br>
Note: In UART function, it can be updated by hardware in the 4th falling edge of the input data 0x55 when the auto baud rate function (ABREN(USCI_PROTCTL[6])) is enabled
<br>
The revised value is the average bit time between bit 5 and bit 6
<br>
The user can use revised CLKDIV and new BRDETITV (USCI_PROTCTL[24:16]) to calculate the precise baud rate.
<br>
</div></td></tr></tbody></table></html>

 </p>

<p class="definition">Definition at line <a class="el" href="ui2c__reg_8h_source.html#l00824">824</a> of file <a class="el" href="ui2c__reg_8h_source.html">ui2c_reg.h</a>.</p>

</div>
</div>
<a id="a810ab1775f8f48f96fb34e6a7a476552" name="a810ab1775f8f48f96fb34e6a7a476552"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a810ab1775f8f48f96fb34e6a7a476552">&#9670;&nbsp;</a></span>CTL</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UI2C_T::CTL</td>
        </tr>
      </table>
</div><div class="memdoc">
<p >[0x0000] USCI Control Register <br  />
</p>
<p > 

<html><table class="fixed" border="1" style="border-collapse:collapse;" borderColor=black ><col width="75px" /><col width="125px" /><col width="700px" /><caption align="left"><font size="3">CTL
</font><br><p> <font size="2">
Offset: 0x00  USCI Control Register
</font></caption><thread><tr bgcolor="#8A0808" ><td><font color=white><b>Bits</b></font></td><td><font color=white><b>Field</b></font></td><td><font color=white><b>Descriptions</b></font></td></tr></thread><tbody>
<tr><td>
[2:0]</td><td>FUNMODE</td><td><div style="word-wrap: break-word;"><b>Function Mode
</b><br>
This bit field selects the protocol for this USCI controller
<br>
Selecting a protocol that is not available or a reserved combination disables the USCI
<br>
When switching between two protocols, the USCI has to be disabled before selecting a new protocol
<br>
Simultaneously, the USCI will be reset when user write 000 to FUNMODE.
<br>
000 = The USCI is disabled. All protocol related state machines are set to idle state.
<br>
001 = The SPI protocol is selected.
<br>
010 = The UART protocol is selected.
<br>
100 = The I2C protocol is selected.
<br>
Note: Other bit combinations are reserved.
<br>
</div></td></tr></tbody></table></html>

 </p>

<p class="definition">Definition at line <a class="el" href="ui2c__reg_8h_source.html#l00820">820</a> of file <a class="el" href="ui2c__reg_8h_source.html">ui2c_reg.h</a>.</p>

</div>
</div>
<a id="a67f9cb6e896b34b69175cb9e2b908cba" name="a67f9cb6e896b34b69175cb9e2b908cba"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a67f9cb6e896b34b69175cb9e2b908cba">&#9670;&nbsp;</a></span>DEVADDR0</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UI2C_T::DEVADDR0</td>
        </tr>
      </table>
</div><div class="memdoc">
<p >[0x0044] USCI Device Address Register 0 <br  />
</p>
<p > 

<html><table class="fixed" border="1" style="border-collapse:collapse;" borderColor=black ><col width="75px" /><col width="125px" /><col width="700px" /><caption align="left"><font size="3">DEVADDR0
</font><br><p> <font size="2">
Offset: 0x44  USCI Device Address Register 0
</font></caption><thread><tr bgcolor="#8A0808" ><td><font color=white><b>Bits</b></font></td><td><font color=white><b>Field</b></font></td><td><font color=white><b>Descriptions</b></font></td></tr></thread><tbody>
<tr><td>
[9:0]</td><td>DEVADDR</td><td><div style="word-wrap: break-word;"><b>Device Address
</b><br>
In I2C protocol, this bit field contains the programmed slave address
<br>
If the first received address byte are 1111 0AAXB, the AA bits are compared to the bits DEVADDR[9:8] to check for address match, where the X is R/W bit
<br>
Then the second address byte is also compared to DEVADDR[7:0].
<br>
Note 1: The DEVADDR [9:7] must be set 3'b000 when I2C operating in 7-bit address mode.
<br>
Note 2: When software set 10'h000, the address can not be used.
<br>
</div></td></tr></tbody></table></html>

 </p>

<p class="definition">Definition at line <a class="el" href="ui2c__reg_8h_source.html#l00834">834</a> of file <a class="el" href="ui2c__reg_8h_source.html">ui2c_reg.h</a>.</p>

</div>
</div>
<a id="a06969bf80a7ebb0afcdb63d9b5bfd508" name="a06969bf80a7ebb0afcdb63d9b5bfd508"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a06969bf80a7ebb0afcdb63d9b5bfd508">&#9670;&nbsp;</a></span>DEVADDR1</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UI2C_T::DEVADDR1</td>
        </tr>
      </table>
</div><div class="memdoc">
<p >[0x0048] USCI Device Address Register 1 <br  />
</p>
<p > 

<html><table class="fixed" border="1" style="border-collapse:collapse;" borderColor=black ><col width="75px" /><col width="125px" /><col width="700px" /><caption align="left"><font size="3">DEVADDR1
</font><br><p> <font size="2">
Offset: 0x48  USCI Device Address Register 1
</font></caption><thread><tr bgcolor="#8A0808" ><td><font color=white><b>Bits</b></font></td><td><font color=white><b>Field</b></font></td><td><font color=white><b>Descriptions</b></font></td></tr></thread><tbody>
<tr><td>
[9:0]</td><td>DEVADDR</td><td><div style="word-wrap: break-word;"><b>Device Address
</b><br>
In I2C protocol, this bit field contains the programmed slave address
<br>
If the first received address byte are 1111 0AAXB, the AA bits are compared to the bits DEVADDR[9:8] to check for address match, where the X is R/W bit
<br>
Then the second address byte is also compared to DEVADDR[7:0].
<br>
Note 1: The DEVADDR [9:7] must be set 3'000 when I2C operating in 7-bit address mode.
<br>
Note 2: When software set 10'h000, the address can not be used.
<br>
</div></td></tr></tbody></table></html>

 </p>

<p class="definition">Definition at line <a class="el" href="ui2c__reg_8h_source.html#l00835">835</a> of file <a class="el" href="ui2c__reg_8h_source.html">ui2c_reg.h</a>.</p>

</div>
</div>
<a id="a428be52d828557e9bca235ef57d506bf" name="a428be52d828557e9bca235ef57d506bf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a428be52d828557e9bca235ef57d506bf">&#9670;&nbsp;</a></span>LINECTL</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UI2C_T::LINECTL</td>
        </tr>
      </table>
</div><div class="memdoc">
<p >[0x002c] USCI Line Control Register <br  />
</p>
<p > 

<html><table class="fixed" border="1" style="border-collapse:collapse;" borderColor=black ><col width="75px" /><col width="125px" /><col width="700px" /><caption align="left"><font size="3">LINECTL
</font><br><p> <font size="2">
Offset: 0x2C  USCI Line Control Register
</font></caption><thread><tr bgcolor="#8A0808" ><td><font color=white><b>Bits</b></font></td><td><font color=white><b>Field</b></font></td><td><font color=white><b>Descriptions</b></font></td></tr></thread><tbody>
<tr><td>
[0]</td><td>LSB</td><td><div style="word-wrap: break-word;"><b>LSB First Transmission Selection
</b><br>
0 = The MSB, which bit of transmit/receive data buffer depends on the setting of DWIDTH, is transmitted/received first.
<br>
1 = The LSB, the bit 0 of data buffer, will be transmitted/received first.
<br>
</div></td></tr><tr><td>
[11:8]</td><td>DWIDTH</td><td><div style="word-wrap: break-word;"><b>Word Length of Transmission
</b><br>
This bit field defines the data word length (amount of bits) for reception and transmission
<br>
The data word is always right-aligned in the data buffer
<br>
USCI support word length from 4 to 16 bits.
<br>
0x0: The data word contains 16 bits located at bit positions [15:0].
<br>
0x1: Reserved.
<br>
0x2: Reserved.
<br>
0x3: Reserved.
<br>
0x4: The data word contains 4 bits located at bit positions [3:0].
<br>
0x5: The data word contains 5 bits located at bit positions [4:0].
<br>
...
<br>
0xF: The data word contains 15 bits located at bit positions [14:0].
<br>
Note: In UART protocol, the length can be configured as 6~13 bits
<br>
And in I2C protocol, the length fixed as 8 bits.
<br>
</div></td></tr></tbody></table></html>

 </p>

<p class="definition">Definition at line <a class="el" href="ui2c__reg_8h_source.html#l00828">828</a> of file <a class="el" href="ui2c__reg_8h_source.html">ui2c_reg.h</a>.</p>

</div>
</div>
<a id="a420a3a2b6019bf7974b2a24a08978abc" name="a420a3a2b6019bf7974b2a24a08978abc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a420a3a2b6019bf7974b2a24a08978abc">&#9670;&nbsp;</a></span>PROTCTL</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UI2C_T::PROTCTL</td>
        </tr>
      </table>
</div><div class="memdoc">
<p >[0x005c] USCI Protocol Control Register <br  />
</p>
<p > 

<html><table class="fixed" border="1" style="border-collapse:collapse;" borderColor=black ><col width="75px" /><col width="125px" /><col width="700px" /><caption align="left"><font size="3">PROTCTL
</font><br><p> <font size="2">
Offset: 0x5C  USCI Protocol Control Register
</font></caption><thread><tr bgcolor="#8A0808" ><td><font color=white><b>Bits</b></font></td><td><font color=white><b>Field</b></font></td><td><font color=white><b>Descriptions</b></font></td></tr></thread><tbody>
<tr><td>
[0]</td><td>GCFUNC</td><td><div style="word-wrap: break-word;"><b>General Call Function
</b><br>
0 = General Call Function Disabled.
<br>
1 = General Call Function Enabled.
<br>
</div></td></tr><tr><td>
[1]</td><td>AA</td><td><div style="word-wrap: break-word;"><b>Assert Acknowledge Control
</b><br>
When AA=1 prior to address or data received, an acknowledged (low level to SDA) will be returned during the acknowledge clock pulse on the SCL line when 1.) A slave is acknowledging the address sent from master, 2.) The receiver devices are acknowledging the data sent by transmitter
<br>
When AA=0 prior to address or data received, a Not acknowledged (high level to SDA) will be returned during the acknowledge clock pulse on the SCL line.
<br>
</div></td></tr><tr><td>
[2]</td><td>STO</td><td><div style="word-wrap: break-word;"><b>I2C STOP Control
</b><br>
In Master mode, setting STO to transmit a STOP condition to bus then I2C hardware will check the bus condition if a STOP condition is detected this bit will be cleared by hardware automatically
<br>
In a slave mode, setting STO resets I2C hardware to the defined "not addressed" slave mode when bus error (USCI_PROTSTS.ERRIF = 1).
<br>
</div></td></tr><tr><td>
[3]</td><td>STA</td><td><div style="word-wrap: break-word;"><b>I2C START Control
</b><br>
Setting STA to logic 1 to enter Master mode, the I2C hardware sends a START or repeat START condition to bus when the bus is free.
<br>
</div></td></tr><tr><td>
[4]</td><td>ADDR10EN</td><td><div style="word-wrap: break-word;"><b>Address 10-bit Function Enable Bit
</b><br>
0 = Address match 10 bit function is disabled.
<br>
1 = Address match 10 bit function is enabled.
<br>
</div></td></tr><tr><td>
[5]</td><td>PTRG</td><td><div style="word-wrap: break-word;"><b>I2C Protocol Trigger (Write Only)
</b><br>
When a new state is present in the USCI_PROTSTS register, if the related interrupt enable bits are set, the I2C interrupt is requested
<br>
It must write one by software to this bit after the related interrupt flags are set to 1 and the I2C protocol function will go ahead until the STOP is active or the PROTEN is disabled.
<br>
0 = I2C's stretch disabled and the I2C protocol function will go ahead.
<br>
1 = I2C's stretch active.
<br>
</div></td></tr><tr><td>
[8]</td><td>SCLOUTEN</td><td><div style="word-wrap: break-word;"><b>SCL Output Enable Bit
</b><br>
This bit enables monitor pulling SCL to low
<br>
This monitor will pull SCL to low until it has had time to respond to an I2C interrupt.
<br>
0 = SCL output will be forced high due to open drain mechanism.
<br>
1 = I2C module may act as a slave peripheral just like in normal operation, the I2C holds the clock line low until it has had time to clear I2C interrupt.
<br>
</div></td></tr><tr><td>
[9]</td><td>MONEN</td><td><div style="word-wrap: break-word;"><b>Monitor Mode Enable Bit
</b><br>
This bit enables monitor mode
<br>
In monitor mode the SDA output will be put in high impedance mode
<br>
This prevents the I2C module from outputting data of any kind (including ACK) onto the I2C data bus.
<br>
0 = The monitor mode is disabled.
<br>
1 = The monitor mode is enabled.
<br>
Note: Depending on the state of the SCLOUTEN bit, the SCL output may be also forced high, preventing the module from having control over the I2C clock line.
<br>
</div></td></tr><tr><td>
[25:16]</td><td>TOCNT</td><td><div style="word-wrap: break-word;"><b>Time-out Clock Cycle
</b><br>
This bit field indicates how many clock cycle selected by TMCNTSRC (USCI_BRGEN [5]) when each interrupt flags are clear
<br>
The time-out is enable when TOCNT bigger than 0.
<br>
Note: The TMCNTSRC (USCI_BRGEN [5]) must be set zero on I2C mode.
<br>
</div></td></tr><tr><td>
[31]</td><td>PROTEN</td><td><div style="word-wrap: break-word;"><b>I2C Protocol Enable Bit
</b><br>
0 = I2C Protocol disable.
<br>
1 = I2C Protocol enable.
<br>
</div></td></tr></tbody></table></html>

 </p>

<p class="definition">Definition at line <a class="el" href="ui2c__reg_8h_source.html#l00840">840</a> of file <a class="el" href="ui2c__reg_8h_source.html">ui2c_reg.h</a>.</p>

</div>
</div>
<a id="ab58d337f5a00e17f23c47a4fce873cee" name="ab58d337f5a00e17f23c47a4fce873cee"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab58d337f5a00e17f23c47a4fce873cee">&#9670;&nbsp;</a></span>PROTIEN</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UI2C_T::PROTIEN</td>
        </tr>
      </table>
</div><div class="memdoc">
<p >[0x0060] USCI Protocol Interrupt Enable Register <br  />
</p>
<p > 

<html><table class="fixed" border="1" style="border-collapse:collapse;" borderColor=black ><col width="75px" /><col width="125px" /><col width="700px" /><caption align="left"><font size="3">PROTIEN
</font><br><p> <font size="2">
Offset: 0x60  USCI Protocol Interrupt Enable Register
</font></caption><thread><tr bgcolor="#8A0808" ><td><font color=white><b>Bits</b></font></td><td><font color=white><b>Field</b></font></td><td><font color=white><b>Descriptions</b></font></td></tr></thread><tbody>
<tr><td>
[0]</td><td>TOIEN</td><td><div style="word-wrap: break-word;"><b>Time-out Interrupt Enable Control
</b><br>
In I2C protocol, this bit enables the interrupt generation in case of a time-out event.
<br>
0 = The time-out interrupt is disabled.
<br>
1 = The time-out interrupt is enabled.
<br>
</div></td></tr><tr><td>
[1]</td><td>STARIEN</td><td><div style="word-wrap: break-word;"><b>Start Condition Received Interrupt Enable Control
</b><br>
This bit enables the generation of a protocol interrupt if a start condition is detected.
<br>
0 = The start condition interrupt is disabled.
<br>
1 = The start condition interrupt is enabled.
<br>
</div></td></tr><tr><td>
[2]</td><td>STORIEN</td><td><div style="word-wrap: break-word;"><b>Stop Condition Received Interrupt Enable Control
</b><br>
This bit enables the generation of a protocol interrupt if a stop condition is detected.
<br>
0 = The stop condition interrupt is disabled.
<br>
1 = The stop condition interrupt is enabled.
<br>
</div></td></tr><tr><td>
[3]</td><td>NACKIEN</td><td><div style="word-wrap: break-word;"><b>Non - Acknowledge Interrupt Enable Control
</b><br>
This bit enables the generation of a protocol interrupt if a non - acknowledge is detected by a master.
<br>
0 = The non - acknowledge interrupt is disabled.
<br>
1 = The non - acknowledge interrupt is enabled.
<br>
</div></td></tr><tr><td>
[4]</td><td>ARBLOIEN</td><td><div style="word-wrap: break-word;"><b>Arbitration Lost Interrupt Enable Control
</b><br>
This bit enables the generation of a protocol interrupt if an arbitration lost event is detected.
<br>
0 = The arbitration lost interrupt is disabled.
<br>
1 = The arbitration lost interrupt is enabled.
<br>
</div></td></tr><tr><td>
[5]</td><td>ERRIEN</td><td><div style="word-wrap: break-word;"><b>Error Interrupt Enable Control
</b><br>
This bit enables the generation of a protocol interrupt if an I2C error condition is detected (indicated by ERR (USCI_PROTSTS [16])).
<br>
0 = The error interrupt is disabled.
<br>
1 = The error interrupt is enabled.
<br>
</div></td></tr><tr><td>
[6]</td><td>ACKIEN</td><td><div style="word-wrap: break-word;"><b>Acknowledge Interrupt Enable Control
</b><br>
This bit enables the generation of a protocol interrupt if an acknowledge is detected by a master.
<br>
0 = The acknowledge interrupt is disabled.
<br>
1 = The acknowledge interrupt is enabled.
<br>
</div></td></tr></tbody></table></html>

 </p>

<p class="definition">Definition at line <a class="el" href="ui2c__reg_8h_source.html#l00841">841</a> of file <a class="el" href="ui2c__reg_8h_source.html">ui2c_reg.h</a>.</p>

</div>
</div>
<a id="a1689cfe379c17e495e04c6834c322498" name="a1689cfe379c17e495e04c6834c322498"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1689cfe379c17e495e04c6834c322498">&#9670;&nbsp;</a></span>PROTSTS</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UI2C_T::PROTSTS</td>
        </tr>
      </table>
</div><div class="memdoc">
<p >[0x0064] USCI Protocol Status Register <br  />
</p>
<p > 

<html><table class="fixed" border="1" style="border-collapse:collapse;" borderColor=black ><col width="75px" /><col width="125px" /><col width="700px" /><caption align="left"><font size="3">PROTSTS
</font><br><p> <font size="2">
Offset: 0x64  USCI Protocol Status Register
</font></caption><thread><tr bgcolor="#8A0808" ><td><font color=white><b>Bits</b></font></td><td><font color=white><b>Field</b></font></td><td><font color=white><b>Descriptions</b></font></td></tr></thread><tbody>
<tr><td>
[5]</td><td>TOIF</td><td><div style="word-wrap: break-word;"><b>Time-out Interrupt Flag
</b><br>
0 = A time-out interrupt status has not occurred.
<br>
1 = A time-out interrupt status has occurred.
<br>
Note: It is cleared by software writing one into this bit
<br>
</div></td></tr><tr><td>
[6]</td><td>ONBUSY</td><td><div style="word-wrap: break-word;"><b>On Bus Busy
</b><br>
Indicates that a communication is in progress on the bus
<br>
It is set by hardware when a START condition is detected
<br>
It is cleared by hardware when a STOP condition is detected
<br>
0 = The bus is IDLE (both SCLK and SDA High).
<br>
1 = The bus is busy.
<br>
</div></td></tr><tr><td>
[8]</td><td>STARIF</td><td><div style="word-wrap: break-word;"><b>Start Condition Received Interrupt Flag
</b><br>
This bit indicates that a start condition or repeated start condition has been detected on master mode
<br>
However, this bit also indicates that a repeated start condition has been detected on slave mode.
<br>
A protocol interrupt can be generated if USCI_PROTCTL.STARIEN = 1.
<br>
0 = A start condition has not yet been detected.
<br>
1 = A start condition has been detected.
<br>
It is cleared by software writing one into this bit
<br>
</div></td></tr><tr><td>
[9]</td><td>STORIF</td><td><div style="word-wrap: break-word;"><b>Stop Condition Received Interrupt Flag
</b><br>
This bit indicates that a stop condition has been detected on the I2C bus lines
<br>
A protocol interrupt can be generated if USCI_PROTCTL.STORIEN = 1.
<br>
0 = A stop condition has not yet been detected.
<br>
1 = A stop condition has been detected.
<br>
It is cleared by software writing one into this bit
<br>
Note: This bit is set when slave RX mode.
<br>
</div></td></tr><tr><td>
[10]</td><td>NACKIF</td><td><div style="word-wrap: break-word;"><b>Non - Acknowledge Received Interrupt Flag
</b><br>
This bit indicates that a non - acknowledge has been received in master mode
<br>
A protocol interrupt can be generated if USCI_PROTCTL.NACKIEN = 1.
<br>
0 = A non - acknowledge has not been received.
<br>
1 = A non - acknowledge has been received.
<br>
It is cleared by software writing one into this bit
<br>
</div></td></tr><tr><td>
[11]</td><td>ARBLOIF</td><td><div style="word-wrap: break-word;"><b>Arbitration Lost Interrupt Flag
</b><br>
This bit indicates that an arbitration has been lost
<br>
A protocol interrupt can be generated if USCI_PROTCTL.ARBLOIEN = 1.
<br>
0 = An arbitration has not been lost.
<br>
1 = An arbitration has been lost.
<br>
It is cleared by software writing one into this bit
<br>
</div></td></tr><tr><td>
[12]</td><td>ERRIF</td><td><div style="word-wrap: break-word;"><b>Error Interrupt Flag
</b><br>
This bit indicates that a Bus Error occurs when a START or STOP condition is present at an illegal position in the formation frame
<br>
Example of illegal position are during the serial transfer of an address byte, a data byte or an acknowledge bit
<br>
A protocol interrupt can be generated if USCI_PROTCTL.ERRIEN = 1.
<br>
0 = An I2C error has not been detected.
<br>
1 = An I2C error has been detected.
<br>
It is cleared by software writing one into this bit
<br>
Note: This bit is set when slave mode, user must write one into STO register to the defined "not addressed" slave mode.
<br>
</div></td></tr><tr><td>
[13]</td><td>ACKIF</td><td><div style="word-wrap: break-word;"><b>Acknowledge Received Interrupt Flag
</b><br>
This bit indicates that an acknowledge has been received in master mode
<br>
A protocol interrupt can be generated if USCI_PROTCTL.ACKIEN = 1.
<br>
0 = An acknowledge has not been received.
<br>
1 = An acknowledge has been received.
<br>
It is cleared by software writing one into this bit
<br>
</div></td></tr><tr><td>
[14]</td><td>SLASEL</td><td><div style="word-wrap: break-word;"><b>Slave Select Status
</b><br>
This bit indicates that this device has been selected as slave.
<br>
0 = The device is not selected as slave.
<br>
1 = The device is selected as slave.
<br>
Note: This bit has no interrupt signal, and it will be cleared automatically by hardware.
<br>
</div></td></tr><tr><td>
[15]</td><td>SLAREAD</td><td><div style="word-wrap: break-word;"><b>Slave Read Request Status
</b><br>
This bit indicates that a slave read request has been detected.
<br>
0 = A slave R/W bit is 1 has not been detected.
<br>
1 = A slave R/W bit is 1 has been detected.
<br>
Note: This bit has no interrupt signal, and it will be cleared automatically by hardware.
<br>
</div></td></tr><tr><td>
[16]</td><td>WKAKDONE</td><td><div style="word-wrap: break-word;"><b>Wakeup Address Frame Acknowledge Bit Done
</b><br>
0 = The ACK bit cycle of address match frame isn't done.
<br>
1 = The ACK bit cycle of address match frame is done in power-down.
<br>
Note: This bit can't release when WKUPIF is set.
<br>
</div></td></tr><tr><td>
[17]</td><td>WRSTSWK</td><td><div style="word-wrap: break-word;"><b>Read/Write Status Bit in Address Wakeup Frame
</b><br>
0 = Write command be record on the address match wakeup frame.
<br>
1 = Read command be record on the address match wakeup frame.
<br>
</div></td></tr><tr><td>
[18]</td><td>BUSHANG</td><td><div style="word-wrap: break-word;"><b>Bus Hang-up
</b><br>
This bit indicates bus hang-up status
<br>
There is 4-bit counter count when SCL hold high and refer fSAMP_CLK
<br>
The hang-up counter will count to overflow and set this bit when SDA is low
<br>
The counter will be reset by falling edge of SCL signal.
<br>
0 = The bus is normal status for transmission.
<br>
1 = The bus is hang-up status for transmission.
<br>
Note: This bit has no interrupt signal, and it will be cleared automatically by hardware when a START condition is present.
<br>
</div></td></tr><tr><td>
[19]</td><td>ERRARBLO</td><td><div style="word-wrap: break-word;"><b>Error Arbitration Lost
</b><br>
This bit indicates bus arbitration lost due to bigger noise which is can't be filtered by input processor
<br>
The I2C can send start condition when ERRARBLO is set
<br>
Thus this bit doesn't be cared on slave mode.
<br>
0 = The bus is normal status for transmission.
<br>
1 = The bus is error arbitration lost status for transmission.
<br>
Note: This bit has no interrupt signal, and it will be cleared automatically by hardware when a START condition is present.
<br>
</div></td></tr></tbody></table></html>

 </p>

<p class="definition">Definition at line <a class="el" href="ui2c__reg_8h_source.html#l00842">842</a> of file <a class="el" href="ui2c__reg_8h_source.html">ui2c_reg.h</a>.</p>

</div>
</div>
<a id="a3ee271dde56e3a144d7921e658066fcc" name="a3ee271dde56e3a144d7921e658066fcc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3ee271dde56e3a144d7921e658066fcc">&#9670;&nbsp;</a></span>RXDAT</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UI2C_T::RXDAT</td>
        </tr>
      </table>
</div><div class="memdoc">
<p >[0x0034] USCI Receive Data Register <br  />
</p>
<p > 

<html><table class="fixed" border="1" style="border-collapse:collapse;" borderColor=black ><col width="75px" /><col width="125px" /><col width="700px" /><caption align="left"><font size="3">RXDAT
</font><br><p> <font size="2">
Offset: 0x34  USCI Receive Data Register
</font></caption><thread><tr bgcolor="#8A0808" ><td><font color=white><b>Bits</b></font></td><td><font color=white><b>Field</b></font></td><td><font color=white><b>Descriptions</b></font></td></tr></thread><tbody>
<tr><td>
[15:0]</td><td>RXDAT</td><td><div style="word-wrap: break-word;"><b>Received Data
</b><br>
This bit field monitors the received data which stored in receive data buffer.
<br>
Note 1: In I2C protocol, RXDAT[12:8] indicate the different transmission conditions which defined in I2C.
<br>
Note 2: In UART protocol, RXDAT[15:13] indicate the same frame status of BREAK, FRMERR and PARITYERR (USCI_PROTSTS[7:5]).
<br>
</div></td></tr></tbody></table></html>

 </p>

<p class="definition">Definition at line <a class="el" href="ui2c__reg_8h_source.html#l00830">830</a> of file <a class="el" href="ui2c__reg_8h_source.html">ui2c_reg.h</a>.</p>

</div>
</div>
<a id="ae84984fd9c06318e2882ff68940d9095" name="ae84984fd9c06318e2882ff68940d9095"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae84984fd9c06318e2882ff68940d9095">&#9670;&nbsp;</a></span>TMCTL</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UI2C_T::TMCTL</td>
        </tr>
      </table>
</div><div class="memdoc">
<p >[0x008c] I2C Timing Configure Control Register <br  />
</p>
<p > 

<html><table class="fixed" border="1" style="border-collapse:collapse;" borderColor=black ><col width="75px" /><col width="125px" /><col width="700px" /><caption align="left"><font size="3">TMCTL
</font><br><p> <font size="2">
Offset: 0x8C  I2C Timing Configure Control Register
</font></caption><thread><tr bgcolor="#8A0808" ><td><font color=white><b>Bits</b></font></td><td><font color=white><b>Field</b></font></td><td><font color=white><b>Descriptions</b></font></td></tr></thread><tbody>
<tr><td>
[8:0]</td><td>STCTL</td><td><div style="word-wrap: break-word;"><b>Setup Time Configure Control Register
</b><br>
This field is used to generate a delay timing between SDA edge and SCL rising edge in transmission mode.
<br>
The delay setup time is numbers of peripheral clock = STCTL x fPCLK.
<br>
</div></td></tr><tr><td>
[24:16]</td><td>HTCTL</td><td><div style="word-wrap: break-word;"><b>Hold Time Configure Control Register
</b><br>
This field is used to generate the delay timing between SCL falling edge SDA edge in
<br>
transmission mode.
<br>
The delay hold time is numbers of peripheral clock = HTCTL x fPCLK.
<br>
</div></td></tr></tbody></table></html>

 </p>

<p class="definition">Definition at line <a class="el" href="ui2c__reg_8h_source.html#l00847">847</a> of file <a class="el" href="ui2c__reg_8h_source.html">ui2c_reg.h</a>.</p>

</div>
</div>
<a id="adb0614c8d5c4d1870a8589c650247f2d" name="adb0614c8d5c4d1870a8589c650247f2d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adb0614c8d5c4d1870a8589c650247f2d">&#9670;&nbsp;</a></span>TXDAT</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UI2C_T::TXDAT</td>
        </tr>
      </table>
</div><div class="memdoc">
<p >[0x0030] USCI Transmit Data Register <br  />
</p>
<p > 

<html><table class="fixed" border="1" style="border-collapse:collapse;" borderColor=black ><col width="75px" /><col width="125px" /><col width="700px" /><caption align="left"><font size="3">TXDAT
</font><br><p> <font size="2">
Offset: 0x30  USCI Transmit Data Register
</font></caption><thread><tr bgcolor="#8A0808" ><td><font color=white><b>Bits</b></font></td><td><font color=white><b>Field</b></font></td><td><font color=white><b>Descriptions</b></font></td></tr></thread><tbody>
<tr><td>
[15:0]</td><td>TXDAT</td><td><div style="word-wrap: break-word;"><b>Transmit Data
</b><br>
Software can use this bit field to write 16-bit transmit data for transmission.
<br>
</div></td></tr></tbody></table></html>

 </p>

<p class="definition">Definition at line <a class="el" href="ui2c__reg_8h_source.html#l00829">829</a> of file <a class="el" href="ui2c__reg_8h_source.html">ui2c_reg.h</a>.</p>

</div>
</div>
<a id="a2b48eac52f7512095abe983edf80d3c1" name="a2b48eac52f7512095abe983edf80d3c1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2b48eac52f7512095abe983edf80d3c1">&#9670;&nbsp;</a></span>WKCTL</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UI2C_T::WKCTL</td>
        </tr>
      </table>
</div><div class="memdoc">
<p >[0x0054] USCI Wake-up Control Register <br  />
</p>
<p > 

<html><table class="fixed" border="1" style="border-collapse:collapse;" borderColor=black ><col width="75px" /><col width="125px" /><col width="700px" /><caption align="left"><font size="3">WKCTL
</font><br><p> <font size="2">
Offset: 0x54  USCI Wake-up Control Register
</font></caption><thread><tr bgcolor="#8A0808" ><td><font color=white><b>Bits</b></font></td><td><font color=white><b>Field</b></font></td><td><font color=white><b>Descriptions</b></font></td></tr></thread><tbody>
<tr><td>
[0]</td><td>WKEN</td><td><div style="word-wrap: break-word;"><b>Wake-up Enable Bit
</b><br>
0 = Wake-up function Disabled.
<br>
1 = Wake-up function Enabled.
<br>
</div></td></tr><tr><td>
[1]</td><td>WKADDREN</td><td><div style="word-wrap: break-word;"><b>Wake-up Address Match Enable Bit
</b><br>
0 = The chip is woken up according data toggle.
<br>
1 = The chip is woken up according address match.
<br>
</div></td></tr></tbody></table></html>

 </p>

<p class="definition">Definition at line <a class="el" href="ui2c__reg_8h_source.html#l00838">838</a> of file <a class="el" href="ui2c__reg_8h_source.html">ui2c_reg.h</a>.</p>

</div>
</div>
<a id="a7725466810a374986a99f9275a3f2a80" name="a7725466810a374986a99f9275a3f2a80"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7725466810a374986a99f9275a3f2a80">&#9670;&nbsp;</a></span>WKSTS</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UI2C_T::WKSTS</td>
        </tr>
      </table>
</div><div class="memdoc">
<p >[0x0058] USCI Wake-up Status Register <br  />
</p>
<p > 

<html><table class="fixed" border="1" style="border-collapse:collapse;" borderColor=black ><col width="75px" /><col width="125px" /><col width="700px" /><caption align="left"><font size="3">WKSTS
</font><br><p> <font size="2">
Offset: 0x58  USCI Wake-up Status Register
</font></caption><thread><tr bgcolor="#8A0808" ><td><font color=white><b>Bits</b></font></td><td><font color=white><b>Field</b></font></td><td><font color=white><b>Descriptions</b></font></td></tr></thread><tbody>
<tr><td>
[0]</td><td>WKF</td><td><div style="word-wrap: break-word;"><b>Wake-up Flag
</b><br>
When chip is woken up from Power-down mode, this bit is set to 1
<br>
Software can write 1 to clear this bit.
<br>
</div></td></tr></tbody></table></html>

 </p>

<p class="definition">Definition at line <a class="el" href="ui2c__reg_8h_source.html#l00839">839</a> of file <a class="el" href="ui2c__reg_8h_source.html">ui2c_reg.h</a>.</p>

</div>
</div>
<hr/>The documentation for this struct was generated from the following file:<ul>
<li>Library/Device/Nuvoton/M480/Include/<a class="el" href="ui2c__reg_8h_source.html">ui2c_reg.h</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Thu Sep 18 2025 10:07:27 for M480 BSP by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.3
</small></address>
</body>
</html>
