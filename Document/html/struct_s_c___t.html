<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.3"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>M480 BSP: SC_T Struct Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectlogo"><img alt="Logo" src="m4.jpg"/></td>
  <td id="projectalign">
   <div id="projectname">M480 BSP<span id="projectnumber">&#160;V3.0.7000</span>
   </div>
   <div id="projectbrief">The Board Support Package for M480 Series</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.3 -->
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',false,false,'search.php','Search');
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-attribs">Data Fields</a>  </div>
  <div class="headertitle"><div class="title">SC_T Struct Reference<div class="ingroups"><a class="el" href="group___r_e_g_i_s_t_e_r.html">Control Register</a></div></div></div>
</div><!--header-->
<div class="contents">

<p><code>#include &lt;<a class="el" href="sc__reg_8h_source.html">sc_reg.h</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-attribs" name="pub-attribs"></a>
Data Fields</h2></td></tr>
<tr class="memitem:a08b9392001378ff1d731861a5eda5d7d"><td class="memItemLeft" align="right" valign="top">__IO uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_s_c___t.html#a08b9392001378ff1d731861a5eda5d7d">DAT</a></td></tr>
<tr class="separator:a08b9392001378ff1d731861a5eda5d7d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5d7098b2e65c064be85bd9349eeb8465"><td class="memItemLeft" align="right" valign="top">__IO uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_s_c___t.html#a5d7098b2e65c064be85bd9349eeb8465">CTL</a></td></tr>
<tr class="separator:a5d7098b2e65c064be85bd9349eeb8465"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1f1c60adf67f1b3cc6602a972c2cb29f"><td class="memItemLeft" align="right" valign="top">__IO uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_s_c___t.html#a1f1c60adf67f1b3cc6602a972c2cb29f">ALTCTL</a></td></tr>
<tr class="separator:a1f1c60adf67f1b3cc6602a972c2cb29f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae24513a3f822d239e34bdf15165af5ae"><td class="memItemLeft" align="right" valign="top">__IO uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_s_c___t.html#ae24513a3f822d239e34bdf15165af5ae">EGT</a></td></tr>
<tr class="separator:ae24513a3f822d239e34bdf15165af5ae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad4c1bc739dc56f6b842cd80a44a70515"><td class="memItemLeft" align="right" valign="top">__IO uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_s_c___t.html#ad4c1bc739dc56f6b842cd80a44a70515">RXTOUT</a></td></tr>
<tr class="separator:ad4c1bc739dc56f6b842cd80a44a70515"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2a21fcbc41c567481506ac04a41bf52e"><td class="memItemLeft" align="right" valign="top">__IO uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_s_c___t.html#a2a21fcbc41c567481506ac04a41bf52e">ETUCTL</a></td></tr>
<tr class="separator:a2a21fcbc41c567481506ac04a41bf52e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a50538e16985f66771d5464743feb1b7a"><td class="memItemLeft" align="right" valign="top">__IO uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_s_c___t.html#a50538e16985f66771d5464743feb1b7a">INTEN</a></td></tr>
<tr class="separator:a50538e16985f66771d5464743feb1b7a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aadeadbb0ba51539b0c2de4ad947fb0a8"><td class="memItemLeft" align="right" valign="top">__IO uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_s_c___t.html#aadeadbb0ba51539b0c2de4ad947fb0a8">INTSTS</a></td></tr>
<tr class="separator:aadeadbb0ba51539b0c2de4ad947fb0a8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a763cbd039f818865fc97569ebfb553e3"><td class="memItemLeft" align="right" valign="top">__IO uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_s_c___t.html#a763cbd039f818865fc97569ebfb553e3">STATUS</a></td></tr>
<tr class="separator:a763cbd039f818865fc97569ebfb553e3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7c045cb802cc04954a95356c2308ce4c"><td class="memItemLeft" align="right" valign="top">__IO uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_s_c___t.html#a7c045cb802cc04954a95356c2308ce4c">PINCTL</a></td></tr>
<tr class="separator:a7c045cb802cc04954a95356c2308ce4c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7f9dd18f1316d1fd3faf6e9f5c2d0d3d"><td class="memItemLeft" align="right" valign="top">__IO uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_s_c___t.html#a7f9dd18f1316d1fd3faf6e9f5c2d0d3d">TMRCTL0</a></td></tr>
<tr class="separator:a7f9dd18f1316d1fd3faf6e9f5c2d0d3d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a93ec89f4fa30ee9e8c6480abf814d849"><td class="memItemLeft" align="right" valign="top">__IO uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_s_c___t.html#a93ec89f4fa30ee9e8c6480abf814d849">TMRCTL1</a></td></tr>
<tr class="separator:a93ec89f4fa30ee9e8c6480abf814d849"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a12c05c3ae1f45e417764abe3ab1d769c"><td class="memItemLeft" align="right" valign="top">__IO uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_s_c___t.html#a12c05c3ae1f45e417764abe3ab1d769c">TMRCTL2</a></td></tr>
<tr class="separator:a12c05c3ae1f45e417764abe3ab1d769c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaea818bd8186138fa212ebf17ffbd8d5"><td class="memItemLeft" align="right" valign="top">__IO uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_s_c___t.html#aaea818bd8186138fa212ebf17ffbd8d5">UARTCTL</a></td></tr>
<tr class="separator:aaea818bd8186138fa212ebf17ffbd8d5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a546855d83fc95705c702c683d5935fcb"><td class="memItemLeft" align="right" valign="top">__IO uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_s_c___t.html#a546855d83fc95705c702c683d5935fcb">ACTCTL</a></td></tr>
<tr class="separator:a546855d83fc95705c702c683d5935fcb"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><pre class="fragment">@addtogroup SC Smart Card Host Interface Controller(SC)
Memory Mapped Structure for SC Controller
</pre> 
<p class="definition">Definition at line <a class="el" href="sc__reg_8h_source.html#l00026">26</a> of file <a class="el" href="sc__reg_8h_source.html">sc_reg.h</a>.</p>
</div><h2 class="groupheader">Field Documentation</h2>
<a id="a546855d83fc95705c702c683d5935fcb" name="a546855d83fc95705c702c683d5935fcb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a546855d83fc95705c702c683d5935fcb">&#9670;&nbsp;</a></span>ACTCTL</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">SC_T::ACTCTL</td>
        </tr>
      </table>
</div><div class="memdoc">
<p >[0x004c] SC Activation Control Register <br  />
</p>
<p > 

<html><table class="fixed" border="1" style="border-collapse:collapse;" borderColor=black ><col width="75px" /><col width="125px" /><col width="700px" /><caption align="left"><font size="3">ACTCTL
</font><br><p> <font size="2">
Offset: 0x4C  SC Activation Control Register
</font></caption><thread><tr bgcolor="#8A0808" ><td><font color=white><b>Bits</b></font></td><td><font color=white><b>Field</b></font></td><td><font color=white><b>Descriptions</b></font></td></tr></thread><tbody>
<tr><td>
[4:0]</td><td>T1EXT</td><td><div style="word-wrap: break-word;"><b>T1 Extend Time of Hardware Activation
</b><br>
This field provide the configurable cycles to extend the activation time T1 period.
<br>
The cycle scaling factor is 2048.
<br>
Extend cycles = (filled value * 2048) cycles.
<br>
Refer to SC activation sequence in Figure 7.17-4.
<br>
For example,
<br>
SCLK = 4MHz, each cycle = 0.25us,.
<br>
Filled 20 to this field
<br>
Extend time = 20 * 2048 * 0.25us = 10.24 ms.
<br>
Note: Setting 0 to this field conforms to the protocol ISO/IEC 7816-3
<br>
</div></td></tr></tbody></table></html>

 </p>

<p class="definition">Definition at line <a class="el" href="sc__reg_8h_source.html#l01501">1501</a> of file <a class="el" href="sc__reg_8h_source.html">sc_reg.h</a>.</p>

</div>
</div>
<a id="a1f1c60adf67f1b3cc6602a972c2cb29f" name="a1f1c60adf67f1b3cc6602a972c2cb29f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1f1c60adf67f1b3cc6602a972c2cb29f">&#9670;&nbsp;</a></span>ALTCTL</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">SC_T::ALTCTL</td>
        </tr>
      </table>
</div><div class="memdoc">
<p >[0x0008] SC Alternate Control Register <br  />
</p>
<p > 

<html><table class="fixed" border="1" style="border-collapse:collapse;" borderColor=black ><col width="75px" /><col width="125px" /><col width="700px" /><caption align="left"><font size="3">ALTCTL
</font><br><p> <font size="2">
Offset: 0x08  SC Alternate Control Register
</font></caption><thread><tr bgcolor="#8A0808" ><td><font color=white><b>Bits</b></font></td><td><font color=white><b>Field</b></font></td><td><font color=white><b>Descriptions</b></font></td></tr></thread><tbody>
<tr><td>
[0]</td><td>TXRST</td><td><div style="word-wrap: break-word;"><b>TX Software Reset
</b><br>
When TXRST is set, all the bytes in the transmit buffer and TX internal state machine will be cleared.
<br>
0 = No effect.
<br>
1 = Reset the TX internal state machine and pointers.
<br>
Note: This bit will be auto cleared after reset is complete.
<br>
</div></td></tr><tr><td>
[1]</td><td>RXRST</td><td><div style="word-wrap: break-word;"><b>Rx Software Reset
</b><br>
When RXRST is set, all the bytes in the receive buffer and Rx internal state machine will be cleared.
<br>
0 = No effect.
<br>
1 = Reset the Rx internal state machine and pointers.
<br>
Note: This bit will be auto cleared after reset is complete.
<br>
</div></td></tr><tr><td>
[2]</td><td>DACTEN</td><td><div style="word-wrap: break-word;"><b>Deactivation Sequence Generator Enable Bit
</b><br>
This bit enables SC controller to initiate the card by deactivation sequence.
<br>
0 = No effect.
<br>
1 = Deactivation sequence generator Enabled.
<br>
Note1: When the deactivation sequence completed, this bit will be cleared automatically and
<br>
the INITIF (SCn_INTSTS[8]) will be set to 1.
<br>
Note2: This field will be cleared by TXRST (SCn_ALTCTL[0]) and RXRST (SCn_ALTCTL[1])
<br>
Thus, do not fill in this bit DACTEN, TXRST and RXRST at the same time.
<br>
Note3: If SCEN (SCn_CTL[0]) is not enabled, this filed cannot be programmed.
<br>
</div></td></tr><tr><td>
[3]</td><td>ACTEN</td><td><div style="word-wrap: break-word;"><b>Activation Sequence Generator Enable Bit
</b><br>
This bit enables SC controller to initiate the card by activation sequence.
<br>
0 = No effect.
<br>
1 = Activation sequence generator Enabled.
<br>
Note1: When the activation sequence completed, this bit will be cleared automatically and the
<br>
INITIF (SCn_INTSTS[8]) will be set to 1.
<br>
Note2: This field will be cleared by TXRST (SCn_ALTCTL[0]) and RXRST (SCn_ALTCTL[1])
<br>
Thus, do not fill in this bit ACTEN, TXRST and RXRST at the same time.
<br>
Note3: If SCEN (SCn_CTL[0]) is not enabled, this filed cannot be programmed.
<br>
Note4: During the activation sequence, RX is disabled automatically and can not receive data
<br>
After the activation sequence completion, RXOFF (SCn_CTL[1]) keeps the state before hardware activation.
<br>
</div></td></tr><tr><td>
[4]</td><td>WARSTEN</td><td><div style="word-wrap: break-word;"><b>Warm Reset Sequence Generator Enable Bit
</b><br>
This bit enables SC controller to initiate the card by warm reset sequence.
<br>
0 = No effect.
<br>
1 = Warm reset sequence generator Enabled.
<br>
Note1: When the warm reset sequence completed, this bit will be cleared automatically and the
<br>
INITIF (SCn_INTSTS[8]) will be set to 1.
<br>
Note2: This field will be cleared by TXRST (SCn_ALTCTL[0]) and RXRST (SCn_ALTCTL[1])
<br>
Thus, do not fill in this bit WARSTEN, TXRST and RXRST at the same time.
<br>
Note3: If SCEN (SCn_CTL[0]) is not enabled, this filed cannot be programmed.
<br>
Note4: During the warm reset sequence, RX is disabled automatically and can not receive data
<br>
After the warm reset sequence completion, RXOFF (SCn_CTL[1]) keeps the state before perform
<br>
warm reset sequence.
<br>
</div></td></tr><tr><td>
[5]</td><td>CNTEN0</td><td><div style="word-wrap: break-word;"><b>Internal Timer0 Start Enable Bit
</b><br>
This bit enables Timer 0 to start counting
<br>
User can fill 0 to stop it and set 1 to reload and count
<br>
The counter unit is ETU base.
<br>
0 = Stops counting.
<br>
1 = Start counting.
<br>
Note1: This field is used for internal 24 bit timer when TMRSEL (SCn_CTL[14:13]) is 11 only.
<br>
Note2: If the operation mode is not in auto-reload mode (SCn_TMRCTL0[26] = 0), this bit will
<br>
be auto-cleared by hardware.
<br>
Note3: If SCEN (SCn_CTL[0]) is not enabled, this filed cannot be programmed.
<br>
</div></td></tr><tr><td>
[6]</td><td>CNTEN1</td><td><div style="word-wrap: break-word;"><b>Internal Timer1 Start Enable Bit
</b><br>
This bit enables Timer 1 to start counting
<br>
User can fill 0 to stop it and set 1 to reload and count
<br>
The counter unit is ETU base.
<br>
0 = Stops counting.
<br>
1 = Start counting.
<br>
Note1: This field is used for internal 8 bit timer when TMRSEL(SCn_CTL[14:13]) is 11 only
<br>
Do not fill CNTEN1 when TMRSEL (SCn_CTL[14:13]) is not equal to 11.
<br>
Note2: If the operation mode is not in auto-reload mode (SCn_TMRCTL1[26] = 0), this bit will
<br>
be auto-cleared by hardware.
<br>
Note3: If SCEN (SCn_CTL[0]) is not enabled, this filed cannot be programmed.
<br>
</div></td></tr><tr><td>
[7]</td><td>CNTEN2</td><td><div style="word-wrap: break-word;"><b>Internal Timer2 Start Enable Bit
</b><br>
This bit enables Timer 2 to start counting
<br>
User can fill 0 to stop it and set 1 to reload and count
<br>
The counter unit is ETU base.
<br>
0 = Stops counting.
<br>
1 = Start counting.
<br>
Note1: This field is used for internal 8 bit timer when TMRSEL (SCn_CTL[14:13]) is 11 only
<br>
Do not fill in CNTEN2 when TMRSEL (SCn_CTL[14:13]) is not equal to 11.
<br>
Note2: If the operation mode is not in auto-reload mode (SCn_TMRCTL2[26] = 0), this bit will
<br>
be auto-cleared by hardware.
<br>
Note3: If SCEN (SCn_CTL[0]) is not enabled, this filed cannot be programmed.
<br>
</div></td></tr><tr><td>
[9:8]</td><td>INITSEL</td><td><div style="word-wrap: break-word;"><b>Initial Timing Selection
</b><br>
This fields indicates the initial timing of hardware activation, warm-reset or deactivation.
<br>
The unit of initial timing is SC module clock.
<br>
Activation: refer to SC Activation Sequence in Figure 7.17-54.
<br>
Warm-reset: refer to Warm-Reset Sequence in Figure 7.17-5.
<br>
Deactivation: refer to Deactivation Sequence in Figure 7.17-56.
<br>
Note: When set activation and warm reset in Timer0 operation mode 0011, it may have deviation
<br>
at most 128 SC module clock cycles.
<br>
</div></td></tr><tr><td>
[11]</td><td>ADACEN</td><td><div style="word-wrap: break-word;"><b>Auto Deactivation When Card Removal
</b><br>
This bit is used for enable hardware auto deactivation when smart card is removed.
<br>
0 = Auto deactivation Disabled.
<br>
1 = Auto deactivation Enabled.
<br>
Note: When the card is removed, hardware will stop any process and then do deactivation sequence
<br>
if this bit is set
<br>
If auto deactivation process completes, hardware will set INITIF (SCn_INTSTS[8]) also.
<br>
</div></td></tr><tr><td>
[12]</td><td>RXBGTEN</td><td><div style="word-wrap: break-word;"><b>Receiver Block Guard Time Function Enable Bit
</b><br>
This bit enables the receiver block guard time function.
<br>
0 = Receiver block guard time function Disabled.
<br>
1 = Receiver block guard time function Enabled.
<br>
</div></td></tr><tr><td>
[13]</td><td>ACTSTS0</td><td><div style="word-wrap: break-word;"><b>Internal Timer0 Active Status (Read Only)
</b><br>
This bit indicates the timer counter status of timer0.
<br>
0 = Timer0 is not active.
<br>
1 = Timer0 is active.
<br>
Note: Timer0 is active does not always mean timer0 is counting the CNT (SCn_TMRCTL0[23:0]).
<br>
</div></td></tr><tr><td>
[14]</td><td>ACTSTS1</td><td><div style="word-wrap: break-word;"><b>Internal Timer1 Active Status (Read Only)
</b><br>
This bit indicates the timer counter status of timer1.
<br>
0 = Timer1 is not active.
<br>
1 = Timer1 is active.
<br>
Note: Timer1 is active does not always mean timer1 is counting the CNT (SCn_TMRCTL1[7:0]).
<br>
</div></td></tr><tr><td>
[15]</td><td>ACTSTS2</td><td><div style="word-wrap: break-word;"><b>Internal Timer2 Active Status (Read Only)
</b><br>
This bit indicates the timer counter status of timer2.
<br>
0 = Timer2 is not active.
<br>
1 = Timer2 is active.
<br>
Note: Timer2 is active does not always mean timer2 is counting the CNT (SCn_TMRCTL2[7:0]).
<br>
</div></td></tr><tr><td>
[31]</td><td>SYNC</td><td><div style="word-wrap: break-word;"><b>SYNC Flag Indicator (Read Only)
</b><br>
Due to synchronization, user should check this bit when writing a new value to SCn_ALTCTL register.
<br>
0 = Synchronizing is completion, user can write new data to SCn_ALTCTL register.
<br>
1 = Last value is synchronizing.
<br>
</div></td></tr></tbody></table></html>

 </p>

<p class="definition">Definition at line <a class="el" href="sc__reg_8h_source.html#l01486">1486</a> of file <a class="el" href="sc__reg_8h_source.html">sc_reg.h</a>.</p>

</div>
</div>
<a id="a5d7098b2e65c064be85bd9349eeb8465" name="a5d7098b2e65c064be85bd9349eeb8465"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5d7098b2e65c064be85bd9349eeb8465">&#9670;&nbsp;</a></span>CTL</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">SC_T::CTL</td>
        </tr>
      </table>
</div><div class="memdoc">
<p >[0x0004] SC Control Register <br  />
</p>
<p > 

<html><table class="fixed" border="1" style="border-collapse:collapse;" borderColor=black ><col width="75px" /><col width="125px" /><col width="700px" /><caption align="left"><font size="3">CTL
</font><br><p> <font size="2">
Offset: 0x04  SC Control Register
</font></caption><thread><tr bgcolor="#8A0808" ><td><font color=white><b>Bits</b></font></td><td><font color=white><b>Field</b></font></td><td><font color=white><b>Descriptions</b></font></td></tr></thread><tbody>
<tr><td>
[0]</td><td>SCEN</td><td><div style="word-wrap: break-word;"><b>SC Controller Enable Bit
</b><br>
Set this bit to 1 to enable SC operation. If this bit is cleared,
<br>
0 = SC will force all transition to IDLE state.
<br>
1 = SC controller is enabled and all function can work correctly.
<br>
Note1: SCEN must be set to 1 before filling in other SC registers, or smart card will not work properly.
<br>
</div></td></tr><tr><td>
[1]</td><td>RXOFF</td><td><div style="word-wrap: break-word;"><b>RX Transition Disable Control Bit
</b><br>
This bit is used for disable Rx transition function.
<br>
0 = The receiver Enabled.
<br>
1 = The receiver Disabled.
<br>
Note1: If AUTOCEN (SCn_CTL[3]) is enabled, this field is ignored.
<br>
</div></td></tr><tr><td>
[2]</td><td>TXOFF</td><td><div style="word-wrap: break-word;"><b>TX Transition Disable Control Bit
</b><br>
This bit is used for disable Tx transition function.
<br>
0 = The transceiver Enabled.
<br>
1 = The transceiver Disabled.
<br>
</div></td></tr><tr><td>
[3]</td><td>AUTOCEN</td><td><div style="word-wrap: break-word;"><b>Auto Convention Enable Bit
</b><br>
This bit is used for enable auto convention function.
<br>
0 = Auto-convention Disabled.
<br>
1 = Auto-convention Enabled.
<br>
If user enables auto convention function, the setting step must be done before Answer to Reset (ATR)
<br>
state and the first data must be 0x3B or 0x3F.
<br>
After hardware received first data and stored it at buffer, hardware will decided the convention and
<br>
change the CONSEL (SCn_CTL[5:4]) bits automatically when received first data is 0x3B or 0x3F.
<br>
If received first byte is 0x3B, TS is direct convention, CONSEL (SCn_CTL[5:4]) will be set to 00
<br>
automatically, otherwise the TS is inverse convention, and CONSEL (SCn_CTL[5:4]) will be set to 11.
<br>
If the first data is not 0x3B or 0x3F, hardware will set ACERRIF (SCn_INTSTS[10]) and generate an
<br>
interrupt to CPU when ACERRIEN (SCn_INTEN[10]) is enabled.
<br>
</div></td></tr><tr><td>
[5:4]</td><td>CONSEL</td><td><div style="word-wrap: break-word;"><b>Convention Selection
</b><br>
00 = Direct convention.
<br>
01 = Reserved.
<br>
10 = Reserved.
<br>
11 = Inverse convention.
<br>
Note: If AUTOCEN (SCn_CTL[3]) is enabled, this field is ignored.
<br>
</div></td></tr><tr><td>
[7:6]</td><td>RXTRGLV</td><td><div style="word-wrap: break-word;"><b>Rx Buffer Trigger Level
</b><br>
When the number of bytes in the receiving buffer equals the RXTRGLV, the RDAIF will be set
<br>
If RDAIEN (SCn_INTEN[0]) is enabled, an interrupt will be generated to CPU.
<br>
00 = Rx Buffer Trigger Level with 01 bytes.
<br>
01 = Rx Buffer Trigger Level with 02 bytes.
<br>
10 = Rx Buffer Trigger Level with 03 bytes.
<br>
11 = Reserved.
<br>
</div></td></tr><tr><td>
[12:8]</td><td>BGT</td><td><div style="word-wrap: break-word;"><b>Block Guard Time (BGT)
</b><br>
Block guard time means the minimum interval between the leading edges of two consecutive characters
<br>
between different transfer directions
<br>
This field indicates the counter for the bit length of block guard time
<br>
According to ISO 7816-3, in T = 0 mode, user must fill 15 (real block guard time = 16.5) to this
<br>
field; in T = 1 mode, user must fill 21 (real block guard time = 22.5) to it.
<br>
Note: The real block guard time is BGT + 1.
<br>
</div></td></tr><tr><td>
[14:13]</td><td>TMRSEL</td><td><div style="word-wrap: break-word;"><b>Timer Channel Selection
</b><br>
00 = All internal timer function Disabled.
<br>
11 = Internal 24 bit timer and two 8 bit timers Enabled
<br>
User can configure them by setting SCn_TMRCTL0[23:0], SCn_TMRCTL1[7:0] and SCn_TMRCTL2[7:0].
<br>
Other configurations are reserved
<br>
</div></td></tr><tr><td>
[15]</td><td>NSB</td><td><div style="word-wrap: break-word;"><b>Stop Bit Length
</b><br>
This field indicates the length of stop bit.
<br>
0 = The stop bit length is 2 ETU.
<br>
1= The stop bit length is 1 ETU.
<br>
Note1: The default stop bit length is 2. SC and UART adopts NSB to program the stop bit length.
<br>
Note2: In UART mode, RX can receive the data sequence in 1 stop bit or 2 stop bits with NSB is set to 0.
<br>
</div></td></tr><tr><td>
[18:16]</td><td>RXRTY</td><td><div style="word-wrap: break-word;"><b>RX Error Retry Count Number
</b><br>
This field indicates the maximum number of receiver retries that are allowed when parity error has occurred.
<br>
Note1: The real retry number is RXRTY + 1, so 8 is the maximum retry number.
<br>
Note2: This field cannot be changed when RXRTYEN enabled
<br>
The change flow is to disable RXRTYEN first and then fill in new retry value.
<br>
</div></td></tr><tr><td>
[19]</td><td>RXRTYEN</td><td><div style="word-wrap: break-word;"><b>RX Error Retry Enable Bit
</b><br>
This bit enables receiver retry function when parity error has occurred.
<br>
0 = RX error retry function Disabled.
<br>
1 = RX error retry function Enabled.
<br>
Note: User must fill in the RXRTY value before enabling this bit.
<br>
</div></td></tr><tr><td>
[22:20]</td><td>TXRTY</td><td><div style="word-wrap: break-word;"><b>TX Error Retry Count Number
</b><br>
This field indicates the maximum number of transmitter retries that are allowed when parity
<br>
error has occurred.
<br>
Note1: The real retry number is TXRTY + 1, so 8 is the maximum retry number.
<br>
Note2: This field cannot be changed when TXRTYEN enabled
<br>
The change flow is to disable TXRTYEN first and then fill in new retry value.
<br>
</div></td></tr><tr><td>
[23]</td><td>TXRTYEN</td><td><div style="word-wrap: break-word;"><b>TX Error Retry Enable Bit
</b><br>
This bit enables transmitter retry function when parity error has occurred.
<br>
0 = TX error retry function Disabled.
<br>
1 = TX error retry function Enabled.
<br>
</div></td></tr><tr><td>
[25:24]</td><td>CDDBSEL</td><td><div style="word-wrap: break-word;"><b>Card Detect De-bounce Selection
</b><br>
This field indicates the card detect de-bounce selection.
<br>
00 = De-bounce sample card insert once per 384 (128 * 3) SC module clocks and de-bounce
<br>
sample card removal once per 128 SC module clocks.
<br>
Other configurations are reserved.
<br>
</div></td></tr><tr><td>
[26]</td><td>CDLV</td><td><div style="word-wrap: break-word;"><b>Card Detect Level Selection
</b><br>
0 = When hardware detects the card detect pin (SCn_CD) from high to low, it indicates a card is detected.
<br>
1 = When hardware detects the card detect pin (SCn_CD) from low to high, it indicates a card is detected.
<br>
Note: User must select card detect level before Smart Card controller enabled.
<br>
</div></td></tr><tr><td>
[30]</td><td>SYNC</td><td><div style="word-wrap: break-word;"><b>SYNC Flag Indicator (Read Only)
</b><br>
Due to synchronization, user should check this bit before writing a new value to RXRTY and TXRTY fields.
<br>
0 = Synchronizing is completion, user can write new data to RXRTY and TXRTY.
<br>
1 = Last value is synchronizing.
<br>
</div></td></tr></tbody></table></html>

 </p>

<p class="definition">Definition at line <a class="el" href="sc__reg_8h_source.html#l01485">1485</a> of file <a class="el" href="sc__reg_8h_source.html">sc_reg.h</a>.</p>

</div>
</div>
<a id="a08b9392001378ff1d731861a5eda5d7d" name="a08b9392001378ff1d731861a5eda5d7d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a08b9392001378ff1d731861a5eda5d7d">&#9670;&nbsp;</a></span>DAT</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">SC_T::DAT</td>
        </tr>
      </table>
</div><div class="memdoc">
<p >[0x0000] SC Receive/Transmit Holding Buffer Register <br  />
</p>
<p > 

<html><table class="fixed" border="1" style="border-collapse:collapse;" borderColor=black ><col width="75px" /><col width="125px" /><col width="700px" /><caption align="left"><font size="3">DAT
</font><br><p> <font size="2">
Offset: 0x00  SC Receive/Transmit Holding Buffer Register
</font></caption><thread><tr bgcolor="#8A0808" ><td><font color=white><b>Bits</b></font></td><td><font color=white><b>Field</b></font></td><td><font color=white><b>Descriptions</b></font></td></tr></thread><tbody>
<tr><td>
[7:0]</td><td>DAT</td><td><div style="word-wrap: break-word;"><b>Receive/Transmit Holding Buffer
</b><br>
Write Operation:
<br>
By writing data to DAT, the SC will send out an 8-bit data.
<br>
Note: If SCEN (SCn_CTL[0]) is not enabled, DAT cannot be programmed.
<br>
Read Operation:
<br>
By reading DAT, the SC will return an 8-bit received data.
<br>
</div></td></tr></tbody></table></html>

 </p>

<p class="definition">Definition at line <a class="el" href="sc__reg_8h_source.html#l01484">1484</a> of file <a class="el" href="sc__reg_8h_source.html">sc_reg.h</a>.</p>

</div>
</div>
<a id="ae24513a3f822d239e34bdf15165af5ae" name="ae24513a3f822d239e34bdf15165af5ae"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae24513a3f822d239e34bdf15165af5ae">&#9670;&nbsp;</a></span>EGT</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">SC_T::EGT</td>
        </tr>
      </table>
</div><div class="memdoc">
<p >[0x000c] SC Extra Guard Time Register <br  />
</p>
<p > 

<html><table class="fixed" border="1" style="border-collapse:collapse;" borderColor=black ><col width="75px" /><col width="125px" /><col width="700px" /><caption align="left"><font size="3">EGT
</font><br><p> <font size="2">
Offset: 0x0C  SC Extra Guard Time Register
</font></caption><thread><tr bgcolor="#8A0808" ><td><font color=white><b>Bits</b></font></td><td><font color=white><b>Field</b></font></td><td><font color=white><b>Descriptions</b></font></td></tr></thread><tbody>
<tr><td>
[7:0]</td><td>EGT</td><td><div style="word-wrap: break-word;"><b>Extra Guard Time
</b><br>
This field indicates the extra guard time value.
<br>
Note: The extra guard time unit is ETU base.
<br>
</div></td></tr></tbody></table></html>

 </p>

<p class="definition">Definition at line <a class="el" href="sc__reg_8h_source.html#l01487">1487</a> of file <a class="el" href="sc__reg_8h_source.html">sc_reg.h</a>.</p>

</div>
</div>
<a id="a2a21fcbc41c567481506ac04a41bf52e" name="a2a21fcbc41c567481506ac04a41bf52e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2a21fcbc41c567481506ac04a41bf52e">&#9670;&nbsp;</a></span>ETUCTL</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">SC_T::ETUCTL</td>
        </tr>
      </table>
</div><div class="memdoc">
<p >[0x0014] SC Element Time Unit Control Register <br  />
</p>
<p > 

<html><table class="fixed" border="1" style="border-collapse:collapse;" borderColor=black ><col width="75px" /><col width="125px" /><col width="700px" /><caption align="left"><font size="3">ETUCTL
</font><br><p> <font size="2">
Offset: 0x14  SC Element Time Unit Control Register
</font></caption><thread><tr bgcolor="#8A0808" ><td><font color=white><b>Bits</b></font></td><td><font color=white><b>Field</b></font></td><td><font color=white><b>Descriptions</b></font></td></tr></thread><tbody>
<tr><td>
[11:0]</td><td>ETURDIV</td><td><div style="word-wrap: break-word;"><b>ETU Rate Divider
</b><br>
The field is used for ETU clock rate divider.
<br>
The real ETU is ETURDIV + 1.
<br>
Note: User can configure this field, but this field must be greater than 0x04.
<br>
</div></td></tr></tbody></table></html>

 </p>

<p class="definition">Definition at line <a class="el" href="sc__reg_8h_source.html#l01489">1489</a> of file <a class="el" href="sc__reg_8h_source.html">sc_reg.h</a>.</p>

</div>
</div>
<a id="a50538e16985f66771d5464743feb1b7a" name="a50538e16985f66771d5464743feb1b7a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a50538e16985f66771d5464743feb1b7a">&#9670;&nbsp;</a></span>INTEN</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">SC_T::INTEN</td>
        </tr>
      </table>
</div><div class="memdoc">
<p >[0x0018] SC Interrupt Enable Control Register <br  />
</p>
<p > 

<html><table class="fixed" border="1" style="border-collapse:collapse;" borderColor=black ><col width="75px" /><col width="125px" /><col width="700px" /><caption align="left"><font size="3">INTEN
</font><br><p> <font size="2">
Offset: 0x18  SC Interrupt Enable Control Register
</font></caption><thread><tr bgcolor="#8A0808" ><td><font color=white><b>Bits</b></font></td><td><font color=white><b>Field</b></font></td><td><font color=white><b>Descriptions</b></font></td></tr></thread><tbody>
<tr><td>
[0]</td><td>RDAIEN</td><td><div style="word-wrap: break-word;"><b>Receive Data Reach Interrupt Enable Bit
</b><br>
This field is used to enable received data reaching trigger level RXTRGLV (SCn_CTL[7:6]) interrupt.
<br>
0 = Receive data reach trigger level interrupt Disabled.
<br>
1 = Receive data reach trigger level interrupt Enabled.
<br>
</div></td></tr><tr><td>
[1]</td><td>TBEIEN</td><td><div style="word-wrap: break-word;"><b>Transmit Buffer Empty Interrupt Enable Bit
</b><br>
This field is used to enable transmit buffer empty interrupt.
<br>
0 = Transmit buffer empty interrupt Disabled.
<br>
1 = Transmit buffer empty interrupt Enabled.
<br>
</div></td></tr><tr><td>
[2]</td><td>TERRIEN</td><td><div style="word-wrap: break-word;"><b>Transfer Error Interrupt Enable Bit
</b><br>
This field is used to enable transfer error interrupt
<br>
The transfer error states is at SCn_STATUS register which includes receiver break error
<br>
BEF (SCn_STATUS[6]), frame error FEF (SCn_STATUS[5]), parity error PEF (SCn_STATUS[4]), receive
<br>
buffer overflow error RXOV (SCn_STATUS[0]), transmit buffer overflow error TXOV (SCn_STATUS[8]),
<br>
receiver retry over limit error RXOVERR (SCn_STATUS[22]) and transmitter retry over limit error
<br>
TXOVERR (SCn_STATUS[30]).
<br>
0 = Transfer error interrupt Disabled.
<br>
1 = Transfer error interrupt Enabled.
<br>
</div></td></tr><tr><td>
[3]</td><td>TMR0IEN</td><td><div style="word-wrap: break-word;"><b>Timer0 Interrupt Enable Bit
</b><br>
This field is used to enable Timer0 interrupt function.
<br>
0 = Timer0 interrupt Disabled.
<br>
1 = Timer0 interrupt Enabled.
<br>
</div></td></tr><tr><td>
[4]</td><td>TMR1IEN</td><td><div style="word-wrap: break-word;"><b>Timer1 Interrupt Enable Bit
</b><br>
This field is used to enable the Timer1 interrupt function.
<br>
0 = Timer1 interrupt Disabled.
<br>
1 = Timer1 interrupt Enabled.
<br>
</div></td></tr><tr><td>
[5]</td><td>TMR2IEN</td><td><div style="word-wrap: break-word;"><b>Timer2 Interrupt Enable Bit
</b><br>
This field is used to enable Timer2 interrupt function.
<br>
0 = Timer2 interrupt Disabled.
<br>
1 = Timer2 interrupt Enabled.
<br>
</div></td></tr><tr><td>
[6]</td><td>BGTIEN</td><td><div style="word-wrap: break-word;"><b>Block Guard Time Interrupt Enable Bit
</b><br>
This field is used to enable block guard time interrupt in receive direction.
<br>
0 = Block guard time interrupt Disabled.
<br>
1 = Block guard time interrupt Enabled.
<br>
Note: This bit is valid only for receive direction block guard time.
<br>
</div></td></tr><tr><td>
[7]</td><td>CDIEN</td><td><div style="word-wrap: break-word;"><b>Card Detect Interrupt Enable Bit
</b><br>
This field is used to enable card detect interrupt
<br>
The card detect status is CDPINSTS (SCn_STATUS[13]).
<br>
0 = Card detect interrupt Disabled.
<br>
1 = Card detect interrupt Enabled.
<br>
</div></td></tr><tr><td>
[8]</td><td>INITIEN</td><td><div style="word-wrap: break-word;"><b>Initial End Interrupt Enable Bit
</b><br>
This field is used to enable activation (ACTEN (SCn_ALTCTL[3] = 1)), deactivation
<br>
(DACTEN (SCn_ALTCTL[2] = 1)) and warm reset (WARSTEN (SCn_ALTCTL [4])) sequence complete interrupt.
<br>
0 = Initial end interrupt Disabled.
<br>
1 = Initial end interrupt Enabled.
<br>
</div></td></tr><tr><td>
[9]</td><td>RXTOIEN</td><td><div style="word-wrap: break-word;"><b>Receiver Buffer Time-out Interrupt Enable Bit
</b><br>
This field is used to enable receiver buffer time-out interrupt.
<br>
0 = Receiver buffer time-out interrupt Disabled.
<br>
1 = Receiver buffer time-out interrupt Enabled.
<br>
</div></td></tr><tr><td>
[10]</td><td>ACERRIEN</td><td><div style="word-wrap: break-word;"><b>Auto Convention Error Interrupt Enable Bit
</b><br>
This field is used to enable auto-convention error interrupt.
<br>
0 = Auto-convention error interrupt Disabled.
<br>
1 = Auto-convention error interrupt Enabled.
<br>
</div></td></tr></tbody></table></html>

 </p>

<p class="definition">Definition at line <a class="el" href="sc__reg_8h_source.html#l01490">1490</a> of file <a class="el" href="sc__reg_8h_source.html">sc_reg.h</a>.</p>

</div>
</div>
<a id="aadeadbb0ba51539b0c2de4ad947fb0a8" name="aadeadbb0ba51539b0c2de4ad947fb0a8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aadeadbb0ba51539b0c2de4ad947fb0a8">&#9670;&nbsp;</a></span>INTSTS</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">SC_T::INTSTS</td>
        </tr>
      </table>
</div><div class="memdoc">
<p >[0x001c] SC Interrupt Status Register <br  />
</p>
<p > 

<html><table class="fixed" border="1" style="border-collapse:collapse;" borderColor=black ><col width="75px" /><col width="125px" /><col width="700px" /><caption align="left"><font size="3">INTSTS
</font><br><p> <font size="2">
Offset: 0x1C  SC Interrupt Status Register
</font></caption><thread><tr bgcolor="#8A0808" ><td><font color=white><b>Bits</b></font></td><td><font color=white><b>Field</b></font></td><td><font color=white><b>Descriptions</b></font></td></tr></thread><tbody>
<tr><td>
[0]</td><td>RDAIF</td><td><div style="word-wrap: break-word;"><b>Receive Data Reach Interrupt Status Flag (Read Only)
</b><br>
This field is used for received data reaching trigger level RXTRGLV (SCn_CTL[7:6]) interrupt status flag.
<br>
0 = Number of receive buffer is less than RXTRGLV setting.
<br>
1 = Number of receive buffer data equals the RXTRGLV setting.
<br>
Note: This bit is read only
<br>
If user reads data from SCn_DAT and receiver buffer data byte number is less than RXTRGLV,
<br>
this bit will be cleared automatically.
<br>
</div></td></tr><tr><td>
[1]</td><td>TBEIF</td><td><div style="word-wrap: break-word;"><b>Transmit Buffer Empty Interrupt Status Flag (Read Only)
</b><br>
This field is used for transmit buffer empty interrupt status flag.
<br>
0 = Transmit buffer is not empty.
<br>
1 = Transmit buffer is empty.
<br>
Note: This bit is read only
<br>
If user wants to clear this bit, user must write data to DAT (SCn_DAT[7:0]) and then this bit
<br>
will be cleared automatically.
<br>
</div></td></tr><tr><td>
[2]</td><td>TERRIF</td><td><div style="word-wrap: break-word;"><b>Transfer Error Interrupt Status Flag
</b><br>
This field is used for transfer error interrupt status flag
<br>
The transfer error states is at SCn_STATUS register which includes receiver break error
<br>
BEF (SCn_STATUS[6]), frame error FEF (SCn_STATUS[5], parity error PEF (SCn_STATUS[4] and receive
<br>
buffer overflow error RXOV (SCn_STATUS[0]), transmit buffer overflow error TXOV (SCn_STATUS[8]),
<br>
receiver retry over limit error RXOVERR (SCn_STATUS[22] or transmitter retry over limit error
<br>
TXOVERR (SCn_STATUS[30]).
<br>
0 = Transfer error interrupt did not occur.
<br>
1 = Transfer error interrupt occurred.
<br>
Note1: This field is the status flag of BEF, FEF, PEF, RXOV, TXOV, RXOVERR or TXOVERR.
<br>
Note2: This bit can be cleared by writing 1 to it.
<br>
</div></td></tr><tr><td>
[3]</td><td>TMR0IF</td><td><div style="word-wrap: break-word;"><b>Timer0 Interrupt Status Flag
</b><br>
This field is used for Timer0 interrupt status flag.
<br>
0 = Timer0 interrupt did not occur.
<br>
1 = Timer0 interrupt occurred.
<br>
Note: This bit can be cleared by writing 1 to it.
<br>
</div></td></tr><tr><td>
[4]</td><td>TMR1IF</td><td><div style="word-wrap: break-word;"><b>Timer1 Interrupt Status Flag
</b><br>
This field is used for Timer1 interrupt status flag.
<br>
0 = Timer1 interrupt did not occur.
<br>
1 = Timer1 interrupt occurred.
<br>
Note: This bit can be cleared by writing 1 to it.
<br>
</div></td></tr><tr><td>
[5]</td><td>TMR2IF</td><td><div style="word-wrap: break-word;"><b>Timer2 Interrupt Status Flag
</b><br>
This field is used for Timer2 interrupt status flag.
<br>
0 = Timer2 interrupt did not occur.
<br>
1 = Timer2 interrupt occurred.
<br>
Note: This bit can be cleared by writing 1 to it.
<br>
</div></td></tr><tr><td>
[6]</td><td>BGTIF</td><td><div style="word-wrap: break-word;"><b>Block Guard Time Interrupt Status Flag
</b><br>
This field is used for indicate block guard time interrupt status flag in receive direction.
<br>
0 = Block guard time interrupt did not occur.
<br>
1 = Block guard time interrupt occurred.
<br>
Note1: This bit is valid only when RXBGTEN (SCn_ALTCTL[12]) is enabled.
<br>
Note2: This bit can be cleared by writing 1 to it.
<br>
</div></td></tr><tr><td>
[7]</td><td>CDIF</td><td><div style="word-wrap: break-word;"><b>Card Detect Interrupt Status Flag (Read Only)
</b><br>
This field is used for card detect interrupt status flag
<br>
The card detect status is CINSERT (SCn_STATUS[12]) and CREMOVE (SCn_STATUS[11]).
<br>
0 = Card detect event did not occur.
<br>
1 = Card detect event occurred.
<br>
Note: This bit is read only, user must to clear CINSERT or CREMOVE status to clear it.
<br>
</div></td></tr><tr><td>
[8]</td><td>INITIF</td><td><div style="word-wrap: break-word;"><b>Initial End Interrupt Status Flag
</b><br>
This field is used for activation (ACTEN (SCn_ALTCTL[3])), deactivation (DACTEN (SCn_ALTCTL[2]))
<br>
and warm reset (WARSTEN (SCn_ALTCTL[4])) sequence interrupt status flag.
<br>
0 = Initial sequence is not complete.
<br>
1 = Initial sequence is completed.
<br>
Note: This bit can be cleared by writing 1 to it.
<br>
</div></td></tr><tr><td>
[9]</td><td>RXTOIF</td><td><div style="word-wrap: break-word;"><b>Receive Buffer Time-out Interrupt Status Flag (Read Only)
</b><br>
This field is used for indicate receive buffer time-out interrupt status flag.
<br>
0 = Receive buffer time-out interrupt did not occur.
<br>
1 = Receive buffer time-out interrupt occurred.
<br>
Note: This bit is read only, user must read all receive buffer remaining data by reading SCn_DAT
<br>
register to clear it.
<br>
</div></td></tr><tr><td>
[10]</td><td>ACERRIF</td><td><div style="word-wrap: break-word;"><b>Auto Convention Error Interrupt Status Flag
</b><br>
This field indicates auto convention sequence error.
<br>
0 = Received TS at ATR state is 0x3B or 0x3F.
<br>
1 = Received TS at ATR state is neither 0x3B nor 0x3F.
<br>
Note: This bit can be cleared by writing 1 to it.
<br>
</div></td></tr></tbody></table></html>

 </p>

<p class="definition">Definition at line <a class="el" href="sc__reg_8h_source.html#l01491">1491</a> of file <a class="el" href="sc__reg_8h_source.html">sc_reg.h</a>.</p>

</div>
</div>
<a id="a7c045cb802cc04954a95356c2308ce4c" name="a7c045cb802cc04954a95356c2308ce4c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7c045cb802cc04954a95356c2308ce4c">&#9670;&nbsp;</a></span>PINCTL</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">SC_T::PINCTL</td>
        </tr>
      </table>
</div><div class="memdoc">
<p >[0x0024] SC Pin Control State Register <br  />
</p>
<p > 

<html><table class="fixed" border="1" style="border-collapse:collapse;" borderColor=black ><col width="75px" /><col width="125px" /><col width="700px" /><caption align="left"><font size="3">PINCTL
</font><br><p> <font size="2">
Offset: 0x24  SC Pin Control State Register
</font></caption><thread><tr bgcolor="#8A0808" ><td><font color=white><b>Bits</b></font></td><td><font color=white><b>Field</b></font></td><td><font color=white><b>Descriptions</b></font></td></tr></thread><tbody>
<tr><td>
[0]</td><td>PWREN</td><td><div style="word-wrap: break-word;"><b>SCn_PWR Pin Signal
</b><br>
User can set PWRINV (SCn_PINCTL[11]) and PWREN (SCn_PINCTL[0]) to decide SCn_PWR pin is in high or low level.
<br>
Write this field to drive SCn_PWR pin
<br>
Refer PWRINV (SCn_PINCTL[11]) description for programming SCn_PWR pin voltage level.
<br>
Read this field to get SCn_PWR signal status.
<br>
0 = SCn_PWR signal status is low.
<br>
1 = SCn_PWR signal status is high.
<br>
Note: When operating at activation, warm reset or deactivation mode, this bit will be changed automatically.
<br>
Thus, do not fill in this field when operating in these modes.
<br>
</div></td></tr><tr><td>
[1]</td><td>RSTEN</td><td><div style="word-wrap: break-word;"><b>SCn_RST Pin Signal
</b><br>
User can set RSTEN (SCn_PINCTL[1]) to decide SCn_RST pin is in high or low level.
<br>
Write this field to drive SCn_RST pin.
<br>
0 = Drive SCn_RST pin to low.
<br>
1 = Drive SCn_RST pin to high.
<br>
Read this field to get SCn_RST signal status.
<br>
0 = SCn_RST signal status is low.
<br>
1 = SCn_RST signal status is high.
<br>
Note: When operating at activation, warm reset or deactivation mode, this bit will be changed automatically.
<br>
Thus, do not fill in this field when operating in these modes.
<br>
</div></td></tr><tr><td>
[6]</td><td>CLKKEEP</td><td><div style="word-wrap: break-word;"><b>SC Clock Enable Bit
</b><br>
0 = SC clock generation Disabled.
<br>
1 = SC clock always keeps free running.
<br>
Note: When operating in activation, warm reset or deactivation mode, this bit will be changed automatically.
<br>
Thus, do not fill in this field when operating in these modes.
<br>
</div></td></tr><tr><td>
[9]</td><td>SCDATA</td><td><div style="word-wrap: break-word;"><b>SCn_DATA Pin Signal
</b><br>
This bit is the signal status of SCn_DATA but user can drive SCn_DATA pin to high or low by setting this bit.
<br>
0 = Drive SCn_DATA pin to low.
<br>
1 = Drive SCn_DATA pin to high.
<br>
Read this field to get SCn_DATA signal status.
<br>
0 = SCn_DATA signal status is low.
<br>
1 = SCn_DATA signal status is high.
<br>
Note: When SC is at activation, warm reset or deactivation mode, this bit will be changed automatically.
<br>
Thus, do not fill in this field when SC is in these modes.
<br>
</div></td></tr><tr><td>
[11]</td><td>PWRINV</td><td><div style="word-wrap: break-word;"><b>SCn_PWR Pin Inverse
</b><br>
This bit is used for inverse the SCn_PWR pin.
<br>
There are four kinds of combination for SCn_PWR pin setting by PWRINV (SCn_PINCTL[11]) and PWREN (SCn_PINCTL[0]).
<br>
PWRINV is 0 and PWREN is 0, SCn_PWR pin is 0.
<br>
PWRINV is 0 and PWREN is 1, SCn_PWR pin is 1.
<br>
PWRINV is 1 and PWREN is 0, SCn_PWR pin is 1.
<br>
PWRINV is 1 and PWREN is 1, SCn_PWR pin is 0.
<br>
Note: User must select PWRINV (SCn_PINCTL[11]) before smart card is enabled by SCEN (SCn_CTL[0]).
<br>
</div></td></tr><tr><td>
[16]</td><td>DATASTS</td><td><div style="word-wrap: break-word;"><b>SCn_DATA Pin Status (Read Only)
</b><br>
This bit is the pin status of SCn_DATA.
<br>
0 = The SCn_DATA pin status is low.
<br>
1 = The SCn_DATA pin status is high.
<br>
</div></td></tr><tr><td>
[17]</td><td>PWRSTS</td><td><div style="word-wrap: break-word;"><b>SCn_PWR Pin Status (Read Only)
</b><br>
This bit is the pin status of SCn_PWR.
<br>
0 = SCn_PWR pin to low.
<br>
1 = SCn_PWR pin to high.
<br>
</div></td></tr><tr><td>
[18]</td><td>RSTSTS</td><td><div style="word-wrap: break-word;"><b>SCn_RST Pin Status (Read Only)
</b><br>
This bit is the pin status of SCn_RST.
<br>
0 = SCn_RST pin is low.
<br>
1 = SCn_RST pin is high.
<br>
</div></td></tr><tr><td>
[30]</td><td>SYNC</td><td><div style="word-wrap: break-word;"><b>SYNC Flag Indicator (Read Only)
</b><br>
Due to synchronization, user should check this bit when writing a new value to SCn_PINCTL register.
<br>
0 = Synchronizing is completion, user can write new data to SCn_PINCTL register.
<br>
1 = Last value is synchronizing.
<br>
</div></td></tr></tbody></table></html>

 </p>

<p class="definition">Definition at line <a class="el" href="sc__reg_8h_source.html#l01493">1493</a> of file <a class="el" href="sc__reg_8h_source.html">sc_reg.h</a>.</p>

</div>
</div>
<a id="ad4c1bc739dc56f6b842cd80a44a70515" name="ad4c1bc739dc56f6b842cd80a44a70515"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad4c1bc739dc56f6b842cd80a44a70515">&#9670;&nbsp;</a></span>RXTOUT</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">SC_T::RXTOUT</td>
        </tr>
      </table>
</div><div class="memdoc">
<p >[0x0010] SC Receive Buffer Time-out Counter Register <br  />
</p>
<p > 

<html><table class="fixed" border="1" style="border-collapse:collapse;" borderColor=black ><col width="75px" /><col width="125px" /><col width="700px" /><caption align="left"><font size="3">RXTOUT
</font><br><p> <font size="2">
Offset: 0x10  SC Receive Buffer Time-out Counter Register
</font></caption><thread><tr bgcolor="#8A0808" ><td><font color=white><b>Bits</b></font></td><td><font color=white><b>Field</b></font></td><td><font color=white><b>Descriptions</b></font></td></tr></thread><tbody>
<tr><td>
[8:0]</td><td>RFTM</td><td><div style="word-wrap: break-word;"><b>SC Receiver FIFO Time-out Counter
</b><br>
The time-out down counter resets and starts counting whenever the RX buffer received a new data
<br>
Once the counter decrease to 1 and no new data is received or CPU does not read data by
<br>
reading SCn_DAT, a receiver time-out flag RBTOIF (SCn_INTSTS[9]) will be set, and hardware will
<br>
generate an interrupt to CPU when RBTOIEN (SCn_INTEN[9]) is enabled.
<br>
Note1: The counter unit is ETU based and the interval of time-out is RFTM + 0.5.
<br>
Note2: Filling in all 0 to this field indicates to disable this function.
<br>
</div></td></tr></tbody></table></html>

 </p>

<p class="definition">Definition at line <a class="el" href="sc__reg_8h_source.html#l01488">1488</a> of file <a class="el" href="sc__reg_8h_source.html">sc_reg.h</a>.</p>

</div>
</div>
<a id="a763cbd039f818865fc97569ebfb553e3" name="a763cbd039f818865fc97569ebfb553e3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a763cbd039f818865fc97569ebfb553e3">&#9670;&nbsp;</a></span>STATUS</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">SC_T::STATUS</td>
        </tr>
      </table>
</div><div class="memdoc">
<p >[0x0020] SC Transfer Status Register <br  />
</p>
<p > 

<html><table class="fixed" border="1" style="border-collapse:collapse;" borderColor=black ><col width="75px" /><col width="125px" /><col width="700px" /><caption align="left"><font size="3">STATUS
</font><br><p> <font size="2">
Offset: 0x20  SC Transfer Status Register
</font></caption><thread><tr bgcolor="#8A0808" ><td><font color=white><b>Bits</b></font></td><td><font color=white><b>Field</b></font></td><td><font color=white><b>Descriptions</b></font></td></tr></thread><tbody>
<tr><td>
[0]</td><td>RXOV</td><td><div style="word-wrap: break-word;"><b>Receive Overflow Error Status Flag
</b><br>
This bit is set when Rx buffer overflow.
<br>
0 = Rx buffer is not overflow.
<br>
1 = Rx buffer is overflow when the number of received bytes is greater than Rx buffer size (4 bytes).
<br>
Note: This bit can be cleared by writing 1 to it.
<br>
</div></td></tr><tr><td>
[1]</td><td>RXEMPTY</td><td><div style="word-wrap: break-word;"><b>Receive Buffer Empty Status Flag (Read Only)
</b><br>
This bit indicates Rx buffer empty or not.
<br>
0 = Rx buffer is not empty.
<br>
1 = Rx buffer is empty, it means the last byte of Rx buffer has read from DAT (SCn_DAT[7:0]) by CPU.
<br>
</div></td></tr><tr><td>
[2]</td><td>RXFULL</td><td><div style="word-wrap: break-word;"><b>Receive Buffer Full Status Flag (Read Only)
</b><br>
This bit indicates Rx buffer full or not.
<br>
0 = Rx buffer count is less than 4.
<br>
1 = Rx buffer count equals to 4.
<br>
</div></td></tr><tr><td>
[4]</td><td>PEF</td><td><div style="word-wrap: break-word;"><b>Receiver Parity Error Status Flag
</b><br>
This bit is set to logic 1 whenever the received character does not have a valid parity bit.
<br>
0 = Receiver parity error flag did not occur.
<br>
1 = Receiver parity error flag occurred.
<br>
Note1: This bit can be cleared by writing 1 to it.
<br>
Note2: If CPU sets receiver retries function by setting RXRTYEN (SCn_CTL[19]), hardware will not
<br>
set this flag.
<br>
</div></td></tr><tr><td>
[5]</td><td>FEF</td><td><div style="word-wrap: break-word;"><b>Receiver Frame Error Status Flag
</b><br>
This bit is set to logic 1 whenever the received character does not have a valid stop bit (that is,
<br>
the stop bit following the last data bit or parity bit is detected as logic 0).
<br>
0 = Receiver frame error flag did not occur.
<br>
1 = Receiver frame error flag occurred.
<br>
Note1: This bit can be cleared by writing 1 to it.
<br>
Note2: If CPU sets receiver retries function by setting RXRTYEN (SCn_CTL[19]), hardware will not
<br>
set this flag.
<br>
</div></td></tr><tr><td>
[6]</td><td>BEF</td><td><div style="word-wrap: break-word;"><b>Receiver Break Error Status Flag
</b><br>
This bit is set to logic 1 whenever the received data input (Rx) held in the spacing state
<br>
(logic 0) is longer than a full word transmission time (that is, the total time of start bit +
<br>
data bits + parity bit + stop bit).
<br>
0 = Receiver break error flag did not occur.
<br>
1 = Receiver break error flag occurred.
<br>
Note1: This bit can be cleared by writing 1 to it.
<br>
Note2: If CPU sets receiver retries function by setting RXRTYEN (SCn_CTL[19]), hardware will not set
<br>
this flag.
<br>
</div></td></tr><tr><td>
[8]</td><td>TXOV</td><td><div style="word-wrap: break-word;"><b>Transmit Overflow Error Interrupt Status Flag
</b><br>
This bit is set when Tx buffer overflow.
<br>
0 = Tx buffer is not overflow.
<br>
1 = Tx buffer is overflow when Tx buffer is full and an additional write operation to DAT (SCn_DAT[7:0]).
<br>
Note: This bit can be cleared by writing 1 to it.
<br>
</div></td></tr><tr><td>
[9]</td><td>TXEMPTY</td><td><div style="word-wrap: break-word;"><b>Transmit Buffer Empty Status Flag (Read Only)
</b><br>
This bit indicates TX buffer empty or not.
<br>
0 = Tx buffer is not empty.
<br>
1 = Tx buffer is empty, it means the last byte of Tx buffer has been transferred to Transmitter
<br>
Shift Register.
<br>
Note: This bit will be cleared when writing data into DAT (SCn_DAT[7:0]).
<br>
</div></td></tr><tr><td>
[10]</td><td>TXFULL</td><td><div style="word-wrap: break-word;"><b>Transmit Buffer Full Status Flag (Read Only)
</b><br>
This bit indicates Tx buffer full or not.
<br>
0 = Tx buffer count is less than 4.
<br>
1 = Tx buffer count equals to 4.
<br>
</div></td></tr><tr><td>
[11]</td><td>CREMOVE</td><td><div style="word-wrap: break-word;"><b>Card Removal Status of SCn_CD Pin
</b><br>
This bit is set whenever card has been removal.
<br>
0 = No effect.
<br>
1 = Card removed.
<br>
Note1: This bit can be cleared by writing 1 to it.
<br>
Note2: Card detect function will start after SCEN (SCn_CTL[0]) set.
<br>
</div></td></tr><tr><td>
[12]</td><td>CINSERT</td><td><div style="word-wrap: break-word;"><b>Card Insert Status of SCn_CD Pin
</b><br>
This bit is set whenever card has been inserted.
<br>
0 = No effect.
<br>
1 = Card insert.
<br>
Note1: This bit can be cleared by writing 1 to it.
<br>
Note2: The card detect function will start after SCEN (SCn_CTL[0]) set.
<br>
</div></td></tr><tr><td>
[13]</td><td>CDPINSTS</td><td><div style="word-wrap: break-word;"><b>Card Detect Pin Status (Read Only)
</b><br>
This bit is the pin status of SCn_CD.
<br>
0 = The SCn_CD pin state at low.
<br>
1 = The SCn_CD pin state at high.
<br>
</div></td></tr><tr><td>
[18:16]</td><td>RXPOINT</td><td><div style="word-wrap: break-word;"><b>Receive Buffer Pointer Status (Read Only)
</b><br>
This field indicates the Rx buffer pointer status
<br>
When SC controller receives one byte from external device, RXPOINT increases one
<br>
When one byte of Rx buffer is read by CPU, RXPOINT decreases one.
<br>
</div></td></tr><tr><td>
[21]</td><td>RXRERR</td><td><div style="word-wrap: break-word;"><b>Receiver Retry Error
</b><br>
This bit is used for receiver error retry and set by hardware.
<br>
0 = No Rx retry transfer.
<br>
1 = Rx has any error and retries transfer.
<br>
Note1: This bit can be cleared by writing 1 to it.
<br>
Note2 This bit is a flag and cannot generate any interrupt to CPU.
<br>
Note3: If CPU enables receiver retries function by setting RXRTYEN (SCn_CTL[19]),
<br>
hardware will not set this flag.
<br>
</div></td></tr><tr><td>
[22]</td><td>RXOVERR</td><td><div style="word-wrap: break-word;"><b>Receiver over Retry Error
</b><br>
This bit is used for receiver retry counts over than retry number limitation.
<br>
0 = Receiver retries counts is not over than RXRTY (SCn_CTL[18:16]) + 1.
<br>
1 = Receiver retries counts over than RXRTY (SCn_CTL[18:16]) + 1.
<br>
Note1: This bit can be cleared by writing 1 to it.
<br>
Note2: If CPU enables receiver retries function by setting RXRTYEN (SCn_CTL[19]), hardware
<br>
will not set this flag.
<br>
</div></td></tr><tr><td>
[23]</td><td>RXACT</td><td><div style="word-wrap: break-word;"><b>Receiver in Active Status Flag (Read Only)
</b><br>
This bit indicates Rx transfer status.
<br>
0 = This bit is cleared automatically when Rx transfer is finished.
<br>
1 = This bit is set by hardware when Rx transfer is in active.
<br>
Note: This bit is read only.
<br>
</div></td></tr><tr><td>
[26:24]</td><td>TXPOINT</td><td><div style="word-wrap: break-word;"><b>Transmit Buffer Pointer Status (Read Only)
</b><br>
This field indicates the Tx buffer pointer status
<br>
When CPU writes data into SCn_DAT, TXPOINT increases one
<br>
When one byte of Tx buffer is transferred to transmitter shift register, TXPOINT decreases one.
<br>
</div></td></tr><tr><td>
[29]</td><td>TXRERR</td><td><div style="word-wrap: break-word;"><b>Transmitter Retry Error
</b><br>
This bit is used for indicate transmitter error retry and set by hardware.
<br>
0 = No Tx retry transfer.
<br>
1 = Tx has any error and retries transfer.
<br>
Note1: This bit can be cleared by writing 1 to it.
<br>
Note2: This bit is a flag and cannot generate any interrupt to CPU.
<br>
</div></td></tr><tr><td>
[30]</td><td>TXOVERR</td><td><div style="word-wrap: break-word;"><b>Transmitter over Retry Error
</b><br>
This bit is used for transmitter retry counts over than retry number limitation.
<br>
0 = Transmitter retries counts is not over than TXRTY (SCn_CTL[22:20]) + 1.
<br>
1 = Transmitter retries counts over than TXRTY (SCn_CTL[22:20]) + 1.
<br>
Note: This bit can be cleared by writing 1 to it.
<br>
</div></td></tr><tr><td>
[31]</td><td>TXACT</td><td><div style="word-wrap: break-word;"><b>Transmit in Active Status Flag (Read Only)
</b><br>
This bit indicates Tx transmit status.
<br>
0 = This bit is cleared automatically when Tx transfer is finished or the last byte transmission
<br>
has completed.
<br>
1 = Transmit is active and this bit is set by hardware when Tx transfer is in active and the STOP
<br>
bit of the last byte has not been transmitted.
<br>
Note: This bit is read only.
<br>
</div></td></tr></tbody></table></html>

 </p>

<p class="definition">Definition at line <a class="el" href="sc__reg_8h_source.html#l01492">1492</a> of file <a class="el" href="sc__reg_8h_source.html">sc_reg.h</a>.</p>

</div>
</div>
<a id="a7f9dd18f1316d1fd3faf6e9f5c2d0d3d" name="a7f9dd18f1316d1fd3faf6e9f5c2d0d3d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7f9dd18f1316d1fd3faf6e9f5c2d0d3d">&#9670;&nbsp;</a></span>TMRCTL0</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">SC_T::TMRCTL0</td>
        </tr>
      </table>
</div><div class="memdoc">
<p >[0x0028] SC Internal Timer0 Control Register <br  />
</p>
<p > 

<html><table class="fixed" border="1" style="border-collapse:collapse;" borderColor=black ><col width="75px" /><col width="125px" /><col width="700px" /><caption align="left"><font size="3">TMRCTL0
</font><br><p> <font size="2">
Offset: 0x28  SC Internal Timer0 Control Register
</font></caption><thread><tr bgcolor="#8A0808" ><td><font color=white><b>Bits</b></font></td><td><font color=white><b>Field</b></font></td><td><font color=white><b>Descriptions</b></font></td></tr></thread><tbody>
<tr><td>
[23:0]</td><td>CNT</td><td><div style="word-wrap: break-word;"><b>Timer0 Counter Value
</b><br>
This field indicates the internal Timer0 counter values.
<br>
Note: Unit of Timer0 counter is ETU base.
<br>
</div></td></tr><tr><td>
[27:24]</td><td>OPMODE</td><td><div style="word-wrap: break-word;"><b>Timer0 Operation Mode Selection
</b><br>
This field indicates the internal 24-bit Timer0 operation selection.
<br>
Refer to Table 7.17-3 for programming Timer0.
<br>
</div></td></tr><tr><td>
[31]</td><td>SYNC</td><td><div style="word-wrap: break-word;"><b>SYNC Flag Indicator (Read Only)
</b><br>
Due to synchronization, user should check this bit when writing a new value to the SCn_TMRCTL0 register.
<br>
0 = Synchronizing is completion, user can write new data to SCn_TMRCTL0 register.
<br>
1 = Last value is synchronizing.
<br>
</div></td></tr></tbody></table></html>

 </p>

<p class="definition">Definition at line <a class="el" href="sc__reg_8h_source.html#l01494">1494</a> of file <a class="el" href="sc__reg_8h_source.html">sc_reg.h</a>.</p>

</div>
</div>
<a id="a93ec89f4fa30ee9e8c6480abf814d849" name="a93ec89f4fa30ee9e8c6480abf814d849"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a93ec89f4fa30ee9e8c6480abf814d849">&#9670;&nbsp;</a></span>TMRCTL1</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">SC_T::TMRCTL1</td>
        </tr>
      </table>
</div><div class="memdoc">
<p >[0x002c] SC Internal Timer1 Control Register <br  />
</p>
<p > 

<html><table class="fixed" border="1" style="border-collapse:collapse;" borderColor=black ><col width="75px" /><col width="125px" /><col width="700px" /><caption align="left"><font size="3">TMRCTL1
</font><br><p> <font size="2">
Offset: 0x2C  SC Internal Timer1 Control Register
</font></caption><thread><tr bgcolor="#8A0808" ><td><font color=white><b>Bits</b></font></td><td><font color=white><b>Field</b></font></td><td><font color=white><b>Descriptions</b></font></td></tr></thread><tbody>
<tr><td>
[7:0]</td><td>CNT</td><td><div style="word-wrap: break-word;"><b>Timer 1 Counter Value
</b><br>
This field indicates the internal Timer1 counter values.
<br>
Note: Unit of Timer1 counter is ETU base.
<br>
</div></td></tr><tr><td>
[27:24]</td><td>OPMODE</td><td><div style="word-wrap: break-word;"><b>Timer 1 Operation Mode Selection
</b><br>
This field indicates the internal 8-bit Timer1 operation selection.
<br>
Refer to Table 7.17-3 for programming Timer1.
<br>
</div></td></tr><tr><td>
[31]</td><td>SYNC</td><td><div style="word-wrap: break-word;"><b>SYNC Flag Indicator (Read Only)
</b><br>
Due to synchronization, software should check this bit when writing a new value to SCn_TMRCTL1 register.
<br>
0 = Synchronizing is completion, user can write new data to SCn_TMRCTL1 register.
<br>
1 = Last value is synchronizing.
<br>
</div></td></tr></tbody></table></html>

 </p>

<p class="definition">Definition at line <a class="el" href="sc__reg_8h_source.html#l01495">1495</a> of file <a class="el" href="sc__reg_8h_source.html">sc_reg.h</a>.</p>

</div>
</div>
<a id="a12c05c3ae1f45e417764abe3ab1d769c" name="a12c05c3ae1f45e417764abe3ab1d769c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a12c05c3ae1f45e417764abe3ab1d769c">&#9670;&nbsp;</a></span>TMRCTL2</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">SC_T::TMRCTL2</td>
        </tr>
      </table>
</div><div class="memdoc">
<p >[0x0030] SC Internal Timer2 Control Register <br  />
</p>
<p > 

<html><table class="fixed" border="1" style="border-collapse:collapse;" borderColor=black ><col width="75px" /><col width="125px" /><col width="700px" /><caption align="left"><font size="3">TMRCTL2
</font><br><p> <font size="2">
Offset: 0x30  SC Internal Timer2 Control Register
</font></caption><thread><tr bgcolor="#8A0808" ><td><font color=white><b>Bits</b></font></td><td><font color=white><b>Field</b></font></td><td><font color=white><b>Descriptions</b></font></td></tr></thread><tbody>
<tr><td>
[7:0]</td><td>CNT</td><td><div style="word-wrap: break-word;"><b>Timer 2 Counter Value
</b><br>
This field indicates the internal Timer2 counter values.
<br>
Note: Unit of Timer2 counter is ETU base.
<br>
</div></td></tr><tr><td>
[27:24]</td><td>OPMODE</td><td><div style="word-wrap: break-word;"><b>Timer 2 Operation Mode Selection
</b><br>
This field indicates the internal 8-bit Timer2 operation selection
<br>
Refer to Table 7.17-3 for programming Timer2.
<br>
</div></td></tr><tr><td>
[31]</td><td>SYNC</td><td><div style="word-wrap: break-word;"><b>SYNC Flag Indicator (Read Only)
</b><br>
Due to synchronization, user should check this bit when writing a new value to SCn_TMRCTL2 register.
<br>
0 = Synchronizing is completion, user can write new data to SCn_TMRCTL2 register.
<br>
1 = Last value is synchronizing.
<br>
</div></td></tr></tbody></table></html>

 </p>

<p class="definition">Definition at line <a class="el" href="sc__reg_8h_source.html#l01496">1496</a> of file <a class="el" href="sc__reg_8h_source.html">sc_reg.h</a>.</p>

</div>
</div>
<a id="aaea818bd8186138fa212ebf17ffbd8d5" name="aaea818bd8186138fa212ebf17ffbd8d5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaea818bd8186138fa212ebf17ffbd8d5">&#9670;&nbsp;</a></span>UARTCTL</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">SC_T::UARTCTL</td>
        </tr>
      </table>
</div><div class="memdoc">
<p >[0x0034] SC UART Mode Control Register <br  />
</p>
<p > 

<html><table class="fixed" border="1" style="border-collapse:collapse;" borderColor=black ><col width="75px" /><col width="125px" /><col width="700px" /><caption align="left"><font size="3">UARTCTL
</font><br><p> <font size="2">
Offset: 0x34  SC UART Mode Control Register
</font></caption><thread><tr bgcolor="#8A0808" ><td><font color=white><b>Bits</b></font></td><td><font color=white><b>Field</b></font></td><td><font color=white><b>Descriptions</b></font></td></tr></thread><tbody>
<tr><td>
[0]</td><td>UARTEN</td><td><div style="word-wrap: break-word;"><b>UART Mode Enable Bit
</b><br>
Sets this bit to enable UART mode function.
<br>
0 = Smart Card mode.
<br>
1 = UART mode.
<br>
Note1: When operating in UART mode, user must set CONSEL (SCn_CTL[5:4]) = 00 and AUTOCEN (SCn_CTL[3]) = 0.
<br>
Note2: When operating in Smart Card mode, user must set UARTEN (SCn_UARTCTL[0]) = 0.
<br>
Note3: When UART mode is enabled, hardware will generate a reset to reset FIFO and internal state machine.
<br>
</div></td></tr><tr><td>
[5:4]</td><td>WLS</td><td><div style="word-wrap: break-word;"><b>Word Length Selection
</b><br>
This field is used for select UART data length.
<br>
00 = Word length is 8 bits.
<br>
01 = Word length is 7 bits.
<br>
10 = Word length is 6 bits.
<br>
11 = Word length is 5 bits.
<br>
Note: In smart card mode, this WLS must be '00'.
<br>
</div></td></tr><tr><td>
[6]</td><td>PBOFF</td><td><div style="word-wrap: break-word;"><b>Parity Bit Disable Control
</b><br>
Sets this bit is used for disable parity check function.
<br>
0 = Parity bit is generated or checked between the last data word bit and stop bit of the serial data.
<br>
1 = Parity bit is not generated (transmitting data) or checked (receiving data) during transfer.
<br>
Note: In smart card mode, this field must be '0' (default setting is with parity bit).
<br>
</div></td></tr><tr><td>
[7]</td><td>OPE</td><td><div style="word-wrap: break-word;"><b>Odd Parity Enable Bit
</b><br>
This is used for odd/even parity selection.
<br>
0 = Even number of logic 1's are transmitted or check the data word and parity bits in receiving mode.
<br>
1 = Odd number of logic 1's are transmitted or check the data word and parity bits in receiving mode.
<br>
Note: This bit has effect only when PBOFF bit is '0'.
<br>
</div></td></tr></tbody></table></html>

 </p>

<p class="definition">Definition at line <a class="el" href="sc__reg_8h_source.html#l01497">1497</a> of file <a class="el" href="sc__reg_8h_source.html">sc_reg.h</a>.</p>

</div>
</div>
<hr/>The documentation for this struct was generated from the following file:<ul>
<li>Library/Device/Nuvoton/M480/Include/<a class="el" href="sc__reg_8h_source.html">sc_reg.h</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Thu Sep 18 2025 10:07:26 for M480 BSP by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.3
</small></address>
</body>
</html>
