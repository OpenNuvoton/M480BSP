<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.3"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>M480 BSP: EPWM_T Struct Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectlogo"><img alt="Logo" src="m4.jpg"/></td>
  <td id="projectalign">
   <div id="projectname">M480 BSP<span id="projectnumber">&#160;V3.06.000</span>
   </div>
   <div id="projectbrief">The Board Support Package for M480 Series</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.3 -->
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',false,false,'search.php','Search');
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-attribs">Data Fields</a>  </div>
  <div class="headertitle"><div class="title">EPWM_T Struct Reference<div class="ingroups"><a class="el" href="group___r_e_g_i_s_t_e_r.html">Control Register</a></div></div></div>
</div><!--header-->
<div class="contents">

<p><code>#include &lt;<a class="el" href="epwm__reg_8h_source.html">epwm_reg.h</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-attribs" name="pub-attribs"></a>
Data Fields</h2></td></tr>
<tr class="memitem:acb716eb6cd9de345d432a2d8e862868c"><td class="memItemLeft" align="right" valign="top">__IO uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_e_p_w_m___t.html#acb716eb6cd9de345d432a2d8e862868c">CTL0</a></td></tr>
<tr class="separator:acb716eb6cd9de345d432a2d8e862868c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a65b83a80a8d852b1fe62bae935c4d41b"><td class="memItemLeft" align="right" valign="top">__IO uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_e_p_w_m___t.html#a65b83a80a8d852b1fe62bae935c4d41b">CTL1</a></td></tr>
<tr class="separator:a65b83a80a8d852b1fe62bae935c4d41b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac41f21d8583921ac8b3543ed6b75e848"><td class="memItemLeft" align="right" valign="top">__IO uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_e_p_w_m___t.html#ac41f21d8583921ac8b3543ed6b75e848">SYNC</a></td></tr>
<tr class="separator:ac41f21d8583921ac8b3543ed6b75e848"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2685e3adfb6e8b9ead4d16c4e4d4a027"><td class="memItemLeft" align="right" valign="top">__IO uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_e_p_w_m___t.html#a2685e3adfb6e8b9ead4d16c4e4d4a027">SWSYNC</a></td></tr>
<tr class="separator:a2685e3adfb6e8b9ead4d16c4e4d4a027"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0543aacf1d502959cb15aa97238d8c12"><td class="memItemLeft" align="right" valign="top">__IO uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_e_p_w_m___t.html#a0543aacf1d502959cb15aa97238d8c12">CLKSRC</a></td></tr>
<tr class="separator:a0543aacf1d502959cb15aa97238d8c12"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a47280570c4b39bb7b3df7fab3401cdb3"><td class="memItemLeft" align="right" valign="top">__IO uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_e_p_w_m___t.html#a47280570c4b39bb7b3df7fab3401cdb3">CLKPSC</a> [3]</td></tr>
<tr class="separator:a47280570c4b39bb7b3df7fab3401cdb3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac03c511206eb9035e1a1d3205432a88d"><td class="memItemLeft" align="right" valign="top">__IO uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_e_p_w_m___t.html#ac03c511206eb9035e1a1d3205432a88d">CNTEN</a></td></tr>
<tr class="separator:ac03c511206eb9035e1a1d3205432a88d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5d6b4513719efeba3a167396262587e8"><td class="memItemLeft" align="right" valign="top">__IO uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_e_p_w_m___t.html#a5d6b4513719efeba3a167396262587e8">CNTCLR</a></td></tr>
<tr class="separator:a5d6b4513719efeba3a167396262587e8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a95d88226a73492d643da5cd80af46b22"><td class="memItemLeft" align="right" valign="top">__IO uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_e_p_w_m___t.html#a95d88226a73492d643da5cd80af46b22">LOAD</a></td></tr>
<tr class="separator:a95d88226a73492d643da5cd80af46b22"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aef471688e87b595cdcee3a8476b52837"><td class="memItemLeft" align="right" valign="top">__IO uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_e_p_w_m___t.html#aef471688e87b595cdcee3a8476b52837">PERIOD</a> [6]</td></tr>
<tr class="separator:aef471688e87b595cdcee3a8476b52837"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6125934b63ce0713054bb320d89cfb80"><td class="memItemLeft" align="right" valign="top">__IO uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_e_p_w_m___t.html#a6125934b63ce0713054bb320d89cfb80">CMPDAT</a> [6]</td></tr>
<tr class="separator:a6125934b63ce0713054bb320d89cfb80"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afda9ab3337ef420e2b2ee40151347f42"><td class="memItemLeft" align="right" valign="top">__IO uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_e_p_w_m___t.html#afda9ab3337ef420e2b2ee40151347f42">DTCTL</a> [3]</td></tr>
<tr class="separator:afda9ab3337ef420e2b2ee40151347f42"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a83a42ab29cc1a0187c204d9a49366cc7"><td class="memItemLeft" align="right" valign="top">__IO uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_e_p_w_m___t.html#a83a42ab29cc1a0187c204d9a49366cc7">PHS</a> [3]</td></tr>
<tr class="separator:a83a42ab29cc1a0187c204d9a49366cc7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8ec40b43ba7f0e40755ff49ea8f5ef82"><td class="memItemLeft" align="right" valign="top">__I uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_e_p_w_m___t.html#a8ec40b43ba7f0e40755ff49ea8f5ef82">CNT</a> [6]</td></tr>
<tr class="separator:a8ec40b43ba7f0e40755ff49ea8f5ef82"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7bc270fb354c810fd8f2dd4bbc871ddb"><td class="memItemLeft" align="right" valign="top">__IO uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_e_p_w_m___t.html#a7bc270fb354c810fd8f2dd4bbc871ddb">WGCTL0</a></td></tr>
<tr class="separator:a7bc270fb354c810fd8f2dd4bbc871ddb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2907994515eb17ac1a1a3879022bc0bc"><td class="memItemLeft" align="right" valign="top">__IO uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_e_p_w_m___t.html#a2907994515eb17ac1a1a3879022bc0bc">WGCTL1</a></td></tr>
<tr class="separator:a2907994515eb17ac1a1a3879022bc0bc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a823c55123442bc4ae77bdec636747ff8"><td class="memItemLeft" align="right" valign="top">__IO uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_e_p_w_m___t.html#a823c55123442bc4ae77bdec636747ff8">MSKEN</a></td></tr>
<tr class="separator:a823c55123442bc4ae77bdec636747ff8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3a8ad62b46e87f2f426324392b2bcdeb"><td class="memItemLeft" align="right" valign="top">__IO uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_e_p_w_m___t.html#a3a8ad62b46e87f2f426324392b2bcdeb">MSK</a></td></tr>
<tr class="separator:a3a8ad62b46e87f2f426324392b2bcdeb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a162fe20c6321426bc6a1b14e7cddf050"><td class="memItemLeft" align="right" valign="top">__IO uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_e_p_w_m___t.html#a162fe20c6321426bc6a1b14e7cddf050">BNF</a></td></tr>
<tr class="separator:a162fe20c6321426bc6a1b14e7cddf050"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaafde4645853ebcfd2d4bd6a1b37aaeb"><td class="memItemLeft" align="right" valign="top">__IO uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_e_p_w_m___t.html#aaafde4645853ebcfd2d4bd6a1b37aaeb">FAILBRK</a></td></tr>
<tr class="separator:aaafde4645853ebcfd2d4bd6a1b37aaeb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5537551059205d37c741d6771d251f9f"><td class="memItemLeft" align="right" valign="top">__IO uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_e_p_w_m___t.html#a5537551059205d37c741d6771d251f9f">BRKCTL</a> [3]</td></tr>
<tr class="separator:a5537551059205d37c741d6771d251f9f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9ce1aa1a288b7373fadfba292fcadde6"><td class="memItemLeft" align="right" valign="top">__IO uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_e_p_w_m___t.html#a9ce1aa1a288b7373fadfba292fcadde6">POLCTL</a></td></tr>
<tr class="separator:a9ce1aa1a288b7373fadfba292fcadde6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad4c7e260588d0c804f659dae62f38c3a"><td class="memItemLeft" align="right" valign="top">__IO uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_e_p_w_m___t.html#ad4c7e260588d0c804f659dae62f38c3a">POEN</a></td></tr>
<tr class="separator:ad4c7e260588d0c804f659dae62f38c3a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1c8f2c8f367831306338ff64af27dd4d"><td class="memItemLeft" align="right" valign="top">__O uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_e_p_w_m___t.html#a1c8f2c8f367831306338ff64af27dd4d">SWBRK</a></td></tr>
<tr class="separator:a1c8f2c8f367831306338ff64af27dd4d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac30d912d6f73186575d642cb21054c8b"><td class="memItemLeft" align="right" valign="top">__IO uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_e_p_w_m___t.html#ac30d912d6f73186575d642cb21054c8b">INTEN0</a></td></tr>
<tr class="separator:ac30d912d6f73186575d642cb21054c8b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7f1f5c00628e57d5bd685ce576d0541e"><td class="memItemLeft" align="right" valign="top">__IO uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_e_p_w_m___t.html#a7f1f5c00628e57d5bd685ce576d0541e">INTEN1</a></td></tr>
<tr class="separator:a7f1f5c00628e57d5bd685ce576d0541e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac4525812584da5c59bba9add04679d70"><td class="memItemLeft" align="right" valign="top">__IO uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_e_p_w_m___t.html#ac4525812584da5c59bba9add04679d70">INTSTS0</a></td></tr>
<tr class="separator:ac4525812584da5c59bba9add04679d70"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a69ed3ad4bafb67436be2ec1bcefbdc20"><td class="memItemLeft" align="right" valign="top">__IO uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_e_p_w_m___t.html#a69ed3ad4bafb67436be2ec1bcefbdc20">INTSTS1</a></td></tr>
<tr class="separator:a69ed3ad4bafb67436be2ec1bcefbdc20"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaa04cd853d1a6050087aff68a61eaa73"><td class="memItemLeft" align="right" valign="top">__IO uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_e_p_w_m___t.html#aaa04cd853d1a6050087aff68a61eaa73">DACTRGEN</a></td></tr>
<tr class="separator:aaa04cd853d1a6050087aff68a61eaa73"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2083e1da8902a1717ca0968441a8c078"><td class="memItemLeft" align="right" valign="top">__IO uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_e_p_w_m___t.html#a2083e1da8902a1717ca0968441a8c078">EADCTS0</a></td></tr>
<tr class="separator:a2083e1da8902a1717ca0968441a8c078"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4d8548edd2bddc6db90d8cda12032bc8"><td class="memItemLeft" align="right" valign="top">__IO uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_e_p_w_m___t.html#a4d8548edd2bddc6db90d8cda12032bc8">EADCTS1</a></td></tr>
<tr class="separator:a4d8548edd2bddc6db90d8cda12032bc8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aacba8b9a1005bb376cb5f1420647aefc"><td class="memItemLeft" align="right" valign="top">__IO uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_e_p_w_m___t.html#aacba8b9a1005bb376cb5f1420647aefc">FTCMPDAT</a> [3]</td></tr>
<tr class="separator:aacba8b9a1005bb376cb5f1420647aefc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9a66b72e270c7892f93f0683d05cc3cd"><td class="memItemLeft" align="right" valign="top">__IO uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_e_p_w_m___t.html#a9a66b72e270c7892f93f0683d05cc3cd">SSCTL</a></td></tr>
<tr class="separator:a9a66b72e270c7892f93f0683d05cc3cd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a936f9d8b8d66fe11ec36955fb058af66"><td class="memItemLeft" align="right" valign="top">__O uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_e_p_w_m___t.html#a936f9d8b8d66fe11ec36955fb058af66">SSTRG</a></td></tr>
<tr class="separator:a936f9d8b8d66fe11ec36955fb058af66"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad29b3637bb7bb5ad0e28268be133fc47"><td class="memItemLeft" align="right" valign="top">__IO uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_e_p_w_m___t.html#ad29b3637bb7bb5ad0e28268be133fc47">LEBCTL</a></td></tr>
<tr class="separator:ad29b3637bb7bb5ad0e28268be133fc47"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a65d0bfd62ef05ecc6a83efd597e7ccb1"><td class="memItemLeft" align="right" valign="top">__IO uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_e_p_w_m___t.html#a65d0bfd62ef05ecc6a83efd597e7ccb1">LEBCNT</a></td></tr>
<tr class="separator:a65d0bfd62ef05ecc6a83efd597e7ccb1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a31307aa536101540e378d3546911cb17"><td class="memItemLeft" align="right" valign="top">__IO uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_e_p_w_m___t.html#a31307aa536101540e378d3546911cb17">STATUS</a></td></tr>
<tr class="separator:a31307aa536101540e378d3546911cb17"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a55af089b93404f05e2ae70bf920ebad1"><td class="memItemLeft" align="right" valign="top">__IO uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_e_p_w_m___t.html#a55af089b93404f05e2ae70bf920ebad1">IFA</a> [6]</td></tr>
<tr class="separator:a55af089b93404f05e2ae70bf920ebad1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af6179be82143fc604f67a9ceab457293"><td class="memItemLeft" align="right" valign="top">__IO uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_e_p_w_m___t.html#af6179be82143fc604f67a9ceab457293">AINTSTS</a></td></tr>
<tr class="separator:af6179be82143fc604f67a9ceab457293"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a918bd4203550ca04d31953ec2340e404"><td class="memItemLeft" align="right" valign="top">__IO uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_e_p_w_m___t.html#a918bd4203550ca04d31953ec2340e404">AINTEN</a></td></tr>
<tr class="separator:a918bd4203550ca04d31953ec2340e404"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3de246f6adad207354bee8fa7c592604"><td class="memItemLeft" align="right" valign="top">__IO uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_e_p_w_m___t.html#a3de246f6adad207354bee8fa7c592604">APDMACTL</a></td></tr>
<tr class="separator:a3de246f6adad207354bee8fa7c592604"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a90190c2bd39ff8f6fcb92b1668bc1793"><td class="memItemLeft" align="right" valign="top">__IO uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_e_p_w_m___t.html#a90190c2bd39ff8f6fcb92b1668bc1793">FDEN</a></td></tr>
<tr class="separator:a90190c2bd39ff8f6fcb92b1668bc1793"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1e314303fd0e177993bb6223bfd7d067"><td class="memItemLeft" align="right" valign="top">__IO uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_e_p_w_m___t.html#a1e314303fd0e177993bb6223bfd7d067">FDCTL</a> [6]</td></tr>
<tr class="separator:a1e314303fd0e177993bb6223bfd7d067"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8680c0b32d475cd4df0d7ce50bb5365a"><td class="memItemLeft" align="right" valign="top">__IO uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_e_p_w_m___t.html#a8680c0b32d475cd4df0d7ce50bb5365a">FDIEN</a></td></tr>
<tr class="separator:a8680c0b32d475cd4df0d7ce50bb5365a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a43c6be6a727eb60307f72c476ca58eff"><td class="memItemLeft" align="right" valign="top">__IO uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_e_p_w_m___t.html#a43c6be6a727eb60307f72c476ca58eff">FDSTS</a></td></tr>
<tr class="separator:a43c6be6a727eb60307f72c476ca58eff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad229e802469432db695160d2d487600a"><td class="memItemLeft" align="right" valign="top">__IO uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_e_p_w_m___t.html#ad229e802469432db695160d2d487600a">EADCPSCCTL</a></td></tr>
<tr class="separator:ad229e802469432db695160d2d487600a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a556f22b6afb66f66aef4fb2d155a01da"><td class="memItemLeft" align="right" valign="top">__IO uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_e_p_w_m___t.html#a556f22b6afb66f66aef4fb2d155a01da">EADCPSC0</a></td></tr>
<tr class="separator:a556f22b6afb66f66aef4fb2d155a01da"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a54d288d4d6f810db91ed68eae97f3f83"><td class="memItemLeft" align="right" valign="top">__IO uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_e_p_w_m___t.html#a54d288d4d6f810db91ed68eae97f3f83">EADCPSC1</a></td></tr>
<tr class="separator:a54d288d4d6f810db91ed68eae97f3f83"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeadd497278fe0a72142dedc2c79302bc"><td class="memItemLeft" align="right" valign="top">__IO uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_e_p_w_m___t.html#aeadd497278fe0a72142dedc2c79302bc">EADCPSCNT0</a></td></tr>
<tr class="separator:aeadd497278fe0a72142dedc2c79302bc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab2b72d469cf368d9ce25e01de7aef6cb"><td class="memItemLeft" align="right" valign="top">__IO uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_e_p_w_m___t.html#ab2b72d469cf368d9ce25e01de7aef6cb">EADCPSCNT1</a></td></tr>
<tr class="separator:ab2b72d469cf368d9ce25e01de7aef6cb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa7bac642d662381258fbc23433597421"><td class="memItemLeft" align="right" valign="top">__IO uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_e_p_w_m___t.html#aa7bac642d662381258fbc23433597421">CAPINEN</a></td></tr>
<tr class="separator:aa7bac642d662381258fbc23433597421"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0ecb00063ff8028504c0bf1e86495fef"><td class="memItemLeft" align="right" valign="top">__IO uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_e_p_w_m___t.html#a0ecb00063ff8028504c0bf1e86495fef">CAPCTL</a></td></tr>
<tr class="separator:a0ecb00063ff8028504c0bf1e86495fef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac931bb118f7dc1f5333654890725e5b9"><td class="memItemLeft" align="right" valign="top">__I uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_e_p_w_m___t.html#ac931bb118f7dc1f5333654890725e5b9">CAPSTS</a></td></tr>
<tr class="separator:ac931bb118f7dc1f5333654890725e5b9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4dc2516ee1fee3cb749c68bac0211790"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_e_c_a_p_d_a_t___t.html">ECAPDAT_T</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_e_p_w_m___t.html#a4dc2516ee1fee3cb749c68bac0211790">CAPDAT</a> [6]</td></tr>
<tr class="separator:a4dc2516ee1fee3cb749c68bac0211790"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a55410e119fe4361458132632c70526ab"><td class="memItemLeft" align="right" valign="top">__IO uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_e_p_w_m___t.html#a55410e119fe4361458132632c70526ab">PDMACTL</a></td></tr>
<tr class="separator:a55410e119fe4361458132632c70526ab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a26262c3ffe1ddffdb647adf86ab5e7af"><td class="memItemLeft" align="right" valign="top">__I uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_e_p_w_m___t.html#a26262c3ffe1ddffdb647adf86ab5e7af">PDMACAP</a> [3]</td></tr>
<tr class="separator:a26262c3ffe1ddffdb647adf86ab5e7af"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa2e9b43fe93524b9fd6a0d263fb023bc"><td class="memItemLeft" align="right" valign="top">__IO uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_e_p_w_m___t.html#aa2e9b43fe93524b9fd6a0d263fb023bc">CAPIEN</a></td></tr>
<tr class="separator:aa2e9b43fe93524b9fd6a0d263fb023bc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae94af34fab3038bb96ea977115cf0a73"><td class="memItemLeft" align="right" valign="top">__IO uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_e_p_w_m___t.html#ae94af34fab3038bb96ea977115cf0a73">CAPIF</a></td></tr>
<tr class="separator:ae94af34fab3038bb96ea977115cf0a73"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a32ffeb6169978057756e218ef00b4f5b"><td class="memItemLeft" align="right" valign="top">__I uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_e_p_w_m___t.html#a32ffeb6169978057756e218ef00b4f5b">PBUF</a> [6]</td></tr>
<tr class="separator:a32ffeb6169978057756e218ef00b4f5b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a28b40a46d04b9b891448a7f1a415ff86"><td class="memItemLeft" align="right" valign="top">__I uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_e_p_w_m___t.html#a28b40a46d04b9b891448a7f1a415ff86">CMPBUF</a> [6]</td></tr>
<tr class="separator:a28b40a46d04b9b891448a7f1a415ff86"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a111855c3ba8fa8ab68d686992be123b4"><td class="memItemLeft" align="right" valign="top">__I uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_e_p_w_m___t.html#a111855c3ba8fa8ab68d686992be123b4">CPSCBUF</a> [3]</td></tr>
<tr class="separator:a111855c3ba8fa8ab68d686992be123b4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3aeb1fe9b7398283bd30499fd30fc5a5"><td class="memItemLeft" align="right" valign="top">__I uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_e_p_w_m___t.html#a3aeb1fe9b7398283bd30499fd30fc5a5">FTCBUF</a> [3]</td></tr>
<tr class="separator:a3aeb1fe9b7398283bd30499fd30fc5a5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2a2bf0d1fa9e150be77816f682da9dbf"><td class="memItemLeft" align="right" valign="top">__IO uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_e_p_w_m___t.html#a2a2bf0d1fa9e150be77816f682da9dbf">FTCI</a></td></tr>
<tr class="separator:a2a2bf0d1fa9e150be77816f682da9dbf"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock">
<p class="definition">Definition at line <a class="el" href="epwm__reg_8h_source.html#l00071">71</a> of file <a class="el" href="epwm__reg_8h_source.html">epwm_reg.h</a>.</p>
</div><h2 class="groupheader">Field Documentation</h2>
<a id="a918bd4203550ca04d31953ec2340e404" name="a918bd4203550ca04d31953ec2340e404"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a918bd4203550ca04d31953ec2340e404">&#9670;&nbsp;</a></span>AINTEN</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">EPWM_T::AINTEN</td>
        </tr>
      </table>
</div><div class="memdoc">
<p >[0x0154] EPWM Accumulator Interrupt Enable Register <br  />
</p>
<p > 

<html><table class="fixed" border="1" style="border-collapse:collapse;" borderColor=black ><col width="75px" /><col width="125px" /><col width="700px" /><caption align="left"><font size="3">AINTEN
</font><br><p> <font size="2">
Offset: 0x154  EPWM Accumulator Interrupt Enable Register
</font></caption><thread><tr bgcolor="#8A0808" ><td><font color=white><b>Bits</b></font></td><td><font color=white><b>Field</b></font></td><td><font color=white><b>Descriptions</b></font></td></tr></thread><tbody>
<tr><td>
[0]</td><td>IFAIEN0</td><td><div style="word-wrap: break-word;"><b>EPWM_CHn Interrupt Flag Accumulator Interrupt Enable Bits
</b><br>
0 = Interrupt Flag accumulator interrupt Disabled.
<br>
1 = Interrupt Flag accumulator interrupt Enabled.
<br>
</div></td></tr><tr><td>
[1]</td><td>IFAIEN1</td><td><div style="word-wrap: break-word;"><b>EPWM_CHn Interrupt Flag Accumulator Interrupt Enable Bits
</b><br>
0 = Interrupt Flag accumulator interrupt Disabled.
<br>
1 = Interrupt Flag accumulator interrupt Enabled.
<br>
</div></td></tr><tr><td>
[2]</td><td>IFAIEN2</td><td><div style="word-wrap: break-word;"><b>EPWM_CHn Interrupt Flag Accumulator Interrupt Enable Bits
</b><br>
0 = Interrupt Flag accumulator interrupt Disabled.
<br>
1 = Interrupt Flag accumulator interrupt Enabled.
<br>
</div></td></tr><tr><td>
[3]</td><td>IFAIEN3</td><td><div style="word-wrap: break-word;"><b>EPWM_CHn Interrupt Flag Accumulator Interrupt Enable Bits
</b><br>
0 = Interrupt Flag accumulator interrupt Disabled.
<br>
1 = Interrupt Flag accumulator interrupt Enabled.
<br>
</div></td></tr><tr><td>
[4]</td><td>IFAIEN4</td><td><div style="word-wrap: break-word;"><b>EPWM_CHn Interrupt Flag Accumulator Interrupt Enable Bits
</b><br>
0 = Interrupt Flag accumulator interrupt Disabled.
<br>
1 = Interrupt Flag accumulator interrupt Enabled.
<br>
</div></td></tr><tr><td>
[5]</td><td>IFAIEN5</td><td><div style="word-wrap: break-word;"><b>EPWM_CHn Interrupt Flag Accumulator Interrupt Enable Bits
</b><br>
0 = Interrupt Flag accumulator interrupt Disabled.
<br>
1 = Interrupt Flag accumulator interrupt Enabled.
<br>
</div></td></tr></tbody></table></html>

 </p>

<p class="definition">Definition at line <a class="el" href="epwm__reg_8h_source.html#l04786">4786</a> of file <a class="el" href="epwm__reg_8h_source.html">epwm_reg.h</a>.</p>

</div>
</div>
<a id="af6179be82143fc604f67a9ceab457293" name="af6179be82143fc604f67a9ceab457293"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af6179be82143fc604f67a9ceab457293">&#9670;&nbsp;</a></span>AINTSTS</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">EPWM_T::AINTSTS</td>
        </tr>
      </table>
</div><div class="memdoc">
<p >[0x0150] EPWM Accumulator Interrupt Flag Register <br  />
</p>
<p > 

<html><table class="fixed" border="1" style="border-collapse:collapse;" borderColor=black ><col width="75px" /><col width="125px" /><col width="700px" /><caption align="left"><font size="3">AINTSTS
</font><br><p> <font size="2">
Offset: 0x150  EPWM Accumulator Interrupt Flag Register
</font></caption><thread><tr bgcolor="#8A0808" ><td><font color=white><b>Bits</b></font></td><td><font color=white><b>Field</b></font></td><td><font color=white><b>Descriptions</b></font></td></tr></thread><tbody>
<tr><td>
[0]</td><td>IFAIF0</td><td><div style="word-wrap: break-word;"><b>EPWM_CHn Interrupt Flag Accumulator Interrupt Flag
</b><br>
Flag is set by hardware when condition match IFASEL in EPWM_IFAn register, software can clear this bit by writing 1 to it.
<br>
</div></td></tr><tr><td>
[1]</td><td>IFAIF1</td><td><div style="word-wrap: break-word;"><b>EPWM_CHn Interrupt Flag Accumulator Interrupt Flag
</b><br>
Flag is set by hardware when condition match IFASEL in EPWM_IFAn register, software can clear this bit by writing 1 to it.
<br>
</div></td></tr><tr><td>
[2]</td><td>IFAIF2</td><td><div style="word-wrap: break-word;"><b>EPWM_CHn Interrupt Flag Accumulator Interrupt Flag
</b><br>
Flag is set by hardware when condition match IFASEL in EPWM_IFAn register, software can clear this bit by writing 1 to it.
<br>
</div></td></tr><tr><td>
[3]</td><td>IFAIF3</td><td><div style="word-wrap: break-word;"><b>EPWM_CHn Interrupt Flag Accumulator Interrupt Flag
</b><br>
Flag is set by hardware when condition match IFASEL in EPWM_IFAn register, software can clear this bit by writing 1 to it.
<br>
</div></td></tr><tr><td>
[4]</td><td>IFAIF4</td><td><div style="word-wrap: break-word;"><b>EPWM_CHn Interrupt Flag Accumulator Interrupt Flag
</b><br>
Flag is set by hardware when condition match IFASEL in EPWM_IFAn register, software can clear this bit by writing 1 to it.
<br>
</div></td></tr><tr><td>
[5]</td><td>IFAIF5</td><td><div style="word-wrap: break-word;"><b>EPWM_CHn Interrupt Flag Accumulator Interrupt Flag
</b><br>
Flag is set by hardware when condition match IFASEL in EPWM_IFAn register, software can clear this bit by writing 1 to it.
<br>
</div></td></tr></tbody></table></html>

 </p>

<p class="definition">Definition at line <a class="el" href="epwm__reg_8h_source.html#l04785">4785</a> of file <a class="el" href="epwm__reg_8h_source.html">epwm_reg.h</a>.</p>

</div>
</div>
<a id="a3de246f6adad207354bee8fa7c592604" name="a3de246f6adad207354bee8fa7c592604"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3de246f6adad207354bee8fa7c592604">&#9670;&nbsp;</a></span>APDMACTL</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">EPWM_T::APDMACTL</td>
        </tr>
      </table>
</div><div class="memdoc">
<p >[0x0158] EPWM Accumulator PDMA Control Register <br  />
</p>
<p > 

<html><table class="fixed" border="1" style="border-collapse:collapse;" borderColor=black ><col width="75px" /><col width="125px" /><col width="700px" /><caption align="left"><font size="3">APDMACTL
</font><br><p> <font size="2">
Offset: 0x158  EPWM Accumulator PDMA Control Register
</font></caption><thread><tr bgcolor="#8A0808" ><td><font color=white><b>Bits</b></font></td><td><font color=white><b>Field</b></font></td><td><font color=white><b>Descriptions</b></font></td></tr></thread><tbody>
<tr><td>
[0]</td><td>APDMAEN0</td><td><div style="word-wrap: break-word;"><b>Channel N Accumulator PDMA Enable Bits
</b><br>
0 = Channel n PDMA function Disabled.
<br>
1 = Channel n PDMA function Enabled for the channel n to trigger PDMA to transfer memory data to register.
<br>
</div></td></tr><tr><td>
[1]</td><td>APDMAEN1</td><td><div style="word-wrap: break-word;"><b>Channel N Accumulator PDMA Enable Bits
</b><br>
0 = Channel n PDMA function Disabled.
<br>
1 = Channel n PDMA function Enabled for the channel n to trigger PDMA to transfer memory data to register.
<br>
</div></td></tr><tr><td>
[2]</td><td>APDMAEN2</td><td><div style="word-wrap: break-word;"><b>Channel N Accumulator PDMA Enable Bits
</b><br>
0 = Channel n PDMA function Disabled.
<br>
1 = Channel n PDMA function Enabled for the channel n to trigger PDMA to transfer memory data to register.
<br>
</div></td></tr><tr><td>
[3]</td><td>APDMAEN3</td><td><div style="word-wrap: break-word;"><b>Channel N Accumulator PDMA Enable Bits
</b><br>
0 = Channel n PDMA function Disabled.
<br>
1 = Channel n PDMA function Enabled for the channel n to trigger PDMA to transfer memory data to register.
<br>
</div></td></tr><tr><td>
[4]</td><td>APDMAEN4</td><td><div style="word-wrap: break-word;"><b>Channel N Accumulator PDMA Enable Bits
</b><br>
0 = Channel n PDMA function Disabled.
<br>
1 = Channel n PDMA function Enabled for the channel n to trigger PDMA to transfer memory data to register.
<br>
</div></td></tr><tr><td>
[5]</td><td>APDMAEN5</td><td><div style="word-wrap: break-word;"><b>Channel N Accumulator PDMA Enable Bits
</b><br>
0 = Channel n PDMA function Disabled.
<br>
1 = Channel n PDMA function Enabled for the channel n to trigger PDMA to transfer memory data to register.
<br>
</div></td></tr></tbody></table></html>

 </p>

<p class="definition">Definition at line <a class="el" href="epwm__reg_8h_source.html#l04787">4787</a> of file <a class="el" href="epwm__reg_8h_source.html">epwm_reg.h</a>.</p>

</div>
</div>
<a id="a162fe20c6321426bc6a1b14e7cddf050" name="a162fe20c6321426bc6a1b14e7cddf050"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a162fe20c6321426bc6a1b14e7cddf050">&#9670;&nbsp;</a></span>BNF</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">EPWM_T::BNF</td>
        </tr>
      </table>
</div><div class="memdoc">
<p >[0x00c0] EPWM Brake Noise Filter Register <br  />
</p>
<p > 

<html><table class="fixed" border="1" style="border-collapse:collapse;" borderColor=black ><col width="75px" /><col width="125px" /><col width="700px" /><caption align="left"><font size="3">BNF
</font><br><p> <font size="2">
Offset: 0xC0  EPWM Brake Noise Filter Register
</font></caption><thread><tr bgcolor="#8A0808" ><td><font color=white><b>Bits</b></font></td><td><font color=white><b>Field</b></font></td><td><font color=white><b>Descriptions</b></font></td></tr></thread><tbody>
<tr><td>
[0]</td><td>BRK0NFEN</td><td><div style="word-wrap: break-word;"><b>EPWM Brake 0 Noise Filter Enable Bit
</b><br>
0 = Noise filter of EPWM Brake 0 Disabled.
<br>
1 = Noise filter of EPWM Brake 0 Enabled.
<br>
</div></td></tr><tr><td>
[3:1]</td><td>BRK0NFSEL</td><td><div style="word-wrap: break-word;"><b>Brake 0 Edge Detector Filter Clock Selection
</b><br>
000 = Filter clock = HCLK.
<br>
001 = Filter clock = HCLK/2.
<br>
010 = Filter clock = HCLK/4.
<br>
011 = Filter clock = HCLK/8.
<br>
100 = Filter clock = HCLK/16.
<br>
101 = Filter clock = HCLK/32.
<br>
110 = Filter clock = HCLK/64.
<br>
111 = Filter clock = HCLK/128.
<br>
</div></td></tr><tr><td>
[6:4]</td><td>BRK0FCNT</td><td><div style="word-wrap: break-word;"><b>Brake 0 Edge Detector Filter Count
</b><br>
The register bits control the Brake0 filter counter to count from 0 to BRK1FCNT.
<br>
</div></td></tr><tr><td>
[7]</td><td>BRK0PINV</td><td><div style="word-wrap: break-word;"><b>Brake 0 Pin Inverse
</b><br>
0 = The state of pin EPWMx_BRAKE0 is passed to the negative edge detector.
<br>
1 = The inversed state of pin EPWMx_BRAKE10 is passed to the negative edge detector.
<br>
</div></td></tr><tr><td>
[8]</td><td>BRK1NFEN</td><td><div style="word-wrap: break-word;"><b>EPWM Brake 1 Noise Filter Enable Bit
</b><br>
0 = Noise filter of EPWM Brake 1 Disabled.
<br>
1 = Noise filter of EPWM Brake 1 Enabled.
<br>
</div></td></tr><tr><td>
[11:9]</td><td>BRK1NFSEL</td><td><div style="word-wrap: break-word;"><b>Brake 1 Edge Detector Filter Clock Selection
</b><br>
000 = Filter clock = HCLK.
<br>
001 = Filter clock = HCLK/2.
<br>
010 = Filter clock = HCLK/4.
<br>
011 = Filter clock = HCLK/8.
<br>
100 = Filter clock = HCLK/16.
<br>
101 = Filter clock = HCLK/32.
<br>
110 = Filter clock = HCLK/64.
<br>
111 = Filter clock = HCLK/128.
<br>
</div></td></tr><tr><td>
[14:12]</td><td>BRK1FCNT</td><td><div style="word-wrap: break-word;"><b>Brake 1 Edge Detector Filter Count
</b><br>
The register bits control the Brake1 filter counter to count from 0 to BRK1FCNT.
<br>
</div></td></tr><tr><td>
[15]</td><td>BRK1PINV</td><td><div style="word-wrap: break-word;"><b>Brake 1 Pin Inverse
</b><br>
0 = The state of pin EPWMx_BRAKE1 is passed to the negative edge detector.
<br>
1 = The inversed state of pin EPWMx_BRAKE1 is passed to the negative edge detector.
<br>
</div></td></tr><tr><td>
[16]</td><td>BK0SRC</td><td><div style="word-wrap: break-word;"><b>Brake 0 Pin Source Select
</b><br>
For EPWM0 setting:
<br>
0 = Brake 0 pin source come from EPWM0_BRAKE0.
<br>
1 = Brake 0 pin source come from EPWM1_BRAKE0.
<br>
For EPWM1 setting:
<br>
0 = Brake 0 pin source come from EPWM1_BRAKE0.
<br>
1 = Brake 0 pin source come from EPWM0_BRAKE0.
<br>
</div></td></tr><tr><td>
[24]</td><td>BK1SRC</td><td><div style="word-wrap: break-word;"><b>Brake 1 Pin Source Select
</b><br>
For EPWM0 setting:
<br>
0 = Brake 1 pin source come from EPWM0_BRAKE1.
<br>
1 = Brake 1 pin source come from EPWM1_BRAKE1.
<br>
For EPWM1 setting:
<br>
0 = Brake 1 pin source come from EPWM1_BRAKE1.
<br>
1 = Brake 1 pin source come from EPWM0_BRAKE1.
<br>
</div></td></tr></tbody></table></html>

 </p>

<p class="definition">Definition at line <a class="el" href="epwm__reg_8h_source.html#l04753">4753</a> of file <a class="el" href="epwm__reg_8h_source.html">epwm_reg.h</a>.</p>

</div>
</div>
<a id="a5537551059205d37c741d6771d251f9f" name="a5537551059205d37c741d6771d251f9f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5537551059205d37c741d6771d251f9f">&#9670;&nbsp;</a></span>BRKCTL</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">EPWM_T::BRKCTL[3]</td>
        </tr>
      </table>
</div><div class="memdoc">
<p >[0x00c8] EPWM Brake Edge Detect Control Register 0/1,2/3,4/5 <br  />
</p>
<p > 

<html><table class="fixed" border="1" style="border-collapse:collapse;" borderColor=black ><col width="75px" /><col width="125px" /><col width="700px" /><caption align="left"><font size="3">BRKCTL[3]
</font><br><p> <font size="2">
Offset: 0xC8  EPWM Brake Edge Detect Control Register 0/1,2/3,4/5
</font></caption><thread><tr bgcolor="#8A0808" ><td><font color=white><b>Bits</b></font></td><td><font color=white><b>Field</b></font></td><td><font color=white><b>Descriptions</b></font></td></tr></thread><tbody>
<tr><td>
[0]</td><td>CPO0EBEN</td><td><div style="word-wrap: break-word;"><b>Enable ACMP0_O Digital Output As Edge-detect Brake Source (Write Protect)
</b><br>
0 = ACMP0_O as edge-detect brake source Disabled.
<br>
1 = ACMP0_O as edge-detect brake source Enabled.
<br>
Note: This register is write protected. Refer toSYS_REGLCTL register.
<br>
</div></td></tr><tr><td>
[1]</td><td>CPO1EBEN</td><td><div style="word-wrap: break-word;"><b>Enable ACMP1_O Digital Output As Edge-detect Brake Source (Write Protect)
</b><br>
0 = ACMP1_O as edge-detect brake source Disabled.
<br>
1 = ACMP1_O as edge-detect brake source Enabled.
<br>
Note: This register is write protected. Refer toSYS_REGLCTL register.
<br>
</div></td></tr><tr><td>
[4]</td><td>BRKP0EEN</td><td><div style="word-wrap: break-word;"><b>Enable EPWMx_BRAKE0 Pin As Edge-detect Brake Source (Write Protect)
</b><br>
0 = EPWMx_BRAKE0 pin as edge-detect brake source Disabled.
<br>
1 = EPWMx_BRAKE0 pin as edge-detect brake source Enabled.
<br>
Note: This register is write protected. Refer toSYS_REGLCTL register.
<br>
</div></td></tr><tr><td>
[5]</td><td>BRKP1EEN</td><td><div style="word-wrap: break-word;"><b>Enable EPWMx_BRAKE1 Pin As Edge-detect Brake Source (Write Protect)
</b><br>
0 = EPWMx_BRAKE1 pin as edge-detect brake source Disabled.
<br>
1 = EPWMx_BRAKE1 pin as edge-detect brake source Enabled.
<br>
Note: This register is write protected. Refer toSYS_REGLCTL register.
<br>
</div></td></tr><tr><td>
[7]</td><td>SYSEBEN</td><td><div style="word-wrap: break-word;"><b>Enable System Fail As Edge-detect Brake Source (Write Protect)
</b><br>
0 = System Fail condition as edge-detect brake source Disabled.
<br>
1 = System Fail condition as edge-detect brake source Enabled.
<br>
Note: This register is write protected. Refer toSYS_REGLCTL register.
<br>
</div></td></tr><tr><td>
[8]</td><td>CPO0LBEN</td><td><div style="word-wrap: break-word;"><b>Enable ACMP0_O Digital Output As Level-detect Brake Source (Write Protect)
</b><br>
0 = ACMP0_O as level-detect brake source Disabled.
<br>
1 = ACMP0_O as level-detect brake source Enabled.
<br>
Note: This register is write protected. Refer toSYS_REGLCTL register.
<br>
</div></td></tr><tr><td>
[9]</td><td>CPO1LBEN</td><td><div style="word-wrap: break-word;"><b>Enable ACMP1_O Digital Output As Level-detect Brake Source (Write Protect)
</b><br>
0 = ACMP1_O as level-detect brake source Disabled.
<br>
1 = ACMP1_O as level-detect brake source Enabled.
<br>
Note: This register is write protected. Refer toSYS_REGLCTL register.
<br>
</div></td></tr><tr><td>
[12]</td><td>BRKP0LEN</td><td><div style="word-wrap: break-word;"><b>Enable BKP0 Pin As Level-detect Brake Source (Write Protect)
</b><br>
0 = EPWMx_BRAKE0 pin as level-detect brake source Disabled.
<br>
1 = EPWMx_BRAKE0 pin as level-detect brake source Enabled.
<br>
Note: This register is write protected. Refer toSYS_REGLCTL register.
<br>
</div></td></tr><tr><td>
[13]</td><td>BRKP1LEN</td><td><div style="word-wrap: break-word;"><b>Enable BKP1 Pin As Level-detect Brake Source (Write Protect)
</b><br>
0 = EPWMx_BRAKE1 pin as level-detect brake source Disabled.
<br>
1 = EPWMx_BRAKE1 pin as level-detect brake source Enabled.
<br>
Note: This register is write protected. Refer toSYS_REGLCTL register.
<br>
</div></td></tr><tr><td>
[15]</td><td>SYSLBEN</td><td><div style="word-wrap: break-word;"><b>Enable System Fail As Level-detect Brake Source (Write Protect)
</b><br>
0 = System Fail condition as level-detect brake source Disabled.
<br>
1 = System Fail condition as level-detect brake source Enabled.
<br>
Note: This register is write protected. Refer toSYS_REGLCTL register.
<br>
</div></td></tr><tr><td>
[17:16]</td><td>BRKAEVEN</td><td><div style="word-wrap: break-word;"><b>EPWM Brake Action Select for Even Channel (Write Protect)
</b><br>
00 = EPWMx brake event will not affect even channels output.
<br>
01 = EPWM even channel output tri-state when EPWMx brake event happened.
<br>
10 = EPWM even channel output low level when EPWMx brake event happened.
<br>
11 = EPWM even channel output high level when EPWMx brake event happened.
<br>
Note: This register is write protected. Refer toSYS_REGLCTL register.
<br>
</div></td></tr><tr><td>
[19:18]</td><td>BRKAODD</td><td><div style="word-wrap: break-word;"><b>EPWM Brake Action Select for Odd Channel (Write Protect)
</b><br>
00 = EPWMx brake event will not affect odd channels output.
<br>
01 = EPWM odd channel output tri-state when EPWMx brake event happened.
<br>
10 = EPWM odd channel output low level when EPWMx brake event happened.
<br>
11 = EPWM odd channel output high level when EPWMx brake event happened.
<br>
Note: This register is write protected. Refer toSYS_REGLCTL register.
<br>
</div></td></tr><tr><td>
[20]</td><td>EADCEBEN</td><td><div style="word-wrap: break-word;"><b>Enable EADC Result Monitor (EADCRM) As Edge-detect Brake Source (Write Protect)
</b><br>
0 = EADCRM as edge-detect brake source Disabled.
<br>
1 = EADCRM as edge-detect brake source Enabled.
<br>
Note: This register is write protected. Refer toSYS_REGLCTL register.
<br>
</div></td></tr><tr><td>
[28]</td><td>EADCLBEN</td><td><div style="word-wrap: break-word;"><b>Enable EADC Result Monitor (EADCRM) As Level-detect Brake Source (Write Protect)
</b><br>
0 = EADCRM as level-detect brake source Disabled.
<br>
1 = EADCRM as level-detect brake source Enabled.
<br>
Note: This register is write protected. Refer toSYS_REGLCTL register.
<br>
</div></td></tr></tbody></table></html>

 </p>

<p class="definition">Definition at line <a class="el" href="epwm__reg_8h_source.html#l04755">4755</a> of file <a class="el" href="epwm__reg_8h_source.html">epwm_reg.h</a>.</p>

</div>
</div>
<a id="a0ecb00063ff8028504c0bf1e86495fef" name="a0ecb00063ff8028504c0bf1e86495fef"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0ecb00063ff8028504c0bf1e86495fef">&#9670;&nbsp;</a></span>CAPCTL</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">EPWM_T::CAPCTL</td>
        </tr>
      </table>
</div><div class="memdoc">
<p >[0x0204] EPWM Capture Control Register <br  />
</p>
<p > 

<html><table class="fixed" border="1" style="border-collapse:collapse;" borderColor=black ><col width="75px" /><col width="125px" /><col width="700px" /><caption align="left"><font size="3">CAPCTL
</font><br><p> <font size="2">
Offset: 0x204  EPWM Capture Control Register
</font></caption><thread><tr bgcolor="#8A0808" ><td><font color=white><b>Bits</b></font></td><td><font color=white><b>Field</b></font></td><td><font color=white><b>Descriptions</b></font></td></tr></thread><tbody>
<tr><td>
[0]</td><td>CAPEN0</td><td><div style="word-wrap: break-word;"><b>Capture Function Enable Bits
</b><br>
0 = Capture function Disabled. RCAPDAT/FCAPDAT register will not be updated.
<br>
1 = Capture function Enabled
<br>
Capture latched the EPWM counter value when detected rising or falling edge of input signal and saved to RCAPDAT (Rising latch) and FCAPDAT (Falling latch).
<br>
</div></td></tr><tr><td>
[1]</td><td>CAPEN1</td><td><div style="word-wrap: break-word;"><b>Capture Function Enable Bits
</b><br>
0 = Capture function Disabled. RCAPDAT/FCAPDAT register will not be updated.
<br>
1 = Capture function Enabled
<br>
Capture latched the EPWM counter value when detected rising or falling edge of input signal and saved to RCAPDAT (Rising latch) and FCAPDAT (Falling latch).
<br>
</div></td></tr><tr><td>
[2]</td><td>CAPEN2</td><td><div style="word-wrap: break-word;"><b>Capture Function Enable Bits
</b><br>
0 = Capture function Disabled. RCAPDAT/FCAPDAT register will not be updated.
<br>
1 = Capture function Enabled
<br>
Capture latched the EPWM counter value when detected rising or falling edge of input signal and saved to RCAPDAT (Rising latch) and FCAPDAT (Falling latch).
<br>
</div></td></tr><tr><td>
[3]</td><td>CAPEN3</td><td><div style="word-wrap: break-word;"><b>Capture Function Enable Bits
</b><br>
0 = Capture function Disabled. RCAPDAT/FCAPDAT register will not be updated.
<br>
1 = Capture function Enabled
<br>
Capture latched the EPWM counter value when detected rising or falling edge of input signal and saved to RCAPDAT (Rising latch) and FCAPDAT (Falling latch).
<br>
</div></td></tr><tr><td>
[4]</td><td>CAPEN4</td><td><div style="word-wrap: break-word;"><b>Capture Function Enable Bits
</b><br>
0 = Capture function Disabled. RCAPDAT/FCAPDAT register will not be updated.
<br>
1 = Capture function Enabled
<br>
Capture latched the EPWM counter value when detected rising or falling edge of input signal and saved to RCAPDAT (Rising latch) and FCAPDAT (Falling latch).
<br>
</div></td></tr><tr><td>
[5]</td><td>CAPEN5</td><td><div style="word-wrap: break-word;"><b>Capture Function Enable Bits
</b><br>
0 = Capture function Disabled. RCAPDAT/FCAPDAT register will not be updated.
<br>
1 = Capture function Enabled
<br>
Capture latched the EPWM counter value when detected rising or falling edge of input signal and saved to RCAPDAT (Rising latch) and FCAPDAT (Falling latch).
<br>
</div></td></tr><tr><td>
[8]</td><td>CAPINV0</td><td><div style="word-wrap: break-word;"><b>Capture Inverter Enable Bits
</b><br>
0 = Capture source inverter Disabled.
<br>
1 = Capture source inverter Enabled. Reverse the input signal from GPIO.
<br>
</div></td></tr><tr><td>
[9]</td><td>CAPINV1</td><td><div style="word-wrap: break-word;"><b>Capture Inverter Enable Bits
</b><br>
0 = Capture source inverter Disabled.
<br>
1 = Capture source inverter Enabled. Reverse the input signal from GPIO.
<br>
</div></td></tr><tr><td>
[10]</td><td>CAPINV2</td><td><div style="word-wrap: break-word;"><b>Capture Inverter Enable Bits
</b><br>
0 = Capture source inverter Disabled.
<br>
1 = Capture source inverter Enabled. Reverse the input signal from GPIO.
<br>
</div></td></tr><tr><td>
[11]</td><td>CAPINV3</td><td><div style="word-wrap: break-word;"><b>Capture Inverter Enable Bits
</b><br>
0 = Capture source inverter Disabled.
<br>
1 = Capture source inverter Enabled. Reverse the input signal from GPIO.
<br>
</div></td></tr><tr><td>
[12]</td><td>CAPINV4</td><td><div style="word-wrap: break-word;"><b>Capture Inverter Enable Bits
</b><br>
0 = Capture source inverter Disabled.
<br>
1 = Capture source inverter Enabled. Reverse the input signal from GPIO.
<br>
</div></td></tr><tr><td>
[13]</td><td>CAPINV5</td><td><div style="word-wrap: break-word;"><b>Capture Inverter Enable Bits
</b><br>
0 = Capture source inverter Disabled.
<br>
1 = Capture source inverter Enabled. Reverse the input signal from GPIO.
<br>
</div></td></tr><tr><td>
[16]</td><td>RCRLDEN0</td><td><div style="word-wrap: break-word;"><b>Rising Capture Reload Enable Bits
</b><br>
0 = Rising capture reload counter Disabled.
<br>
1 = Rising capture reload counter Enabled.
<br>
</div></td></tr><tr><td>
[17]</td><td>RCRLDEN1</td><td><div style="word-wrap: break-word;"><b>Rising Capture Reload Enable Bits
</b><br>
0 = Rising capture reload counter Disabled.
<br>
1 = Rising capture reload counter Enabled.
<br>
</div></td></tr><tr><td>
[18]</td><td>RCRLDEN2</td><td><div style="word-wrap: break-word;"><b>Rising Capture Reload Enable Bits
</b><br>
0 = Rising capture reload counter Disabled.
<br>
1 = Rising capture reload counter Enabled.
<br>
</div></td></tr><tr><td>
[19]</td><td>RCRLDEN3</td><td><div style="word-wrap: break-word;"><b>Rising Capture Reload Enable Bits
</b><br>
0 = Rising capture reload counter Disabled.
<br>
1 = Rising capture reload counter Enabled.
<br>
</div></td></tr><tr><td>
[20]</td><td>RCRLDEN4</td><td><div style="word-wrap: break-word;"><b>Rising Capture Reload Enable Bits
</b><br>
0 = Rising capture reload counter Disabled.
<br>
1 = Rising capture reload counter Enabled.
<br>
</div></td></tr><tr><td>
[21]</td><td>RCRLDEN5</td><td><div style="word-wrap: break-word;"><b>Rising Capture Reload Enable Bits
</b><br>
0 = Rising capture reload counter Disabled.
<br>
1 = Rising capture reload counter Enabled.
<br>
</div></td></tr><tr><td>
[24]</td><td>FCRLDEN0</td><td><div style="word-wrap: break-word;"><b>Falling Capture Reload Enable Bits
</b><br>
0 = Falling capture reload counter Disabled.
<br>
1 = Falling capture reload counter Enabled.
<br>
</div></td></tr><tr><td>
[25]</td><td>FCRLDEN1</td><td><div style="word-wrap: break-word;"><b>Falling Capture Reload Enable Bits
</b><br>
0 = Falling capture reload counter Disabled.
<br>
1 = Falling capture reload counter Enabled.
<br>
</div></td></tr><tr><td>
[26]</td><td>FCRLDEN2</td><td><div style="word-wrap: break-word;"><b>Falling Capture Reload Enable Bits
</b><br>
0 = Falling capture reload counter Disabled.
<br>
1 = Falling capture reload counter Enabled.
<br>
</div></td></tr><tr><td>
[27]</td><td>FCRLDEN3</td><td><div style="word-wrap: break-word;"><b>Falling Capture Reload Enable Bits
</b><br>
0 = Falling capture reload counter Disabled.
<br>
1 = Falling capture reload counter Enabled.
<br>
</div></td></tr><tr><td>
[28]</td><td>FCRLDEN4</td><td><div style="word-wrap: break-word;"><b>Falling Capture Reload Enable Bits
</b><br>
0 = Falling capture reload counter Disabled.
<br>
1 = Falling capture reload counter Enabled.
<br>
</div></td></tr><tr><td>
[29]</td><td>FCRLDEN5</td><td><div style="word-wrap: break-word;"><b>Falling Capture Reload Enable Bits
</b><br>
0 = Falling capture reload counter Disabled.
<br>
1 = Falling capture reload counter Enabled.
<br>
</div></td></tr></tbody></table></html>

 </p>

<p class="definition">Definition at line <a class="el" href="epwm__reg_8h_source.html#l04804">4804</a> of file <a class="el" href="epwm__reg_8h_source.html">epwm_reg.h</a>.</p>

</div>
</div>
<a id="a4dc2516ee1fee3cb749c68bac0211790" name="a4dc2516ee1fee3cb749c68bac0211790"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4dc2516ee1fee3cb749c68bac0211790">&#9670;&nbsp;</a></span>CAPDAT</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_e_c_a_p_d_a_t___t.html">ECAPDAT_T</a> EPWM_T::CAPDAT[6]</td>
        </tr>
      </table>
</div><div class="memdoc">
<p >[0x020C] EPWM Rising and Falling Capture Data Register 0~5 <br  />
 </p>

<p class="definition">Definition at line <a class="el" href="epwm__reg_8h_source.html#l04806">4806</a> of file <a class="el" href="epwm__reg_8h_source.html">epwm_reg.h</a>.</p>

</div>
</div>
<a id="aa2e9b43fe93524b9fd6a0d263fb023bc" name="aa2e9b43fe93524b9fd6a0d263fb023bc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa2e9b43fe93524b9fd6a0d263fb023bc">&#9670;&nbsp;</a></span>CAPIEN</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">EPWM_T::CAPIEN</td>
        </tr>
      </table>
</div><div class="memdoc">
<p >[0x0250] EPWM Capture Interrupt Enable Register <br  />
</p>
<p > 

<html><table class="fixed" border="1" style="border-collapse:collapse;" borderColor=black ><col width="75px" /><col width="125px" /><col width="700px" /><caption align="left"><font size="3">CAPIEN
</font><br><p> <font size="2">
Offset: 0x250  EPWM Capture Interrupt Enable Register
</font></caption><thread><tr bgcolor="#8A0808" ><td><font color=white><b>Bits</b></font></td><td><font color=white><b>Field</b></font></td><td><font color=white><b>Descriptions</b></font></td></tr></thread><tbody>
<tr><td>
[0]</td><td>CAPRIEN0</td><td><div style="word-wrap: break-word;"><b>EPWM Capture Rising Latch Interrupt Enable Bits
</b><br>
0 = Capture rising edge latch interrupt Disabled.
<br>
1 = Capture rising edge latch interrupt Enabled.
<br>
</div></td></tr><tr><td>
[1]</td><td>CAPRIEN1</td><td><div style="word-wrap: break-word;"><b>EPWM Capture Rising Latch Interrupt Enable Bits
</b><br>
0 = Capture rising edge latch interrupt Disabled.
<br>
1 = Capture rising edge latch interrupt Enabled.
<br>
</div></td></tr><tr><td>
[2]</td><td>CAPRIEN2</td><td><div style="word-wrap: break-word;"><b>EPWM Capture Rising Latch Interrupt Enable Bits
</b><br>
0 = Capture rising edge latch interrupt Disabled.
<br>
1 = Capture rising edge latch interrupt Enabled.
<br>
</div></td></tr><tr><td>
[3]</td><td>CAPRIEN3</td><td><div style="word-wrap: break-word;"><b>EPWM Capture Rising Latch Interrupt Enable Bits
</b><br>
0 = Capture rising edge latch interrupt Disabled.
<br>
1 = Capture rising edge latch interrupt Enabled.
<br>
</div></td></tr><tr><td>
[4]</td><td>CAPRIEN4</td><td><div style="word-wrap: break-word;"><b>EPWM Capture Rising Latch Interrupt Enable Bits
</b><br>
0 = Capture rising edge latch interrupt Disabled.
<br>
1 = Capture rising edge latch interrupt Enabled.
<br>
</div></td></tr><tr><td>
[5]</td><td>CAPRIEN5</td><td><div style="word-wrap: break-word;"><b>EPWM Capture Rising Latch Interrupt Enable Bits
</b><br>
0 = Capture rising edge latch interrupt Disabled.
<br>
1 = Capture rising edge latch interrupt Enabled.
<br>
</div></td></tr><tr><td>
[8]</td><td>CAPFIEN0</td><td><div style="word-wrap: break-word;"><b>EPWM Capture Falling Latch Interrupt Enable Bits
</b><br>
0 = Capture falling edge latch interrupt Disabled.
<br>
1 = Capture falling edge latch interrupt Enabled.
<br>
</div></td></tr><tr><td>
[9]</td><td>CAPFIEN1</td><td><div style="word-wrap: break-word;"><b>EPWM Capture Falling Latch Interrupt Enable Bits
</b><br>
0 = Capture falling edge latch interrupt Disabled.
<br>
1 = Capture falling edge latch interrupt Enabled.
<br>
</div></td></tr><tr><td>
[10]</td><td>CAPFIEN2</td><td><div style="word-wrap: break-word;"><b>EPWM Capture Falling Latch Interrupt Enable Bits
</b><br>
0 = Capture falling edge latch interrupt Disabled.
<br>
1 = Capture falling edge latch interrupt Enabled.
<br>
</div></td></tr><tr><td>
[11]</td><td>CAPFIEN3</td><td><div style="word-wrap: break-word;"><b>EPWM Capture Falling Latch Interrupt Enable Bits
</b><br>
0 = Capture falling edge latch interrupt Disabled.
<br>
1 = Capture falling edge latch interrupt Enabled.
<br>
</div></td></tr><tr><td>
[12]</td><td>CAPFIEN4</td><td><div style="word-wrap: break-word;"><b>EPWM Capture Falling Latch Interrupt Enable Bits
</b><br>
0 = Capture falling edge latch interrupt Disabled.
<br>
1 = Capture falling edge latch interrupt Enabled.
<br>
</div></td></tr><tr><td>
[13]</td><td>CAPFIEN5</td><td><div style="word-wrap: break-word;"><b>EPWM Capture Falling Latch Interrupt Enable Bits
</b><br>
0 = Capture falling edge latch interrupt Disabled.
<br>
1 = Capture falling edge latch interrupt Enabled.
<br>
</div></td></tr></tbody></table></html>

 </p>

<p class="definition">Definition at line <a class="el" href="epwm__reg_8h_source.html#l04812">4812</a> of file <a class="el" href="epwm__reg_8h_source.html">epwm_reg.h</a>.</p>

</div>
</div>
<a id="ae94af34fab3038bb96ea977115cf0a73" name="ae94af34fab3038bb96ea977115cf0a73"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae94af34fab3038bb96ea977115cf0a73">&#9670;&nbsp;</a></span>CAPIF</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">EPWM_T::CAPIF</td>
        </tr>
      </table>
</div><div class="memdoc">
<p >[0x0254] EPWM Capture Interrupt Flag Register <br  />
</p>
<p > 

<html><table class="fixed" border="1" style="border-collapse:collapse;" borderColor=black ><col width="75px" /><col width="125px" /><col width="700px" /><caption align="left"><font size="3">CAPIF
</font><br><p> <font size="2">
Offset: 0x254  EPWM Capture Interrupt Flag Register
</font></caption><thread><tr bgcolor="#8A0808" ><td><font color=white><b>Bits</b></font></td><td><font color=white><b>Field</b></font></td><td><font color=white><b>Descriptions</b></font></td></tr></thread><tbody>
<tr><td>
[0]</td><td>CRLIF0</td><td><div style="word-wrap: break-word;"><b>EPWM Capture Rising Latch Interrupt Flag
</b><br>
This bit is writing 1 to clear.
<br>
0 = No capture rising latch condition happened.
<br>
1 = Capture rising latch condition happened, this flag will be set to high.
<br>
Note: When Capture with PDMA operating, CAPIF corresponding channel CRLIF will cleared by hardware after PDMA transfer data.
<br>
</div></td></tr><tr><td>
[1]</td><td>CRLIF1</td><td><div style="word-wrap: break-word;"><b>EPWM Capture Rising Latch Interrupt Flag
</b><br>
This bit is writing 1 to clear.
<br>
0 = No capture rising latch condition happened.
<br>
1 = Capture rising latch condition happened, this flag will be set to high.
<br>
Note: When Capture with PDMA operating, CAPIF corresponding channel CRLIF will cleared by hardware after PDMA transfer data.
<br>
</div></td></tr><tr><td>
[2]</td><td>CRLIF2</td><td><div style="word-wrap: break-word;"><b>EPWM Capture Rising Latch Interrupt Flag
</b><br>
This bit is writing 1 to clear.
<br>
0 = No capture rising latch condition happened.
<br>
1 = Capture rising latch condition happened, this flag will be set to high.
<br>
Note: When Capture with PDMA operating, CAPIF corresponding channel CRLIF will cleared by hardware after PDMA transfer data.
<br>
</div></td></tr><tr><td>
[3]</td><td>CRLIF3</td><td><div style="word-wrap: break-word;"><b>EPWM Capture Rising Latch Interrupt Flag
</b><br>
This bit is writing 1 to clear.
<br>
0 = No capture rising latch condition happened.
<br>
1 = Capture rising latch condition happened, this flag will be set to high.
<br>
Note: When Capture with PDMA operating, CAPIF corresponding channel CRLIF will cleared by hardware after PDMA transfer data.
<br>
</div></td></tr><tr><td>
[4]</td><td>CRLIF4</td><td><div style="word-wrap: break-word;"><b>EPWM Capture Rising Latch Interrupt Flag
</b><br>
This bit is writing 1 to clear.
<br>
0 = No capture rising latch condition happened.
<br>
1 = Capture rising latch condition happened, this flag will be set to high.
<br>
Note: When Capture with PDMA operating, CAPIF corresponding channel CRLIF will cleared by hardware after PDMA transfer data.
<br>
</div></td></tr><tr><td>
[5]</td><td>CRLIF5</td><td><div style="word-wrap: break-word;"><b>EPWM Capture Rising Latch Interrupt Flag
</b><br>
This bit is writing 1 to clear.
<br>
0 = No capture rising latch condition happened.
<br>
1 = Capture rising latch condition happened, this flag will be set to high.
<br>
Note: When Capture with PDMA operating, CAPIF corresponding channel CRLIF will cleared by hardware after PDMA transfer data.
<br>
</div></td></tr><tr><td>
[8]</td><td>CFLIF0</td><td><div style="word-wrap: break-word;"><b>EPWM Capture Falling Latch Interrupt Flag
</b><br>
This bit is writing 1 to clear.
<br>
0 = No capture falling latch condition happened.
<br>
1 = Capture falling latch condition happened, this flag will be set to high.
<br>
Note: When Capture with PDMA operating, CAPIF corresponding channel CFLIF will cleared by hardware after PDMA transfer data.
<br>
</div></td></tr><tr><td>
[9]</td><td>CFLIF1</td><td><div style="word-wrap: break-word;"><b>EPWM Capture Falling Latch Interrupt Flag
</b><br>
This bit is writing 1 to clear.
<br>
0 = No capture falling latch condition happened.
<br>
1 = Capture falling latch condition happened, this flag will be set to high.
<br>
Note: When Capture with PDMA operating, CAPIF corresponding channel CFLIF will cleared by hardware after PDMA transfer data.
<br>
</div></td></tr><tr><td>
[10]</td><td>CFLIF2</td><td><div style="word-wrap: break-word;"><b>EPWM Capture Falling Latch Interrupt Flag
</b><br>
This bit is writing 1 to clear.
<br>
0 = No capture falling latch condition happened.
<br>
1 = Capture falling latch condition happened, this flag will be set to high.
<br>
Note: When Capture with PDMA operating, CAPIF corresponding channel CFLIF will cleared by hardware after PDMA transfer data.
<br>
</div></td></tr><tr><td>
[11]</td><td>CFLIF3</td><td><div style="word-wrap: break-word;"><b>EPWM Capture Falling Latch Interrupt Flag
</b><br>
This bit is writing 1 to clear.
<br>
0 = No capture falling latch condition happened.
<br>
1 = Capture falling latch condition happened, this flag will be set to high.
<br>
Note: When Capture with PDMA operating, CAPIF corresponding channel CFLIF will cleared by hardware after PDMA transfer data.
<br>
</div></td></tr><tr><td>
[12]</td><td>CFLIF4</td><td><div style="word-wrap: break-word;"><b>EPWM Capture Falling Latch Interrupt Flag
</b><br>
This bit is writing 1 to clear.
<br>
0 = No capture falling latch condition happened.
<br>
1 = Capture falling latch condition happened, this flag will be set to high.
<br>
Note: When Capture with PDMA operating, CAPIF corresponding channel CFLIF will cleared by hardware after PDMA transfer data.
<br>
</div></td></tr><tr><td>
[13]</td><td>CFLIF5</td><td><div style="word-wrap: break-word;"><b>EPWM Capture Falling Latch Interrupt Flag
</b><br>
This bit is writing 1 to clear.
<br>
0 = No capture falling latch condition happened.
<br>
1 = Capture falling latch condition happened, this flag will be set to high.
<br>
Note: When Capture with PDMA operating, CAPIF corresponding channel CFLIF will cleared by hardware after PDMA transfer data.
<br>
</div></td></tr></tbody></table></html>

 </p>

<p class="definition">Definition at line <a class="el" href="epwm__reg_8h_source.html#l04813">4813</a> of file <a class="el" href="epwm__reg_8h_source.html">epwm_reg.h</a>.</p>

</div>
</div>
<a id="aa7bac642d662381258fbc23433597421" name="aa7bac642d662381258fbc23433597421"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa7bac642d662381258fbc23433597421">&#9670;&nbsp;</a></span>CAPINEN</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">EPWM_T::CAPINEN</td>
        </tr>
      </table>
</div><div class="memdoc">
<p >[0x0200] EPWM Capture Input Enable Register <br  />
</p>
<p > 

<html><table class="fixed" border="1" style="border-collapse:collapse;" borderColor=black ><col width="75px" /><col width="125px" /><col width="700px" /><caption align="left"><font size="3">CAPINEN
</font><br><p> <font size="2">
Offset: 0x200  EPWM Capture Input Enable Register
</font></caption><thread><tr bgcolor="#8A0808" ><td><font color=white><b>Bits</b></font></td><td><font color=white><b>Field</b></font></td><td><font color=white><b>Descriptions</b></font></td></tr></thread><tbody>
<tr><td>
[0]</td><td>CAPINEN0</td><td><div style="word-wrap: break-word;"><b>Capture Input Enable Bits
</b><br>
0 = EPWM Channel capture input path Disabled
<br>
The input of EPWM channel capture function is always regarded as 0.
<br>
1 = EPWM Channel capture input path Enabled
<br>
The input of EPWM channel capture function comes from correlative multifunction pin.
<br>
</div></td></tr><tr><td>
[1]</td><td>CAPINEN1</td><td><div style="word-wrap: break-word;"><b>Capture Input Enable Bits
</b><br>
0 = EPWM Channel capture input path Disabled
<br>
The input of EPWM channel capture function is always regarded as 0.
<br>
1 = EPWM Channel capture input path Enabled
<br>
The input of EPWM channel capture function comes from correlative multifunction pin.
<br>
</div></td></tr><tr><td>
[2]</td><td>CAPINEN2</td><td><div style="word-wrap: break-word;"><b>Capture Input Enable Bits
</b><br>
0 = EPWM Channel capture input path Disabled
<br>
The input of EPWM channel capture function is always regarded as 0.
<br>
1 = EPWM Channel capture input path Enabled
<br>
The input of EPWM channel capture function comes from correlative multifunction pin.
<br>
</div></td></tr><tr><td>
[3]</td><td>CAPINEN3</td><td><div style="word-wrap: break-word;"><b>Capture Input Enable Bits
</b><br>
0 = EPWM Channel capture input path Disabled
<br>
The input of EPWM channel capture function is always regarded as 0.
<br>
1 = EPWM Channel capture input path Enabled
<br>
The input of EPWM channel capture function comes from correlative multifunction pin.
<br>
</div></td></tr><tr><td>
[4]</td><td>CAPINEN4</td><td><div style="word-wrap: break-word;"><b>Capture Input Enable Bits
</b><br>
0 = EPWM Channel capture input path Disabled
<br>
The input of EPWM channel capture function is always regarded as 0.
<br>
1 = EPWM Channel capture input path Enabled
<br>
The input of EPWM channel capture function comes from correlative multifunction pin.
<br>
</div></td></tr><tr><td>
[5]</td><td>CAPINEN5</td><td><div style="word-wrap: break-word;"><b>Capture Input Enable Bits
</b><br>
0 = EPWM Channel capture input path Disabled
<br>
The input of EPWM channel capture function is always regarded as 0.
<br>
1 = EPWM Channel capture input path Enabled
<br>
The input of EPWM channel capture function comes from correlative multifunction pin.
<br>
</div></td></tr></tbody></table></html>

 </p>

<p class="definition">Definition at line <a class="el" href="epwm__reg_8h_source.html#l04803">4803</a> of file <a class="el" href="epwm__reg_8h_source.html">epwm_reg.h</a>.</p>

</div>
</div>
<a id="ac931bb118f7dc1f5333654890725e5b9" name="ac931bb118f7dc1f5333654890725e5b9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac931bb118f7dc1f5333654890725e5b9">&#9670;&nbsp;</a></span>CAPSTS</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">EPWM_T::CAPSTS</td>
        </tr>
      </table>
</div><div class="memdoc">
<p >[0x0208] EPWM Capture Status Register <br  />
</p>
<p > 

<html><table class="fixed" border="1" style="border-collapse:collapse;" borderColor=black ><col width="75px" /><col width="125px" /><col width="700px" /><caption align="left"><font size="3">CAPSTS
</font><br><p> <font size="2">
Offset: 0x208  EPWM Capture Status Register
</font></caption><thread><tr bgcolor="#8A0808" ><td><font color=white><b>Bits</b></font></td><td><font color=white><b>Field</b></font></td><td><font color=white><b>Descriptions</b></font></td></tr></thread><tbody>
<tr><td>
[0]</td><td>CRLIFOV0</td><td><div style="word-wrap: break-word;"><b>Capture Rising Latch Interrupt Flag Overrun Status (Read Only)
</b><br>
This flag indicates if rising latch happened when the corresponding CRLIF is 1.
<br>
Note: This bit will be cleared automatically when user clear corresponding CRLIF.
<br>
</div></td></tr><tr><td>
[1]</td><td>CRLIFOV1</td><td><div style="word-wrap: break-word;"><b>Capture Rising Latch Interrupt Flag Overrun Status (Read Only)
</b><br>
This flag indicates if rising latch happened when the corresponding CRLIF is 1.
<br>
Note: This bit will be cleared automatically when user clear corresponding CRLIF.
<br>
</div></td></tr><tr><td>
[2]</td><td>CRLIFOV2</td><td><div style="word-wrap: break-word;"><b>Capture Rising Latch Interrupt Flag Overrun Status (Read Only)
</b><br>
This flag indicates if rising latch happened when the corresponding CRLIF is 1.
<br>
Note: This bit will be cleared automatically when user clear corresponding CRLIF.
<br>
</div></td></tr><tr><td>
[3]</td><td>CRLIFOV3</td><td><div style="word-wrap: break-word;"><b>Capture Rising Latch Interrupt Flag Overrun Status (Read Only)
</b><br>
This flag indicates if rising latch happened when the corresponding CRLIF is 1.
<br>
Note: This bit will be cleared automatically when user clear corresponding CRLIF.
<br>
</div></td></tr><tr><td>
[4]</td><td>CRLIFOV4</td><td><div style="word-wrap: break-word;"><b>Capture Rising Latch Interrupt Flag Overrun Status (Read Only)
</b><br>
This flag indicates if rising latch happened when the corresponding CRLIF is 1.
<br>
Note: This bit will be cleared automatically when user clear corresponding CRLIF.
<br>
</div></td></tr><tr><td>
[5]</td><td>CRLIFOV5</td><td><div style="word-wrap: break-word;"><b>Capture Rising Latch Interrupt Flag Overrun Status (Read Only)
</b><br>
This flag indicates if rising latch happened when the corresponding CRLIF is 1.
<br>
Note: This bit will be cleared automatically when user clear corresponding CRLIF.
<br>
</div></td></tr><tr><td>
[8]</td><td>CFLIFOV0</td><td><div style="word-wrap: break-word;"><b>Capture Falling Latch Interrupt Flag Overrun Status (Read Only)
</b><br>
This flag indicates if falling latch happened when the corresponding CFLIF is 1.
<br>
Note: This bit will be cleared automatically when user clear corresponding CFLIF.
<br>
</div></td></tr><tr><td>
[9]</td><td>CFLIFOV1</td><td><div style="word-wrap: break-word;"><b>Capture Falling Latch Interrupt Flag Overrun Status (Read Only)
</b><br>
This flag indicates if falling latch happened when the corresponding CFLIF is 1.
<br>
Note: This bit will be cleared automatically when user clear corresponding CFLIF.
<br>
</div></td></tr><tr><td>
[10]</td><td>CFLIFOV2</td><td><div style="word-wrap: break-word;"><b>Capture Falling Latch Interrupt Flag Overrun Status (Read Only)
</b><br>
This flag indicates if falling latch happened when the corresponding CFLIF is 1.
<br>
Note: This bit will be cleared automatically when user clear corresponding CFLIF.
<br>
</div></td></tr><tr><td>
[11]</td><td>CFLIFOV3</td><td><div style="word-wrap: break-word;"><b>Capture Falling Latch Interrupt Flag Overrun Status (Read Only)
</b><br>
This flag indicates if falling latch happened when the corresponding CFLIF is 1.
<br>
Note: This bit will be cleared automatically when user clear corresponding CFLIF.
<br>
</div></td></tr><tr><td>
[12]</td><td>CFLIFOV4</td><td><div style="word-wrap: break-word;"><b>Capture Falling Latch Interrupt Flag Overrun Status (Read Only)
</b><br>
This flag indicates if falling latch happened when the corresponding CFLIF is 1.
<br>
Note: This bit will be cleared automatically when user clear corresponding CFLIF.
<br>
</div></td></tr><tr><td>
[13]</td><td>CFLIFOV5</td><td><div style="word-wrap: break-word;"><b>Capture Falling Latch Interrupt Flag Overrun Status (Read Only)
</b><br>
This flag indicates if falling latch happened when the corresponding CFLIF is 1.
<br>
Note: This bit will be cleared automatically when user clear corresponding CFLIF.
<br>
</div></td></tr></tbody></table></html>

 </p>

<p class="definition">Definition at line <a class="el" href="epwm__reg_8h_source.html#l04805">4805</a> of file <a class="el" href="epwm__reg_8h_source.html">epwm_reg.h</a>.</p>

</div>
</div>
<a id="a47280570c4b39bb7b3df7fab3401cdb3" name="a47280570c4b39bb7b3df7fab3401cdb3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a47280570c4b39bb7b3df7fab3401cdb3">&#9670;&nbsp;</a></span>CLKPSC</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">EPWM_T::CLKPSC[3]</td>
        </tr>
      </table>
</div><div class="memdoc">
<p >[0x0014] EPWM Clock Prescale Register 0/1,2/3,4/5 <br  />
</p>
<p > 

<html><table class="fixed" border="1" style="border-collapse:collapse;" borderColor=black ><col width="75px" /><col width="125px" /><col width="700px" /><caption align="left"><font size="3">CLKPSC[3]
</font><br><p> <font size="2">
Offset: 0x14  EPWM Clock Prescale Register 0/1, 2/3, 4/5
</font></caption><thread><tr bgcolor="#8A0808" ><td><font color=white><b>Bits</b></font></td><td><font color=white><b>Field</b></font></td><td><font color=white><b>Descriptions</b></font></td></tr></thread><tbody>
<tr><td>
[11:0]</td><td>CLKPSC</td><td><div style="word-wrap: break-word;"><b>EPWM Counter Clock Prescale
</b><br>
The clock of EPWM counter is decided by clock prescaler
<br>
Each EPWM pair share one EPWM counter clock prescaler
<br>
The clock of EPWM counter is divided by (CLKPSC+ 1)
<br>
</div></td></tr></tbody></table></html>

 </p>

<p class="definition">Definition at line <a class="el" href="epwm__reg_8h_source.html#l04722">4722</a> of file <a class="el" href="epwm__reg_8h_source.html">epwm_reg.h</a>.</p>

</div>
</div>
<a id="a0543aacf1d502959cb15aa97238d8c12" name="a0543aacf1d502959cb15aa97238d8c12"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0543aacf1d502959cb15aa97238d8c12">&#9670;&nbsp;</a></span>CLKSRC</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">EPWM_T::CLKSRC</td>
        </tr>
      </table>
</div><div class="memdoc">
<p >[0x0010] EPWM Clock Source Register <br  />
</p>
<p > 

<html><table class="fixed" border="1" style="border-collapse:collapse;" borderColor=black ><col width="75px" /><col width="125px" /><col width="700px" /><caption align="left"><font size="3">CLKSRC
</font><br><p> <font size="2">
Offset: 0x10  EPWM Clock Source Register
</font></caption><thread><tr bgcolor="#8A0808" ><td><font color=white><b>Bits</b></font></td><td><font color=white><b>Field</b></font></td><td><font color=white><b>Descriptions</b></font></td></tr></thread><tbody>
<tr><td>
[2:0]</td><td>ECLKSRC0</td><td><div style="word-wrap: break-word;"><b>EPWM_CH01 External Clock Source Select
</b><br>
000 = EPWMx_CLK, x denotes 0 or 1.
<br>
001 = TIMER0 overflow.
<br>
010 = TIMER1 overflow.
<br>
011 = TIMER2 overflow.
<br>
100 = TIMER3 overflow.
<br>
Others = Reserved.
<br>
</div></td></tr><tr><td>
[10:8]</td><td>ECLKSRC2</td><td><div style="word-wrap: break-word;"><b>EPWM_CH23 External Clock Source Select
</b><br>
000 = EPWMx_CLK, x denotes 0 or 1.
<br>
001 = TIMER0 overflow.
<br>
010 = TIMER1 overflow.
<br>
011 = TIMER2 overflow.
<br>
100 = TIMER3 overflow.
<br>
Others = Reserved.
<br>
</div></td></tr><tr><td>
[18:16]</td><td>ECLKSRC4</td><td><div style="word-wrap: break-word;"><b>EPWM_CH45 External Clock Source Select
</b><br>
000 = EPWMx_CLK, x denotes 0 or 1.
<br>
001 = TIMER0 overflow.
<br>
010 = TIMER1 overflow.
<br>
011 = TIMER2 overflow.
<br>
100 = TIMER3 overflow.
<br>
Others = Reserved.
<br>
</div></td></tr></tbody></table></html>

 </p>

<p class="definition">Definition at line <a class="el" href="epwm__reg_8h_source.html#l04721">4721</a> of file <a class="el" href="epwm__reg_8h_source.html">epwm_reg.h</a>.</p>

</div>
</div>
<a id="a28b40a46d04b9b891448a7f1a415ff86" name="a28b40a46d04b9b891448a7f1a415ff86"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a28b40a46d04b9b891448a7f1a415ff86">&#9670;&nbsp;</a></span>CMPBUF</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">EPWM_T::CMPBUF[6]</td>
        </tr>
      </table>
</div><div class="memdoc">
<p >[0x031c] EPWM CMPDAT0~5 Buffer <br  />
</p>
<p > 

<html><table class="fixed" border="1" style="border-collapse:collapse;" borderColor=black ><col width="75px" /><col width="125px" /><col width="700px" /><caption align="left"><font size="3">CMPBUF[6]
</font><br><p> <font size="2">
Offset: 0x31C  EPWM CMPDAT0~5 Buffer
</font></caption><thread><tr bgcolor="#8A0808" ><td><font color=white><b>Bits</b></font></td><td><font color=white><b>Field</b></font></td><td><font color=white><b>Descriptions</b></font></td></tr></thread><tbody>
<tr><td>
[15:0]</td><td>CMPBUF</td><td><div style="word-wrap: break-word;"><b>EPWM Comparator Register Buffer (Read Only)
</b><br>
Used as CMP active register.
<br>
</div></td></tr></tbody></table></html>

 </p>

<p class="definition">Definition at line <a class="el" href="epwm__reg_8h_source.html#l04818">4818</a> of file <a class="el" href="epwm__reg_8h_source.html">epwm_reg.h</a>.</p>

</div>
</div>
<a id="a6125934b63ce0713054bb320d89cfb80" name="a6125934b63ce0713054bb320d89cfb80"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6125934b63ce0713054bb320d89cfb80">&#9670;&nbsp;</a></span>CMPDAT</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">EPWM_T::CMPDAT[6]</td>
        </tr>
      </table>
</div><div class="memdoc">
<p >[0x0050] EPWM Comparator Register 0~5 <br  />
</p>
<p > 

<html><table class="fixed" border="1" style="border-collapse:collapse;" borderColor=black ><col width="75px" /><col width="125px" /><col width="700px" /><caption align="left"><font size="3">CMPDAT[6]
</font><br><p> <font size="2">
Offset: 0x50  EPWM Comparator Register 0
</font></caption><thread><tr bgcolor="#8A0808" ><td><font color=white><b>Bits</b></font></td><td><font color=white><b>Field</b></font></td><td><font color=white><b>Descriptions</b></font></td></tr></thread><tbody>
<tr><td>
[15:0]</td><td>CMP</td><td><div style="word-wrap: break-word;"><b>EPWM Comparator Register
</b><br>
CMP use to compare with CNTR to generate EPWM waveform, interrupt and trigger EADC/DAC.
<br>
In independent mode, CMPDAT0~5 denote as 6 independent EPWM_CH0~5 compared point.
<br>
In complementary mode, CMPDAT0, 2, 4 denote as first compared point, and CMPDAT1, 3, 5 denote as second compared point for the corresponding 3 complementary pairs EPWM_CH0 and EPWM_CH1, EPWM_CH2 and EPWM_CH3, EPWM_CH4 and EPWM_CH5.
<br>
</div></td></tr></tbody></table></html>

 </p>

<p class="definition">Definition at line <a class="el" href="epwm__reg_8h_source.html#l04733">4733</a> of file <a class="el" href="epwm__reg_8h_source.html">epwm_reg.h</a>.</p>

</div>
</div>
<a id="a8ec40b43ba7f0e40755ff49ea8f5ef82" name="a8ec40b43ba7f0e40755ff49ea8f5ef82"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8ec40b43ba7f0e40755ff49ea8f5ef82">&#9670;&nbsp;</a></span>CNT</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">EPWM_T::CNT[6]</td>
        </tr>
      </table>
</div><div class="memdoc">
<p >[0x0090] EPWM Counter Register 0~5 <br  />
</p>
<p > 

<html><table class="fixed" border="1" style="border-collapse:collapse;" borderColor=black ><col width="75px" /><col width="125px" /><col width="700px" /><caption align="left"><font size="3">CNT[6]
</font><br><p> <font size="2">
Offset: 0x90  EPWM Counter Register 0~5
</font></caption><thread><tr bgcolor="#8A0808" ><td><font color=white><b>Bits</b></font></td><td><font color=white><b>Field</b></font></td><td><font color=white><b>Descriptions</b></font></td></tr></thread><tbody>
<tr><td>
[15:0]</td><td>CNT</td><td><div style="word-wrap: break-word;"><b>EPWM Data Register (Read Only)
</b><br>
User can monitor CNTR to know the current value in 16-bit period counter.
<br>
</div></td></tr><tr><td>
[16]</td><td>DIRF</td><td><div style="word-wrap: break-word;"><b>EPWM Direction Indicator Flag (Read Only)
</b><br>
0 = Counter is Down count.
<br>
1 = Counter is UP count.
<br>
</div></td></tr></tbody></table></html>

 </p>

<p class="definition">Definition at line <a class="el" href="epwm__reg_8h_source.html#l04745">4745</a> of file <a class="el" href="epwm__reg_8h_source.html">epwm_reg.h</a>.</p>

</div>
</div>
<a id="a5d6b4513719efeba3a167396262587e8" name="a5d6b4513719efeba3a167396262587e8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5d6b4513719efeba3a167396262587e8">&#9670;&nbsp;</a></span>CNTCLR</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">EPWM_T::CNTCLR</td>
        </tr>
      </table>
</div><div class="memdoc">
<p >[0x0024] EPWM Clear Counter Register <br  />
</p>
<p > 

<html><table class="fixed" border="1" style="border-collapse:collapse;" borderColor=black ><col width="75px" /><col width="125px" /><col width="700px" /><caption align="left"><font size="3">CNTCLR
</font><br><p> <font size="2">
Offset: 0x24  EPWM Clear Counter Register
</font></caption><thread><tr bgcolor="#8A0808" ><td><font color=white><b>Bits</b></font></td><td><font color=white><b>Field</b></font></td><td><font color=white><b>Descriptions</b></font></td></tr></thread><tbody>
<tr><td>
[0]</td><td>CNTCLR0</td><td><div style="word-wrap: break-word;"><b>Clear EPWM Counter Control Bit
</b><br>
It is automatically cleared by hardware. Each bit n controls the corresponding EPWM channel n.
<br>
0 = No effect.
<br>
1 = Clear 16-bit EPWM counter to 0000H.
<br>
</div></td></tr><tr><td>
[1]</td><td>CNTCLR1</td><td><div style="word-wrap: break-word;"><b>Clear EPWM Counter Control Bit
</b><br>
It is automatically cleared by hardware. Each bit n controls the corresponding EPWM channel n.
<br>
0 = No effect.
<br>
1 = Clear 16-bit EPWM counter to 0000H.
<br>
</div></td></tr><tr><td>
[2]</td><td>CNTCLR2</td><td><div style="word-wrap: break-word;"><b>Clear EPWM Counter Control Bit
</b><br>
It is automatically cleared by hardware. Each bit n controls the corresponding EPWM channel n.
<br>
0 = No effect.
<br>
1 = Clear 16-bit EPWM counter to 0000H.
<br>
</div></td></tr><tr><td>
[3]</td><td>CNTCLR3</td><td><div style="word-wrap: break-word;"><b>Clear EPWM Counter Control Bit
</b><br>
It is automatically cleared by hardware. Each bit n controls the corresponding EPWM channel n.
<br>
0 = No effect.
<br>
1 = Clear 16-bit EPWM counter to 0000H.
<br>
</div></td></tr><tr><td>
[4]</td><td>CNTCLR4</td><td><div style="word-wrap: break-word;"><b>Clear EPWM Counter Control Bit
</b><br>
It is automatically cleared by hardware. Each bit n controls the corresponding EPWM channel n.
<br>
0 = No effect.
<br>
1 = Clear 16-bit EPWM counter to 0000H.
<br>
</div></td></tr><tr><td>
[5]</td><td>CNTCLR5</td><td><div style="word-wrap: break-word;"><b>Clear EPWM Counter Control Bit
</b><br>
It is automatically cleared by hardware. Each bit n controls the corresponding EPWM channel n.
<br>
0 = No effect.
<br>
1 = Clear 16-bit EPWM counter to 0000H.
<br>
</div></td></tr></tbody></table></html>

 </p>

<p class="definition">Definition at line <a class="el" href="epwm__reg_8h_source.html#l04724">4724</a> of file <a class="el" href="epwm__reg_8h_source.html">epwm_reg.h</a>.</p>

</div>
</div>
<a id="ac03c511206eb9035e1a1d3205432a88d" name="ac03c511206eb9035e1a1d3205432a88d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac03c511206eb9035e1a1d3205432a88d">&#9670;&nbsp;</a></span>CNTEN</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">EPWM_T::CNTEN</td>
        </tr>
      </table>
</div><div class="memdoc">
<p >[0x0020] EPWM Counter Enable Register <br  />
</p>
<p > 

<html><table class="fixed" border="1" style="border-collapse:collapse;" borderColor=black ><col width="75px" /><col width="125px" /><col width="700px" /><caption align="left"><font size="3">CNTEN
</font><br><p> <font size="2">
Offset: 0x20  EPWM Counter Enable Register
</font></caption><thread><tr bgcolor="#8A0808" ><td><font color=white><b>Bits</b></font></td><td><font color=white><b>Field</b></font></td><td><font color=white><b>Descriptions</b></font></td></tr></thread><tbody>
<tr><td>
[0]</td><td>CNTEN0</td><td><div style="word-wrap: break-word;"><b>EPWM Counter Enable Bits
</b><br>
0 = EPWM Counter and clock prescaler Stop Running.
<br>
1 = EPWM Counter and clock prescaler Start Running.
<br>
</div></td></tr><tr><td>
[1]</td><td>CNTEN1</td><td><div style="word-wrap: break-word;"><b>EPWM Counter Enable Bits
</b><br>
0 = EPWM Counter and clock prescaler Stop Running.
<br>
1 = EPWM Counter and clock prescaler Start Running.
<br>
</div></td></tr><tr><td>
[2]</td><td>CNTEN2</td><td><div style="word-wrap: break-word;"><b>EPWM Counter Enable Bits
</b><br>
0 = EPWM Counter and clock prescaler Stop Running.
<br>
1 = EPWM Counter and clock prescaler Start Running.
<br>
</div></td></tr><tr><td>
[3]</td><td>CNTEN3</td><td><div style="word-wrap: break-word;"><b>EPWM Counter Enable Bits
</b><br>
0 = EPWM Counter and clock prescaler Stop Running.
<br>
1 = EPWM Counter and clock prescaler Start Running.
<br>
</div></td></tr><tr><td>
[4]</td><td>CNTEN4</td><td><div style="word-wrap: break-word;"><b>EPWM Counter Enable Bits
</b><br>
0 = EPWM Counter and clock prescaler Stop Running.
<br>
1 = EPWM Counter and clock prescaler Start Running.
<br>
</div></td></tr><tr><td>
[5]</td><td>CNTEN5</td><td><div style="word-wrap: break-word;"><b>EPWM Counter Enable Bits
</b><br>
0 = EPWM Counter and clock prescaler Stop Running.
<br>
1 = EPWM Counter and clock prescaler Start Running.
<br>
</div></td></tr></tbody></table></html>

 </p>

<p class="definition">Definition at line <a class="el" href="epwm__reg_8h_source.html#l04723">4723</a> of file <a class="el" href="epwm__reg_8h_source.html">epwm_reg.h</a>.</p>

</div>
</div>
<a id="a111855c3ba8fa8ab68d686992be123b4" name="a111855c3ba8fa8ab68d686992be123b4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a111855c3ba8fa8ab68d686992be123b4">&#9670;&nbsp;</a></span>CPSCBUF</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">EPWM_T::CPSCBUF[3]</td>
        </tr>
      </table>
</div><div class="memdoc">
<p >[0x0334] EPWM CLKPSC0_1/2_3/4_5 Buffer <br  />
</p>
<p > 

<html><table class="fixed" border="1" style="border-collapse:collapse;" borderColor=black ><col width="75px" /><col width="125px" /><col width="700px" /><caption align="left"><font size="3">CPSCBUF[3]
</font><br><p> <font size="2">
Offset: 0x334  EPWM CLKPSC0_1/2_3/4_5 Buffer
</font></caption><thread><tr bgcolor="#8A0808" ><td><font color=white><b>Bits</b></font></td><td><font color=white><b>Field</b></font></td><td><font color=white><b>Descriptions</b></font></td></tr></thread><tbody>
<tr><td>
[11:0]</td><td>CPSCBUF</td><td><div style="word-wrap: break-word;"><b>EPWM Counter Clock Prescale Buffer
</b><br>
Use as EPWM counter clock prescale active register.
<br>
</div></td></tr></tbody></table></html>

 </p>

<p class="definition">Definition at line <a class="el" href="epwm__reg_8h_source.html#l04819">4819</a> of file <a class="el" href="epwm__reg_8h_source.html">epwm_reg.h</a>.</p>

</div>
</div>
<a id="acb716eb6cd9de345d432a2d8e862868c" name="acb716eb6cd9de345d432a2d8e862868c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acb716eb6cd9de345d432a2d8e862868c">&#9670;&nbsp;</a></span>CTL0</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">EPWM_T::CTL0</td>
        </tr>
      </table>
</div><div class="memdoc">
<p >[0x0000] EPWM Control Register 0 <br  />
</p>
<p > 

<html><table class="fixed" border="1" style="border-collapse:collapse;" borderColor=black ><col width="75px" /><col width="125px" /><col width="700px" /><caption align="left"><font size="3">CTL0
</font><br><p> <font size="2">
Offset: 0x00  EPWM Control Register 0
</font></caption><thread><tr bgcolor="#8A0808" ><td><font color=white><b>Bits</b></font></td><td><font color=white><b>Field</b></font></td><td><font color=white><b>Descriptions</b></font></td></tr></thread><tbody>
<tr><td>
[0]</td><td>CTRLD0</td><td><div style="word-wrap: break-word;"><b>Center Re-load
</b><br>
In up-down counter type, PERIOD will load to PBUF at the end point of each period
<br>
CMPDAT will load to CMPBUF at the center point of a period
<br>
</div></td></tr><tr><td>
[1]</td><td>CTRLD1</td><td><div style="word-wrap: break-word;"><b>Center Re-load
</b><br>
In up-down counter type, PERIOD will load to PBUF at the end point of each period
<br>
CMPDAT will load to CMPBUF at the center point of a period
<br>
</div></td></tr><tr><td>
[2]</td><td>CTRLD2</td><td><div style="word-wrap: break-word;"><b>Center Re-load
</b><br>
In up-down counter type, PERIOD will load to PBUF at the end point of each period
<br>
CMPDAT will load to CMPBUF at the center point of a period
<br>
</div></td></tr><tr><td>
[3]</td><td>CTRLD3</td><td><div style="word-wrap: break-word;"><b>Center Re-load
</b><br>
In up-down counter type, PERIOD will load to PBUF at the end point of each period
<br>
CMPDAT will load to CMPBUF at the center point of a period
<br>
</div></td></tr><tr><td>
[4]</td><td>CTRLD4</td><td><div style="word-wrap: break-word;"><b>Center Re-load
</b><br>
In up-down counter type, PERIOD will load to PBUF at the end point of each period
<br>
CMPDAT will load to CMPBUF at the center point of a period
<br>
</div></td></tr><tr><td>
[5]</td><td>CTRLD5</td><td><div style="word-wrap: break-word;"><b>Center Re-load
</b><br>
In up-down counter type, PERIOD will load to PBUF at the end point of each period
<br>
CMPDAT will load to CMPBUF at the center point of a period
<br>
</div></td></tr><tr><td>
[8]</td><td>WINLDEN0</td><td><div style="word-wrap: break-word;"><b>Window Load Enable Bits
</b><br>
0 = PERIOD will load to PBUF at the end point of each period
<br>
CMPDAT will load to CMPBUF at the end point or center point of each period by setting CTRLD bit.
<br>
1 = PERIOD will load to PBUF at the end point of each period
<br>
CMPDAT will load to CMPBUF at the end point of each period when valid reload window is set
<br>
The valid reload window is set by software write 1 to EPWM_LOAD register and cleared by hardware after load success.
<br>
</div></td></tr><tr><td>
[9]</td><td>WINLDEN1</td><td><div style="word-wrap: break-word;"><b>Window Load Enable Bits
</b><br>
0 = PERIOD will load to PBUF at the end point of each period
<br>
CMPDAT will load to CMPBUF at the end point or center point of each period by setting CTRLD bit.
<br>
1 = PERIOD will load to PBUF at the end point of each period
<br>
CMPDAT will load to CMPBUF at the end point of each period when valid reload window is set
<br>
The valid reload window is set by software write 1 to EPWM_LOAD register and cleared by hardware after load success.
<br>
</div></td></tr><tr><td>
[10]</td><td>WINLDEN2</td><td><div style="word-wrap: break-word;"><b>Window Load Enable Bits
</b><br>
0 = PERIOD will load to PBUF at the end point of each period
<br>
CMPDAT will load to CMPBUF at the end point or center point of each period by setting CTRLD bit.
<br>
1 = PERIOD will load to PBUF at the end point of each period
<br>
CMPDAT will load to CMPBUF at the end point of each period when valid reload window is set
<br>
The valid reload window is set by software write 1 to EPWM_LOAD register and cleared by hardware after load success.
<br>
</div></td></tr><tr><td>
[11]</td><td>WINLDEN3</td><td><div style="word-wrap: break-word;"><b>Window Load Enable Bits
</b><br>
0 = PERIOD will load to PBUF at the end point of each period
<br>
CMPDAT will load to CMPBUF at the end point or center point of each period by setting CTRLD bit.
<br>
1 = PERIOD will load to PBUF at the end point of each period
<br>
CMPDAT will load to CMPBUF at the end point of each period when valid reload window is set
<br>
The valid reload window is set by software write 1 to EPWM_LOAD register and cleared by hardware after load success.
<br>
</div></td></tr><tr><td>
[12]</td><td>WINLDEN4</td><td><div style="word-wrap: break-word;"><b>Window Load Enable Bits
</b><br>
0 = PERIOD will load to PBUF at the end point of each period
<br>
CMPDAT will load to CMPBUF at the end point or center point of each period by setting CTRLD bit.
<br>
1 = PERIOD will load to PBUF at the end point of each period
<br>
CMPDAT will load to CMPBUF at the end point of each period when valid reload window is set
<br>
The valid reload window is set by software write 1 to EPWM_LOAD register and cleared by hardware after load success.
<br>
</div></td></tr><tr><td>
[13]</td><td>WINLDEN5</td><td><div style="word-wrap: break-word;"><b>Window Load Enable Bits
</b><br>
0 = PERIOD will load to PBUF at the end point of each period
<br>
CMPDAT will load to CMPBUF at the end point or center point of each period by setting CTRLD bit.
<br>
1 = PERIOD will load to PBUF at the end point of each period
<br>
CMPDAT will load to CMPBUF at the end point of each period when valid reload window is set
<br>
The valid reload window is set by software write 1 to EPWM_LOAD register and cleared by hardware after load success.
<br>
</div></td></tr><tr><td>
[16]</td><td>IMMLDEN0</td><td><div style="word-wrap: break-word;"><b>Immediately Load Enable Bits
</b><br>
0 = PERIOD will load to PBUF at the end point of each period
<br>
CMPDAT will load to CMPBUF at the end point or center point of each period by setting CTRLD bit.
<br>
1 = PERIOD/CMPDAT will load to PBUF and CMPBUF immediately when software update PERIOD/CMPDAT.
<br>
Note: If IMMLDENn is enabled, WINLDENn and CTRLDn will be invalid.
<br>
</div></td></tr><tr><td>
[17]</td><td>IMMLDEN1</td><td><div style="word-wrap: break-word;"><b>Immediately Load Enable Bits
</b><br>
0 = PERIOD will load to PBUF at the end point of each period
<br>
CMPDAT will load to CMPBUF at the end point or center point of each period by setting CTRLD bit.
<br>
1 = PERIOD/CMPDAT will load to PBUF and CMPBUF immediately when software update PERIOD/CMPDAT.
<br>
Note: If IMMLDENn is enabled, WINLDENn and CTRLDn will be invalid.
<br>
</div></td></tr><tr><td>
[18]</td><td>IMMLDEN2</td><td><div style="word-wrap: break-word;"><b>Immediately Load Enable Bits
</b><br>
0 = PERIOD will load to PBUF at the end point of each period
<br>
CMPDAT will load to CMPBUF at the end point or center point of each period by setting CTRLD bit.
<br>
1 = PERIOD/CMPDAT will load to PBUF and CMPBUF immediately when software update PERIOD/CMPDAT.
<br>
Note: If IMMLDENn is enabled, WINLDENn and CTRLDn will be invalid.
<br>
</div></td></tr><tr><td>
[19]</td><td>IMMLDEN3</td><td><div style="word-wrap: break-word;"><b>Immediately Load Enable Bits
</b><br>
0 = PERIOD will load to PBUF at the end point of each period
<br>
CMPDAT will load to CMPBUF at the end point or center point of each period by setting CTRLD bit.
<br>
1 = PERIOD/CMPDAT will load to PBUF and CMPBUF immediately when software update PERIOD/CMPDAT.
<br>
Note: If IMMLDENn is enabled, WINLDENn and CTRLDn will be invalid.
<br>
</div></td></tr><tr><td>
[20]</td><td>IMMLDEN4</td><td><div style="word-wrap: break-word;"><b>Immediately Load Enable Bits
</b><br>
0 = PERIOD will load to PBUF at the end point of each period
<br>
CMPDAT will load to CMPBUF at the end point or center point of each period by setting CTRLD bit.
<br>
1 = PERIOD/CMPDAT will load to PBUF and CMPBUF immediately when software update PERIOD/CMPDAT.
<br>
Note: If IMMLDENn is enabled, WINLDENn and CTRLDn will be invalid.
<br>
</div></td></tr><tr><td>
[21]</td><td>IMMLDEN5</td><td><div style="word-wrap: break-word;"><b>Immediately Load Enable Bits
</b><br>
0 = PERIOD will load to PBUF at the end point of each period
<br>
CMPDAT will load to CMPBUF at the end point or center point of each period by setting CTRLD bit.
<br>
1 = PERIOD/CMPDAT will load to PBUF and CMPBUF immediately when software update PERIOD/CMPDAT.
<br>
Note: If IMMLDENn is enabled, WINLDENn and CTRLDn will be invalid.
<br>
</div></td></tr><tr><td>
[24]</td><td>GROUPEN</td><td><div style="word-wrap: break-word;"><b>Group Function Enable Bit(S)
</b><br>
0 = The output waveform of each EPWM channel are independent.
<br>
1 = Unify the EPWM_CH2 and EPWM_CH4 to output the same waveform as EPWM_CH0 and unify the EPWM_CH3 and EPWM_CH5 to output the same waveform as EPWM_CH1.
<br>
</div></td></tr><tr><td>
[30]</td><td>DBGHALT</td><td><div style="word-wrap: break-word;"><b>ICE Debug Mode Counter Halt (Write Protect)
</b><br>
If counter halt is enabled, EPWM all counters will keep current value until exit ICE debug mode.
<br>
0 = ICE debug mode counter halt disable.
<br>
1 = ICE debug mode counter halt enable.
<br>
Note: This register is write protected. Refer toSYS_REGLCTL register.
<br>
</div></td></tr><tr><td>
[31]</td><td>DBGTRIOFF</td><td><div style="word-wrap: break-word;"><b>ICE Debug Mode Acknowledge Disable (Write Protect)
</b><br>
0 = ICE debug mode acknowledgement effects EPWM output.
<br>
EPWM pin will be forced as tri-state while ICE debug mode acknowledged.
<br>
1 = ICE debug mode acknowledgement disabled.
<br>
EPWM pin will keep output no matter ICE debug mode acknowledged or not.
<br>
Note: This register is write protected. Refer toSYS_REGLCTL register.
<br>
</div></td></tr></tbody></table></html>

 </p>

<p class="definition">Definition at line <a class="el" href="epwm__reg_8h_source.html#l04717">4717</a> of file <a class="el" href="epwm__reg_8h_source.html">epwm_reg.h</a>.</p>

</div>
</div>
<a id="a65b83a80a8d852b1fe62bae935c4d41b" name="a65b83a80a8d852b1fe62bae935c4d41b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a65b83a80a8d852b1fe62bae935c4d41b">&#9670;&nbsp;</a></span>CTL1</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">EPWM_T::CTL1</td>
        </tr>
      </table>
</div><div class="memdoc">
<p >[0x0004] EPWM Control Register 1 <br  />
</p>
<p > 

<html><table class="fixed" border="1" style="border-collapse:collapse;" borderColor=black ><col width="75px" /><col width="125px" /><col width="700px" /><caption align="left"><font size="3">CTL1
</font><br><p> <font size="2">
Offset: 0x04  EPWM Control Register 1
</font></caption><thread><tr bgcolor="#8A0808" ><td><font color=white><b>Bits</b></font></td><td><font color=white><b>Field</b></font></td><td><font color=white><b>Descriptions</b></font></td></tr></thread><tbody>
<tr><td>
[1:0]</td><td>CNTTYPE0</td><td><div style="word-wrap: break-word;"><b>EPWM Counter Behavior Type
</b><br>
00 = Up counter type (supports in capture mode).
<br>
01 = Down count type (supports in capture mode).
<br>
10 = Up-down counter type.
<br>
11 = Reserved.
<br>
</div></td></tr><tr><td>
[3:2]</td><td>CNTTYPE1</td><td><div style="word-wrap: break-word;"><b>EPWM Counter Behavior Type
</b><br>
00 = Up counter type (supports in capture mode).
<br>
01 = Down count type (supports in capture mode).
<br>
10 = Up-down counter type.
<br>
11 = Reserved.
<br>
</div></td></tr><tr><td>
[5:4]</td><td>CNTTYPE2</td><td><div style="word-wrap: break-word;"><b>EPWM Counter Behavior Type
</b><br>
00 = Up counter type (supports in capture mode).
<br>
01 = Down count type (supports in capture mode).
<br>
10 = Up-down counter type.
<br>
11 = Reserved.
<br>
</div></td></tr><tr><td>
[7:6]</td><td>CNTTYPE3</td><td><div style="word-wrap: break-word;"><b>EPWM Counter Behavior Type
</b><br>
00 = Up counter type (supports in capture mode).
<br>
01 = Down count type (supports in capture mode).
<br>
10 = Up-down counter type.
<br>
11 = Reserved.
<br>
</div></td></tr><tr><td>
[9:8]</td><td>CNTTYPE4</td><td><div style="word-wrap: break-word;"><b>EPWM Counter Behavior Type
</b><br>
00 = Up counter type (supports in capture mode).
<br>
01 = Down count type (supports in capture mode).
<br>
10 = Up-down counter type.
<br>
11 = Reserved.
<br>
</div></td></tr><tr><td>
[11:10]</td><td>CNTTYPE5</td><td><div style="word-wrap: break-word;"><b>EPWM Counter Behavior Type
</b><br>
00 = Up counter type (supports in capture mode).
<br>
01 = Down count type (supports in capture mode).
<br>
10 = Up-down counter type.
<br>
11 = Reserved.
<br>
</div></td></tr><tr><td>
[16]</td><td>CNTMODE0</td><td><div style="word-wrap: break-word;"><b>EPWM Counter Mode
</b><br>
0 = Auto-reload mode.
<br>
1 = One-shot mode.
<br>
</div></td></tr><tr><td>
[17]</td><td>CNTMODE1</td><td><div style="word-wrap: break-word;"><b>EPWM Counter Mode
</b><br>
0 = Auto-reload mode.
<br>
1 = One-shot mode.
<br>
</div></td></tr><tr><td>
[18]</td><td>CNTMODE2</td><td><div style="word-wrap: break-word;"><b>EPWM Counter Mode
</b><br>
0 = Auto-reload mode.
<br>
1 = One-shot mode.
<br>
</div></td></tr><tr><td>
[19]</td><td>CNTMODE3</td><td><div style="word-wrap: break-word;"><b>EPWM Counter Mode
</b><br>
0 = Auto-reload mode.
<br>
1 = One-shot mode.
<br>
</div></td></tr><tr><td>
[20]</td><td>CNTMODE4</td><td><div style="word-wrap: break-word;"><b>EPWM Counter Mode
</b><br>
0 = Auto-reload mode.
<br>
1 = One-shot mode.
<br>
</div></td></tr><tr><td>
[21]</td><td>CNTMODE5</td><td><div style="word-wrap: break-word;"><b>EPWM Counter Mode
</b><br>
0 = Auto-reload mode.
<br>
1 = One-shot mode.
<br>
</div></td></tr><tr><td>
[24]</td><td>OUTMODE0</td><td><div style="word-wrap: break-word;"><b>EPWM Output Mode
</b><br>
Each bit n controls the output mode of corresponding EPWM channel n.
<br>
0 = EPWM independent mode.
<br>
1 = EPWM complementary mode.
<br>
Note: When operating in group function, these bits must all set to the same mode.
<br>
</div></td></tr><tr><td>
[25]</td><td>OUTMODE2</td><td><div style="word-wrap: break-word;"><b>EPWM Output Mode
</b><br>
Each bit n controls the output mode of corresponding EPWM channel n.
<br>
0 = EPWM independent mode.
<br>
1 = EPWM complementary mode.
<br>
Note: When operating in group function, these bits must all set to the same mode.
<br>
</div></td></tr><tr><td>
[26]</td><td>OUTMODE4</td><td><div style="word-wrap: break-word;"><b>EPWM Output Mode
</b><br>
Each bit n controls the output mode of corresponding EPWM channel n.
<br>
0 = EPWM independent mode.
<br>
1 = EPWM complementary mode.
<br>
Note: When operating in group function, these bits must all set to the same mode.
<br>
</div></td></tr></tbody></table></html>

 </p>

<p class="definition">Definition at line <a class="el" href="epwm__reg_8h_source.html#l04718">4718</a> of file <a class="el" href="epwm__reg_8h_source.html">epwm_reg.h</a>.</p>

</div>
</div>
<a id="aaa04cd853d1a6050087aff68a61eaa73" name="aaa04cd853d1a6050087aff68a61eaa73"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaa04cd853d1a6050087aff68a61eaa73">&#9670;&nbsp;</a></span>DACTRGEN</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">EPWM_T::DACTRGEN</td>
        </tr>
      </table>
</div><div class="memdoc">
<p >[0x00f4] EPWM Trigger DAC Enable Register <br  />
</p>
<p > 

<html><table class="fixed" border="1" style="border-collapse:collapse;" borderColor=black ><col width="75px" /><col width="125px" /><col width="700px" /><caption align="left"><font size="3">DACTRGEN
</font><br><p> <font size="2">
Offset: 0xF4  EPWM Trigger DAC Enable Register
</font></caption><thread><tr bgcolor="#8A0808" ><td><font color=white><b>Bits</b></font></td><td><font color=white><b>Field</b></font></td><td><font color=white><b>Descriptions</b></font></td></tr></thread><tbody>
<tr><td>
[0]</td><td>ZTE0</td><td><div style="word-wrap: break-word;"><b>EPWM Zero Point Trigger DAC Enable Bits
</b><br>
EPWM can trigger EADC/DAC/DMA to start action when EPWM counter down count to zero if this bit is set to1.
<br>
0 = EPWM period point trigger DAC function Disabled.
<br>
1 = EPWM period point trigger DAC function Enabled.
<br>
</div></td></tr><tr><td>
[1]</td><td>ZTE1</td><td><div style="word-wrap: break-word;"><b>EPWM Zero Point Trigger DAC Enable Bits
</b><br>
EPWM can trigger EADC/DAC/DMA to start action when EPWM counter down count to zero if this bit is set to1.
<br>
0 = EPWM period point trigger DAC function Disabled.
<br>
1 = EPWM period point trigger DAC function Enabled.
<br>
</div></td></tr><tr><td>
[2]</td><td>ZTE2</td><td><div style="word-wrap: break-word;"><b>EPWM Zero Point Trigger DAC Enable Bits
</b><br>
EPWM can trigger EADC/DAC/DMA to start action when EPWM counter down count to zero if this bit is set to1.
<br>
0 = EPWM period point trigger DAC function Disabled.
<br>
1 = EPWM period point trigger DAC function Enabled.
<br>
</div></td></tr><tr><td>
[3]</td><td>ZTE3</td><td><div style="word-wrap: break-word;"><b>EPWM Zero Point Trigger DAC Enable Bits
</b><br>
EPWM can trigger EADC/DAC/DMA to start action when EPWM counter down count to zero if this bit is set to1.
<br>
0 = EPWM period point trigger DAC function Disabled.
<br>
1 = EPWM period point trigger DAC function Enabled.
<br>
</div></td></tr><tr><td>
[4]</td><td>ZTE4</td><td><div style="word-wrap: break-word;"><b>EPWM Zero Point Trigger DAC Enable Bits
</b><br>
EPWM can trigger EADC/DAC/DMA to start action when EPWM counter down count to zero if this bit is set to1.
<br>
0 = EPWM period point trigger DAC function Disabled.
<br>
1 = EPWM period point trigger DAC function Enabled.
<br>
</div></td></tr><tr><td>
[5]</td><td>ZTE5</td><td><div style="word-wrap: break-word;"><b>EPWM Zero Point Trigger DAC Enable Bits
</b><br>
EPWM can trigger EADC/DAC/DMA to start action when EPWM counter down count to zero if this bit is set to1.
<br>
0 = EPWM period point trigger DAC function Disabled.
<br>
1 = EPWM period point trigger DAC function Enabled.
<br>
</div></td></tr><tr><td>
[8]</td><td>PTE0</td><td><div style="word-wrap: break-word;"><b>EPWM Period Point Trigger DAC Enable Bits
</b><br>
EPWM can trigger DAC to start action when EPWM counter up count to (PERIODn+1) if this bit is set to1.
<br>
0 = EPWM period point trigger DAC function Disabled.
<br>
1 = EPWM period point trigger DAC function Enabled.
<br>
</div></td></tr><tr><td>
[9]</td><td>PTE1</td><td><div style="word-wrap: break-word;"><b>EPWM Period Point Trigger DAC Enable Bits
</b><br>
EPWM can trigger DAC to start action when EPWM counter up count to (PERIODn+1) if this bit is set to1.
<br>
0 = EPWM period point trigger DAC function Disabled.
<br>
1 = EPWM period point trigger DAC function Enabled.
<br>
</div></td></tr><tr><td>
[10]</td><td>PTE2</td><td><div style="word-wrap: break-word;"><b>EPWM Period Point Trigger DAC Enable Bits
</b><br>
EPWM can trigger DAC to start action when EPWM counter up count to (PERIODn+1) if this bit is set to1.
<br>
0 = EPWM period point trigger DAC function Disabled.
<br>
1 = EPWM period point trigger DAC function Enabled.
<br>
</div></td></tr><tr><td>
[11]</td><td>PTE3</td><td><div style="word-wrap: break-word;"><b>EPWM Period Point Trigger DAC Enable Bits
</b><br>
EPWM can trigger DAC to start action when EPWM counter up count to (PERIODn+1) if this bit is set to1.
<br>
0 = EPWM period point trigger DAC function Disabled.
<br>
1 = EPWM period point trigger DAC function Enabled.
<br>
</div></td></tr><tr><td>
[12]</td><td>PTE4</td><td><div style="word-wrap: break-word;"><b>EPWM Period Point Trigger DAC Enable Bits
</b><br>
EPWM can trigger DAC to start action when EPWM counter up count to (PERIODn+1) if this bit is set to1.
<br>
0 = EPWM period point trigger DAC function Disabled.
<br>
1 = EPWM period point trigger DAC function Enabled.
<br>
</div></td></tr><tr><td>
[13]</td><td>PTE5</td><td><div style="word-wrap: break-word;"><b>EPWM Period Point Trigger DAC Enable Bits
</b><br>
EPWM can trigger DAC to start action when EPWM counter up count to (PERIODn+1) if this bit is set to1.
<br>
0 = EPWM period point trigger DAC function Disabled.
<br>
1 = EPWM period point trigger DAC function Enabled.
<br>
</div></td></tr><tr><td>
[16]</td><td>CUTRGE0</td><td><div style="word-wrap: break-word;"><b>EPWM Compare Up Count Point Trigger DAC Enable Bits
</b><br>
EPWM can trigger DAC to start action when EPWM counter up count to CMPDAT if this bit is set to1.
<br>
0 = EPWM Compare Up point trigger DAC function Disabled.
<br>
1 = EPWM Compare Up point trigger DAC function Enabled.
<br>
Note1: This bit should keep at 0 when EPWM counter operating in down counter type.
<br>
Note2: In complementary mode, CUTRGE1, 3, 5 use as another CUTRGE for channel 0, 2, 4.
<br>
</div></td></tr><tr><td>
[17]</td><td>CUTRGE1</td><td><div style="word-wrap: break-word;"><b>EPWM Compare Up Count Point Trigger DAC Enable Bits
</b><br>
EPWM can trigger DAC to start action when EPWM counter up count to CMPDAT if this bit is set to1.
<br>
0 = EPWM Compare Up point trigger DAC function Disabled.
<br>
1 = EPWM Compare Up point trigger DAC function Enabled.
<br>
Note1: This bit should keep at 0 when EPWM counter operating in down counter type.
<br>
Note2: In complementary mode, CUTRGE1, 3, 5 use as another CUTRGE for channel 0, 2, 4.
<br>
</div></td></tr><tr><td>
[18]</td><td>CUTRGE2</td><td><div style="word-wrap: break-word;"><b>EPWM Compare Up Count Point Trigger DAC Enable Bits
</b><br>
EPWM can trigger DAC to start action when EPWM counter up count to CMPDAT if this bit is set to1.
<br>
0 = EPWM Compare Up point trigger DAC function Disabled.
<br>
1 = EPWM Compare Up point trigger DAC function Enabled.
<br>
Note1: This bit should keep at 0 when EPWM counter operating in down counter type.
<br>
Note2: In complementary mode, CUTRGE1, 3, 5 use as another CUTRGE for channel 0, 2, 4.
<br>
</div></td></tr><tr><td>
[19]</td><td>CUTRGE3</td><td><div style="word-wrap: break-word;"><b>EPWM Compare Up Count Point Trigger DAC Enable Bits
</b><br>
EPWM can trigger DAC to start action when EPWM counter up count to CMPDAT if this bit is set to1.
<br>
0 = EPWM Compare Up point trigger DAC function Disabled.
<br>
1 = EPWM Compare Up point trigger DAC function Enabled.
<br>
Note1: This bit should keep at 0 when EPWM counter operating in down counter type.
<br>
Note2: In complementary mode, CUTRGE1, 3, 5 use as another CUTRGE for channel 0, 2, 4.
<br>
</div></td></tr><tr><td>
[20]</td><td>CUTRGE4</td><td><div style="word-wrap: break-word;"><b>EPWM Compare Up Count Point Trigger DAC Enable Bits
</b><br>
EPWM can trigger DAC to start action when EPWM counter up count to CMPDAT if this bit is set to1.
<br>
0 = EPWM Compare Up point trigger DAC function Disabled.
<br>
1 = EPWM Compare Up point trigger DAC function Enabled.
<br>
Note1: This bit should keep at 0 when EPWM counter operating in down counter type.
<br>
Note2: In complementary mode, CUTRGE1, 3, 5 use as another CUTRGE for channel 0, 2, 4.
<br>
</div></td></tr><tr><td>
[21]</td><td>CUTRGE5</td><td><div style="word-wrap: break-word;"><b>EPWM Compare Up Count Point Trigger DAC Enable Bits
</b><br>
EPWM can trigger DAC to start action when EPWM counter up count to CMPDAT if this bit is set to1.
<br>
0 = EPWM Compare Up point trigger DAC function Disabled.
<br>
1 = EPWM Compare Up point trigger DAC function Enabled.
<br>
Note1: This bit should keep at 0 when EPWM counter operating in down counter type.
<br>
Note2: In complementary mode, CUTRGE1, 3, 5 use as another CUTRGE for channel 0, 2, 4.
<br>
</div></td></tr><tr><td>
[24]</td><td>CDTRGE0</td><td><div style="word-wrap: break-word;"><b>EPWM Compare Down Count Point Trigger DAC Enable Bits
</b><br>
EPWM can trigger DAC to start action when EPWM counter down count to CMPDAT if this bit is set to1.
<br>
0 = EPWM Compare Down count point trigger DAC function Disabled.
<br>
1 = EPWM Compare Down count point trigger DAC function Enabled.
<br>
Note1: This bit should keep at 0 when EPWM counter operating in up counter type.
<br>
Note2: In complementary mode, CDTRGE1, 3, 5 use as another CDTRGE for channel 0, 2, 4.
<br>
</div></td></tr><tr><td>
[25]</td><td>CDTRGE1</td><td><div style="word-wrap: break-word;"><b>EPWM Compare Down Count Point Trigger DAC Enable Bits
</b><br>
EPWM can trigger DAC to start action when EPWM counter down count to CMPDAT if this bit is set to1.
<br>
0 = EPWM Compare Down count point trigger DAC function Disabled.
<br>
1 = EPWM Compare Down count point trigger DAC function Enabled.
<br>
Note1: This bit should keep at 0 when EPWM counter operating in up counter type.
<br>
Note2: In complementary mode, CDTRGE1, 3, 5 use as another CDTRGE for channel 0, 2, 4.
<br>
</div></td></tr><tr><td>
[26]</td><td>CDTRGE2</td><td><div style="word-wrap: break-word;"><b>EPWM Compare Down Count Point Trigger DAC Enable Bits
</b><br>
EPWM can trigger DAC to start action when EPWM counter down count to CMPDAT if this bit is set to1.
<br>
0 = EPWM Compare Down count point trigger DAC function Disabled.
<br>
1 = EPWM Compare Down count point trigger DAC function Enabled.
<br>
Note1: This bit should keep at 0 when EPWM counter operating in up counter type.
<br>
Note2: In complementary mode, CDTRGE1, 3, 5 use as another CDTRGE for channel 0, 2, 4.
<br>
</div></td></tr><tr><td>
[27]</td><td>CDTRGE3</td><td><div style="word-wrap: break-word;"><b>EPWM Compare Down Count Point Trigger DAC Enable Bits
</b><br>
EPWM can trigger DAC to start action when EPWM counter down count to CMPDAT if this bit is set to1.
<br>
0 = EPWM Compare Down count point trigger DAC function Disabled.
<br>
1 = EPWM Compare Down count point trigger DAC function Enabled.
<br>
Note1: This bit should keep at 0 when EPWM counter operating in up counter type.
<br>
Note2: In complementary mode, CDTRGE1, 3, 5 use as another CDTRGE for channel 0, 2, 4.
<br>
</div></td></tr><tr><td>
[28]</td><td>CDTRGE4</td><td><div style="word-wrap: break-word;"><b>EPWM Compare Down Count Point Trigger DAC Enable Bits
</b><br>
EPWM can trigger DAC to start action when EPWM counter down count to CMPDAT if this bit is set to1.
<br>
0 = EPWM Compare Down count point trigger DAC function Disabled.
<br>
1 = EPWM Compare Down count point trigger DAC function Enabled.
<br>
Note1: This bit should keep at 0 when EPWM counter operating in up counter type.
<br>
Note2: In complementary mode, CDTRGE1, 3, 5 use as another CDTRGE for channel 0, 2, 4.
<br>
</div></td></tr><tr><td>
[29]</td><td>CDTRGE5</td><td><div style="word-wrap: break-word;"><b>EPWM Compare Down Count Point Trigger DAC Enable Bits
</b><br>
EPWM can trigger DAC to start action when EPWM counter down count to CMPDAT if this bit is set to1.
<br>
0 = EPWM Compare Down count point trigger DAC function Disabled.
<br>
1 = EPWM Compare Down count point trigger DAC function Enabled.
<br>
Note1: This bit should keep at 0 when EPWM counter operating in up counter type.
<br>
Note2: In complementary mode, CDTRGE1, 3, 5 use as another CDTRGE for channel 0, 2, 4.
<br>
</div></td></tr></tbody></table></html>

 </p>

<p class="definition">Definition at line <a class="el" href="epwm__reg_8h_source.html#l04766">4766</a> of file <a class="el" href="epwm__reg_8h_source.html">epwm_reg.h</a>.</p>

</div>
</div>
<a id="afda9ab3337ef420e2b2ee40151347f42" name="afda9ab3337ef420e2b2ee40151347f42"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afda9ab3337ef420e2b2ee40151347f42">&#9670;&nbsp;</a></span>DTCTL</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">EPWM_T::DTCTL[3]</td>
        </tr>
      </table>
</div><div class="memdoc">
<p >[0x0070] EPWM Dead-Time Control Register 0/1,2/3,4/5 <br  />
</p>
<p > 

<html><table class="fixed" border="1" style="border-collapse:collapse;" borderColor=black ><col width="75px" /><col width="125px" /><col width="700px" /><caption align="left"><font size="3">DTCTL[3]
</font><br><p> <font size="2">
Offset: 0x70  EPWM Dead-Time Control Register 0/1,2/3,4/5
</font></caption><thread><tr bgcolor="#8A0808" ><td><font color=white><b>Bits</b></font></td><td><font color=white><b>Field</b></font></td><td><font color=white><b>Descriptions</b></font></td></tr></thread><tbody>
<tr><td>
[11:0]</td><td>DTCNT</td><td><div style="word-wrap: break-word;"><b>Dead-time Counter (Write Protect)
</b><br>
The dead-time can be calculated from the following formula:
<br>
Dead-time = (DTCNT[11:0]+1) * EPWM_CLK period.
<br>
Note: This register is write protected. Refer toSYS_REGLCTL register.
<br>
</div></td></tr><tr><td>
[16]</td><td>DTEN</td><td><div style="word-wrap: break-word;"><b>Enable Dead-time Insertion for EPWM Pair (EPWM_CH0, EPWM_CH1) (EPWM_CH2, EPWM_CH3) (EPWM_CH4, EPWM_CH5) (Write Protect)
</b><br>
Dead-time insertion is only active when this pair of complementary EPWM is enabled
<br>
If dead- time insertion is inactive, the outputs of pin pair are complementary without any delay.
<br>
0 = Dead-time insertion Disabled on the pin pair.
<br>
1 = Dead-time insertion Enabled on the pin pair.
<br>
Note: This register is write protected. Refer toSYS_REGLCTL register.
<br>
</div></td></tr><tr><td>
[24]</td><td>DTCKSEL</td><td><div style="word-wrap: break-word;"><b>Dead-time Clock Select (Write Protect)
</b><br>
0 = Dead-time clock source from EPWM_CLK.
<br>
1 = Dead-time clock source from prescaler output.
<br>
Note: This register is write protected. Refer toREGWRPROT register.
<br>
</div></td></tr></tbody></table></html>

 </p>

<p class="definition">Definition at line <a class="el" href="epwm__reg_8h_source.html#l04737">4737</a> of file <a class="el" href="epwm__reg_8h_source.html">epwm_reg.h</a>.</p>

</div>
</div>
<a id="a556f22b6afb66f66aef4fb2d155a01da" name="a556f22b6afb66f66aef4fb2d155a01da"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a556f22b6afb66f66aef4fb2d155a01da">&#9670;&nbsp;</a></span>EADCPSC0</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__IO uint32_t EPWM_T::EADCPSC0</td>
        </tr>
      </table>
</div><div class="memdoc">
<p >[0x0188] EPWM Trigger EADC Prescale Register 0 <br  />
 </p>

<p class="definition">Definition at line <a class="el" href="epwm__reg_8h_source.html#l04796">4796</a> of file <a class="el" href="epwm__reg_8h_source.html">epwm_reg.h</a>.</p>

</div>
</div>
<a id="a54d288d4d6f810db91ed68eae97f3f83" name="a54d288d4d6f810db91ed68eae97f3f83"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a54d288d4d6f810db91ed68eae97f3f83">&#9670;&nbsp;</a></span>EADCPSC1</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__IO uint32_t EPWM_T::EADCPSC1</td>
        </tr>
      </table>
</div><div class="memdoc">
<p >[0x018C] EPWM Trigger EADC Prescale Register 1 <br  />
 </p>

<p class="definition">Definition at line <a class="el" href="epwm__reg_8h_source.html#l04797">4797</a> of file <a class="el" href="epwm__reg_8h_source.html">epwm_reg.h</a>.</p>

</div>
</div>
<a id="ad229e802469432db695160d2d487600a" name="ad229e802469432db695160d2d487600a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad229e802469432db695160d2d487600a">&#9670;&nbsp;</a></span>EADCPSCCTL</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__IO uint32_t EPWM_T::EADCPSCCTL</td>
        </tr>
      </table>
</div><div class="memdoc">
<p >[0x0184] EPWM Trigger EADC Prescale Control Register <br  />
 </p>

<p class="definition">Definition at line <a class="el" href="epwm__reg_8h_source.html#l04795">4795</a> of file <a class="el" href="epwm__reg_8h_source.html">epwm_reg.h</a>.</p>

</div>
</div>
<a id="aeadd497278fe0a72142dedc2c79302bc" name="aeadd497278fe0a72142dedc2c79302bc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeadd497278fe0a72142dedc2c79302bc">&#9670;&nbsp;</a></span>EADCPSCNT0</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__IO uint32_t EPWM_T::EADCPSCNT0</td>
        </tr>
      </table>
</div><div class="memdoc">
<p >[0x0190] EPWM Trigger EADC Prescale Counter Register 0 <br  />
 </p>

<p class="definition">Definition at line <a class="el" href="epwm__reg_8h_source.html#l04798">4798</a> of file <a class="el" href="epwm__reg_8h_source.html">epwm_reg.h</a>.</p>

</div>
</div>
<a id="ab2b72d469cf368d9ce25e01de7aef6cb" name="ab2b72d469cf368d9ce25e01de7aef6cb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab2b72d469cf368d9ce25e01de7aef6cb">&#9670;&nbsp;</a></span>EADCPSCNT1</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__IO uint32_t EPWM_T::EADCPSCNT1</td>
        </tr>
      </table>
</div><div class="memdoc">
<p >[0x0194] EPWM Trigger EADC Prescale Counter Register 1 <br  />
 </p>

<p class="definition">Definition at line <a class="el" href="epwm__reg_8h_source.html#l04799">4799</a> of file <a class="el" href="epwm__reg_8h_source.html">epwm_reg.h</a>.</p>

</div>
</div>
<a id="a2083e1da8902a1717ca0968441a8c078" name="a2083e1da8902a1717ca0968441a8c078"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2083e1da8902a1717ca0968441a8c078">&#9670;&nbsp;</a></span>EADCTS0</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">EPWM_T::EADCTS0</td>
        </tr>
      </table>
</div><div class="memdoc">
<p >[0x00f8] EPWM Trigger EADC Source Select Register 0 <br  />
</p>
<p > 

<html><table class="fixed" border="1" style="border-collapse:collapse;" borderColor=black ><col width="75px" /><col width="125px" /><col width="700px" /><caption align="left"><font size="3">EADCTS0
</font><br><p> <font size="2">
Offset: 0xF8  EPWM Trigger EADC Source Select Register 0
</font></caption><thread><tr bgcolor="#8A0808" ><td><font color=white><b>Bits</b></font></td><td><font color=white><b>Field</b></font></td><td><font color=white><b>Descriptions</b></font></td></tr></thread><tbody>
<tr><td>
[3:0]</td><td>TRGSEL0</td><td><div style="word-wrap: break-word;"><b>EPWM_CH0 Trigger EADC Source Select
</b><br>
0000 = EPWM_CH0 zero point.
<br>
0001 = EPWM_CH0 period point.
<br>
0010 = EPWM_CH0 zero or period point.
<br>
0011 = EPWM_CH0 up-count CMPDAT point.
<br>
0100 = EPWM_CH0 down-count CMPDAT point.
<br>
0101 = EPWM_CH1 zero point.
<br>
0110 = EPWM_CH1 period point.
<br>
0111 = EPWM_CH1 zero or period point.
<br>
1000 = EPWM_CH1 up-count CMPDAT point.
<br>
1001 = EPWM_CH1 down-count CMPDAT point.
<br>
1010 = EPWM_CH0 up-count free CMPDAT point.
<br>
1011 = EPWM_CH0 down-count free CMPDAT point.
<br>
1100 = EPWM_CH2 up-count free CMPDAT point.
<br>
1101 = EPWM_CH2 down-count free CMPDAT point.
<br>
1110 = EPWM_CH4 up-count free CMPDAT point.
<br>
1111 = EPWM_CH4 down-count free CMPDAT point.
<br>
</div></td></tr><tr><td>
[7]</td><td>TRGEN0</td><td><div style="word-wrap: break-word;"><b>EPWM_CH0 Trigger EADC enable bit
</b><br>
</div></td></tr><tr><td>
[11:8]</td><td>TRGSEL1</td><td><div style="word-wrap: break-word;"><b>EPWM_CH1 Trigger EADC Source Select
</b><br>
0000 = EPWM_CH0 zero point.
<br>
0001 = EPWM_CH0 period point.
<br>
0010 = EPWM_CH0 zero or period point.
<br>
0011 = EPWM_CH0 up-count CMPDAT point.
<br>
0100 = EPWM_CH0 down-count CMPDAT point.
<br>
0101 = EPWM_CH1 zero point.
<br>
0110 = EPWM_CH1 period point.
<br>
0111 = EPWM_CH1 zero or period point.
<br>
1000 = EPWM_CH1 up-count CMPDAT point.
<br>
1001 = EPWM_CH1 down-count CMPDAT point.
<br>
1010 = EPWM_CH0 up-count free CMPDAT point.
<br>
1011 = EPWM_CH0 down-count free CMPDAT point.
<br>
1100 = EPWM_CH2 up-count free CMPDAT point.
<br>
1101 = EPWM_CH2 down-count free CMPDAT point.
<br>
1110 = EPWM_CH4 up-count free CMPDAT point.
<br>
1111 = EPWM_CH4 down-count free CMPDAT point.
<br>
</div></td></tr><tr><td>
[15]</td><td>TRGEN1</td><td><div style="word-wrap: break-word;"><b>EPWM_CH1 Trigger EADC enable bit
</b><br>
</div></td></tr><tr><td>
[19:16]</td><td>TRGSEL2</td><td><div style="word-wrap: break-word;"><b>EPWM_CH2 Trigger EADC Source Select
</b><br>
0000 = EPWM_CH2 zero point.
<br>
0001 = EPWM_CH2 period point.
<br>
0010 = EPWM_CH2 zero or period point.
<br>
0011 = EPWM_CH2 up-count CMPDAT point.
<br>
0100 = EPWM_CH2 down-count CMPDAT point.
<br>
0101 = EPWM_CH3 zero point.
<br>
0110 = EPWM_CH3 period point.
<br>
0111 = EPWM_CH3 zero or period point.
<br>
1000 = EPWM_CH3 up-count CMPDAT point.
<br>
1001 = EPWM_CH3 down-count CMPDAT point.
<br>
1010 = EPWM_CH0 up-count free CMPDAT point.
<br>
1011 = EPWM_CH0 down-count free CMPDAT point.
<br>
1100 = EPWM_CH2 up-count free CMPDAT point.
<br>
1101 = EPWM_CH2 down-count free CMPDAT point.
<br>
1110 = EPWM_CH4 up-count free CMPDAT point.
<br>
1111 = EPWM_CH4 down-count free CMPDAT point.
<br>
</div></td></tr><tr><td>
[23]</td><td>TRGEN2</td><td><div style="word-wrap: break-word;"><b>EPWM_CH2 Trigger EADC enable bit
</b><br>
</div></td></tr><tr><td>
[27:24]</td><td>TRGSEL3</td><td><div style="word-wrap: break-word;"><b>EPWM_CH3 Trigger EADC Source Select
</b><br>
0000 = EPWM_CH2 zero point.
<br>
0001 = EPWM_CH2 period point.
<br>
0010 = EPWM_CH2 zero or period point.
<br>
0011 = EPWM_CH2 up-count CMPDAT point.
<br>
0100 = EPWM_CH2 down-count CMPDAT point.
<br>
0101 = EPWM_CH3 zero point.
<br>
0110 = EPWM_CH3 period point.
<br>
0111 = EPWM_CH3 zero or period point.
<br>
1000 = EPWM_CH3 up-count CMPDAT point.
<br>
1001 = EPWM_CH3 down-count CMPDAT point.
<br>
1010 = EPWM_CH0 up-count free CMPDAT point.
<br>
1011 = EPWM_CH0 down-count free CMPDAT point.
<br>
1100 = EPWM_CH2 up-count free CMPDAT point.
<br>
1101 = EPWM_CH2 down-count free CMPDAT point.
<br>
1110 = EPWM_CH4 up-count free CMPDAT point.
<br>
1111 = EPWM_CH4 down-count free CMPDAT point.
<br>
</div></td></tr><tr><td>
[31]</td><td>TRGEN3</td><td><div style="word-wrap: break-word;"><b>EPWM_CH3 Trigger EADC enable bit
</b><br>
</div></td></tr></tbody></table></html>

 </p>

<p class="definition">Definition at line <a class="el" href="epwm__reg_8h_source.html#l04767">4767</a> of file <a class="el" href="epwm__reg_8h_source.html">epwm_reg.h</a>.</p>

</div>
</div>
<a id="a4d8548edd2bddc6db90d8cda12032bc8" name="a4d8548edd2bddc6db90d8cda12032bc8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4d8548edd2bddc6db90d8cda12032bc8">&#9670;&nbsp;</a></span>EADCTS1</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">EPWM_T::EADCTS1</td>
        </tr>
      </table>
</div><div class="memdoc">
<p >[0x00fc] EPWM Trigger EADC Source Select Register 1 <br  />
</p>
<p > 

<html><table class="fixed" border="1" style="border-collapse:collapse;" borderColor=black ><col width="75px" /><col width="125px" /><col width="700px" /><caption align="left"><font size="3">EADCTS1
</font><br><p> <font size="2">
Offset: 0xFC  EPWM Trigger EADC Source Select Register 1
</font></caption><thread><tr bgcolor="#8A0808" ><td><font color=white><b>Bits</b></font></td><td><font color=white><b>Field</b></font></td><td><font color=white><b>Descriptions</b></font></td></tr></thread><tbody>
<tr><td>
[3:0]</td><td>TRGSEL4</td><td><div style="word-wrap: break-word;"><b>EPWM_CH4 Trigger EADC Source Select
</b><br>
0000 = EPWM_CH4 zero point.
<br>
0001 = EPWM_CH4 period point.
<br>
0010 = EPWM_CH4 zero or period point.
<br>
0011 = EPWM_CH4 up-count CMPDAT point.
<br>
0100 = EPWM_CH4 down-count CMPDAT point.
<br>
0101 = EPWM_CH5 zero point.
<br>
0110 = EPWM_CH5 period point.
<br>
0111 = EPWM_CH5 zero or period point.
<br>
1000 = EPWM_CH5 up-count CMPDAT point.
<br>
1001 = EPWM_CH5 down-count CMPDAT point.
<br>
1010 = EPWM_CH0 up-count free CMPDAT point.
<br>
1011 = EPWM_CH0 down-count free CMPDAT point.
<br>
1100 = EPWM_CH2 up-count free CMPDAT point.
<br>
1101 = EPWM_CH2 down-count free CMPDAT point.
<br>
1110 = EPWM_CH4 up-count free CMPDAT point.
<br>
1111 = EPWM_CH4 down-count free CMPDAT point.
<br>
</div></td></tr><tr><td>
[7]</td><td>TRGEN4</td><td><div style="word-wrap: break-word;"><b>EPWM_CH4 Trigger EADC enable bit
</b><br>
</div></td></tr><tr><td>
[11:8]</td><td>TRGSEL5</td><td><div style="word-wrap: break-word;"><b>EPWM_CH5 Trigger EADC Source Select
</b><br>
0000 = EPWM_CH4 zero point.
<br>
0001 = EPWM_CH4 period point.
<br>
0010 = EPWM_CH4 zero or period point.
<br>
0011 = EPWM_CH4 up-count CMPDAT point.
<br>
0100 = EPWM_CH4 down-count CMPDAT point.
<br>
0101 = EPWM_CH5 zero point.
<br>
0110 = EPWM_CH5 period point.
<br>
0111 = EPWM_CH5 zero or period point.
<br>
1000 = EPWM_CH5 up-count CMPDAT point.
<br>
1001 = EPWM_CH5 down-count CMPDAT point.
<br>
1010 = EPWM_CH0 up-count free CMPDAT point.
<br>
1011 = EPWM_CH0 down-count free CMPDAT point.
<br>
1100 = EPWM_CH2 up-count free CMPDAT point.
<br>
1101 = EPWM_CH2 down-count free CMPDAT point.
<br>
1110 = EPWM_CH4 up-count free CMPDAT point.
<br>
1111 = EPWM_CH4 down-count free CMPDAT point.
<br>
</div></td></tr><tr><td>
[15]</td><td>TRGEN5</td><td><div style="word-wrap: break-word;"><b>EPWM_CH5 Trigger EADC enable bit
</b><br>
</div></td></tr></tbody></table></html>

 </p>

<p class="definition">Definition at line <a class="el" href="epwm__reg_8h_source.html#l04768">4768</a> of file <a class="el" href="epwm__reg_8h_source.html">epwm_reg.h</a>.</p>

</div>
</div>
<a id="aaafde4645853ebcfd2d4bd6a1b37aaeb" name="aaafde4645853ebcfd2d4bd6a1b37aaeb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaafde4645853ebcfd2d4bd6a1b37aaeb">&#9670;&nbsp;</a></span>FAILBRK</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">EPWM_T::FAILBRK</td>
        </tr>
      </table>
</div><div class="memdoc">
<p >[0x00c4] EPWM System Fail Brake Control Register <br  />
</p>
<p > 

<html><table class="fixed" border="1" style="border-collapse:collapse;" borderColor=black ><col width="75px" /><col width="125px" /><col width="700px" /><caption align="left"><font size="3">FAILBRK
</font><br><p> <font size="2">
Offset: 0xC4  EPWM System Fail Brake Control Register
</font></caption><thread><tr bgcolor="#8A0808" ><td><font color=white><b>Bits</b></font></td><td><font color=white><b>Field</b></font></td><td><font color=white><b>Descriptions</b></font></td></tr></thread><tbody>
<tr><td>
[0]</td><td>CSSBRKEN</td><td><div style="word-wrap: break-word;"><b>Clock Security System Detection Trigger EPWM Brake Function 0 Enable Bit
</b><br>
0 = Brake Function triggered by CSS detection Disabled.
<br>
1 = Brake Function triggered by CSS detection Enabled.
<br>
</div></td></tr><tr><td>
[1]</td><td>BODBRKEN</td><td><div style="word-wrap: break-word;"><b>Brown-out Detection Trigger EPWM Brake Function 0 Enable Bit
</b><br>
0 = Brake Function triggered by BOD Disabled.
<br>
1 = Brake Function triggered by BOD Enabled.
<br>
</div></td></tr><tr><td>
[2]</td><td>RAMBRKEN</td><td><div style="word-wrap: break-word;"><b>SRAM Parity Error Detection Trigger EPWM Brake Function 0 Enable Bit
</b><br>
0 = Brake Function triggered by SRAM parity error detection Disabled.
<br>
1 = Brake Function triggered by SRAM parity error detection Enabled.
<br>
</div></td></tr><tr><td>
[3]</td><td>CORBRKEN</td><td><div style="word-wrap: break-word;"><b>Core Lockup Detection Trigger EPWM Brake Function 0 Enable Bit
</b><br>
0 = Brake Function triggered by Core lockup detection Disabled.
<br>
1 = Brake Function triggered by Core lockup detection Enabled.
<br>
</div></td></tr></tbody></table></html>

 </p>

<p class="definition">Definition at line <a class="el" href="epwm__reg_8h_source.html#l04754">4754</a> of file <a class="el" href="epwm__reg_8h_source.html">epwm_reg.h</a>.</p>

</div>
</div>
<a id="a1e314303fd0e177993bb6223bfd7d067" name="a1e314303fd0e177993bb6223bfd7d067"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1e314303fd0e177993bb6223bfd7d067">&#9670;&nbsp;</a></span>FDCTL</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__IO uint32_t EPWM_T::FDCTL[6]</td>
        </tr>
      </table>
</div><div class="memdoc">
<p >[0x0164~0x178] EPWM Fault Detect Control Register 0~5 <br  />
 </p>

<p class="definition">Definition at line <a class="el" href="epwm__reg_8h_source.html#l04792">4792</a> of file <a class="el" href="epwm__reg_8h_source.html">epwm_reg.h</a>.</p>

</div>
</div>
<a id="a90190c2bd39ff8f6fcb92b1668bc1793" name="a90190c2bd39ff8f6fcb92b1668bc1793"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a90190c2bd39ff8f6fcb92b1668bc1793">&#9670;&nbsp;</a></span>FDEN</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__IO uint32_t EPWM_T::FDEN</td>
        </tr>
      </table>
</div><div class="memdoc">
<p >[0x0160] EPWM Fault Detect Enable Register <br  />
 </p>

<p class="definition">Definition at line <a class="el" href="epwm__reg_8h_source.html#l04791">4791</a> of file <a class="el" href="epwm__reg_8h_source.html">epwm_reg.h</a>.</p>

</div>
</div>
<a id="a8680c0b32d475cd4df0d7ce50bb5365a" name="a8680c0b32d475cd4df0d7ce50bb5365a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8680c0b32d475cd4df0d7ce50bb5365a">&#9670;&nbsp;</a></span>FDIEN</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__IO uint32_t EPWM_T::FDIEN</td>
        </tr>
      </table>
</div><div class="memdoc">
<p >[0x017C] EPWM Fault Detect Interrupt Enable Register <br  />
 </p>

<p class="definition">Definition at line <a class="el" href="epwm__reg_8h_source.html#l04793">4793</a> of file <a class="el" href="epwm__reg_8h_source.html">epwm_reg.h</a>.</p>

</div>
</div>
<a id="a43c6be6a727eb60307f72c476ca58eff" name="a43c6be6a727eb60307f72c476ca58eff"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a43c6be6a727eb60307f72c476ca58eff">&#9670;&nbsp;</a></span>FDSTS</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__IO uint32_t EPWM_T::FDSTS</td>
        </tr>
      </table>
</div><div class="memdoc">
<p >[0x0180] EPWM Fault Detect Interrupt Flag Register <br  />
 </p>

<p class="definition">Definition at line <a class="el" href="epwm__reg_8h_source.html#l04794">4794</a> of file <a class="el" href="epwm__reg_8h_source.html">epwm_reg.h</a>.</p>

</div>
</div>
<a id="a3aeb1fe9b7398283bd30499fd30fc5a5" name="a3aeb1fe9b7398283bd30499fd30fc5a5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3aeb1fe9b7398283bd30499fd30fc5a5">&#9670;&nbsp;</a></span>FTCBUF</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">EPWM_T::FTCBUF[3]</td>
        </tr>
      </table>
</div><div class="memdoc">
<p >[0x0340] EPWM FTCMPDAT0_1/2_3/4_5 Buffer <br  />
</p>
<p > 

<html><table class="fixed" border="1" style="border-collapse:collapse;" borderColor=black ><col width="75px" /><col width="125px" /><col width="700px" /><caption align="left"><font size="3">FTCBUF[3]
</font><br><p> <font size="2">
Offset: 0x340  EPWM FTCMPDAT0_1/2_3/4_5 Buffer
</font></caption><thread><tr bgcolor="#8A0808" ><td><font color=white><b>Bits</b></font></td><td><font color=white><b>Field</b></font></td><td><font color=white><b>Descriptions</b></font></td></tr></thread><tbody>
<tr><td>
[15:0]</td><td>FTCMPBUF</td><td><div style="word-wrap: break-word;"><b>EPWM FTCMPDAT Buffer (Read Only)
</b><br>
Used as FTCMPDAT active register.
<br>
</div></td></tr></tbody></table></html>

 </p>

<p class="definition">Definition at line <a class="el" href="epwm__reg_8h_source.html#l04820">4820</a> of file <a class="el" href="epwm__reg_8h_source.html">epwm_reg.h</a>.</p>

</div>
</div>
<a id="a2a2bf0d1fa9e150be77816f682da9dbf" name="a2a2bf0d1fa9e150be77816f682da9dbf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2a2bf0d1fa9e150be77816f682da9dbf">&#9670;&nbsp;</a></span>FTCI</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">EPWM_T::FTCI</td>
        </tr>
      </table>
</div><div class="memdoc">
<p >[0x034c] EPWM FTCMPDAT Indicator Register <br  />
</p>
<p > 

<html><table class="fixed" border="1" style="border-collapse:collapse;" borderColor=black ><col width="75px" /><col width="125px" /><col width="700px" /><caption align="left"><font size="3">FTCI
</font><br><p> <font size="2">
Offset: 0x34C  EPWM FTCMPDAT Indicator Register
</font></caption><thread><tr bgcolor="#8A0808" ><td><font color=white><b>Bits</b></font></td><td><font color=white><b>Field</b></font></td><td><font color=white><b>Descriptions</b></font></td></tr></thread><tbody>
<tr><td>
[0]</td><td>FTCMU0</td><td><div style="word-wrap: break-word;"><b>EPWM FTCMPDAT Up Indicator
</b><br>
Indicator will be set to high when FTCMPDATn equal to CNTn and DIRF=1, software can write 1 to clear this bit.
<br>
</div></td></tr><tr><td>
[1]</td><td>FTCMU2</td><td><div style="word-wrap: break-word;"><b>EPWM FTCMPDAT Up Indicator
</b><br>
Indicator will be set to high when FTCMPDATn equal to CNTn and DIRF=1, software can write 1 to clear this bit.
<br>
</div></td></tr><tr><td>
[2]</td><td>FTCMU4</td><td><div style="word-wrap: break-word;"><b>EPWM FTCMPDAT Up Indicator
</b><br>
Indicator will be set to high when FTCMPDATn equal to CNTn and DIRF=1, software can write 1 to clear this bit.
<br>
</div></td></tr><tr><td>
[8]</td><td>FTCMD0</td><td><div style="word-wrap: break-word;"><b>EPWM FTCMPDAT Down Indicator
</b><br>
Indicator will be set to high when FTCMPDATn equal to CNTn and DIRF=0, software can write 1 to clear this bit.
<br>
</div></td></tr><tr><td>
[9]</td><td>FTCMD2</td><td><div style="word-wrap: break-word;"><b>EPWM FTCMPDAT Down Indicator
</b><br>
Indicator will be set to high when FTCMPDATn equal to CNTn and DIRF=0, software can write 1 to clear this bit.
<br>
</div></td></tr><tr><td>
[10]</td><td>FTCMD4</td><td><div style="word-wrap: break-word;"><b>EPWM FTCMPDAT Down Indicator
</b><br>
Indicator will be set to high when FTCMPDATn equal to CNTn and DIRF=0, software can write 1 to clear this bit.
<br>
</div></td></tr></tbody></table></html>

 </p>

<p class="definition">Definition at line <a class="el" href="epwm__reg_8h_source.html#l04821">4821</a> of file <a class="el" href="epwm__reg_8h_source.html">epwm_reg.h</a>.</p>

</div>
</div>
<a id="aacba8b9a1005bb376cb5f1420647aefc" name="aacba8b9a1005bb376cb5f1420647aefc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aacba8b9a1005bb376cb5f1420647aefc">&#9670;&nbsp;</a></span>FTCMPDAT</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">EPWM_T::FTCMPDAT[3]</td>
        </tr>
      </table>
</div><div class="memdoc">
<p >[0x0100] EPWM Free Trigger Compare Register 0/1,2/3,4/5 <br  />
</p>
<p > 

<html><table class="fixed" border="1" style="border-collapse:collapse;" borderColor=black ><col width="75px" /><col width="125px" /><col width="700px" /><caption align="left"><font size="3">FTCMPDAT[3]
</font><br><p> <font size="2">
Offset: 0x100  EPWM Free Trigger Compare Register 0/1,2/3,4/5
</font></caption><thread><tr bgcolor="#8A0808" ><td><font color=white><b>Bits</b></font></td><td><font color=white><b>Field</b></font></td><td><font color=white><b>Descriptions</b></font></td></tr></thread><tbody>
<tr><td>
[15:0]</td><td>FTCMP</td><td><div style="word-wrap: break-word;"><b>EPWM Free Trigger Compare Register
</b><br>
FTCMP use to compare with even CNTR to trigger EADC
<br>
FTCMPDAT0, 2, 4 corresponding complementary pairs EPWM_CH0 and EPWM_CH1, EPWM_CH2 and EPWM_CH3, EPWM_CH4 and EPWM_CH5.
<br>
</div></td></tr></tbody></table></html>

 </p>

<p class="definition">Definition at line <a class="el" href="epwm__reg_8h_source.html#l04769">4769</a> of file <a class="el" href="epwm__reg_8h_source.html">epwm_reg.h</a>.</p>

</div>
</div>
<a id="a55af089b93404f05e2ae70bf920ebad1" name="a55af089b93404f05e2ae70bf920ebad1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a55af089b93404f05e2ae70bf920ebad1">&#9670;&nbsp;</a></span>IFA</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">EPWM_T::IFA[6]</td>
        </tr>
      </table>
</div><div class="memdoc">
<p >[0x0130] EPWM Interrupt Flag Accumulator Register 0~5 <br  />
</p>
<p > 

<html><table class="fixed" border="1" style="border-collapse:collapse;" borderColor=black ><col width="75px" /><col width="125px" /><col width="700px" /><caption align="left"><font size="3">IFA[6]
</font><br><p> <font size="2">
Offset: 0x130  EPWM Interrupt Flag Accumulator Register 0~5
</font></caption><thread><tr bgcolor="#8A0808" ><td><font color=white><b>Bits</b></font></td><td><font color=white><b>Field</b></font></td><td><font color=white><b>Descriptions</b></font></td></tr></thread><tbody>
<tr><td>
[15:0]</td><td>IFACNT</td><td><div style="word-wrap: break-word;"><b>EPWM_CHn Interrupt Flag Counter
</b><br>
The register sets the count number which defines how many times of EPWM_CHn period occurs to set bit IFAIFn to request the EPWM period interrupt.
<br>
EPWM flag will be set in every IFACNT[15:0] times of EPWM period.
<br>
</div></td></tr><tr><td>
[24]</td><td>STPMOD</td><td><div style="word-wrap: break-word;"><b>EPWM_CHn Interrupt Flag Accumulator Stop Mode Enable Bits
</b><br>
0 = EPWM_CHn interrupt flag accumulator stop mode disable.
<br>
1 = EPWM_CHn interrupt flag accumulator stop mode enable.
<br>
</div></td></tr><tr><td>
[29:28]</td><td>IFASEL</td><td><div style="word-wrap: break-word;"><b>EPWM_CHn Interrupt Flag Accumulator Source Select
</b><br>
00 = CNT equal to Zero in channel n.
<br>
01 = CNT equal to PERIOD in channel n.
<br>
10 = CNT equal to CMPU in channel n.
<br>
11 = CNT equal to CMPD in channel n.
<br>
</div></td></tr><tr><td>
[31]</td><td>IFAEN</td><td><div style="word-wrap: break-word;"><b>EPWM_CHn Interrupt Flag Accumulator Enable Bits
</b><br>
0 = EPWM_CHn interrupt flag accumulator disable.
<br>
1 = EPWM_CHn interrupt flag accumulator enable.
<br>
</div></td></tr></tbody></table></html>

 </p>

<p class="definition">Definition at line <a class="el" href="epwm__reg_8h_source.html#l04781">4781</a> of file <a class="el" href="epwm__reg_8h_source.html">epwm_reg.h</a>.</p>

</div>
</div>
<a id="ac30d912d6f73186575d642cb21054c8b" name="ac30d912d6f73186575d642cb21054c8b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac30d912d6f73186575d642cb21054c8b">&#9670;&nbsp;</a></span>INTEN0</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">EPWM_T::INTEN0</td>
        </tr>
      </table>
</div><div class="memdoc">
<p >[0x00e0] EPWM Interrupt Enable Register 0 <br  />
</p>
<p > 

<html><table class="fixed" border="1" style="border-collapse:collapse;" borderColor=black ><col width="75px" /><col width="125px" /><col width="700px" /><caption align="left"><font size="3">INTEN0
</font><br><p> <font size="2">
Offset: 0xE0  EPWM Interrupt Enable Register 0
</font></caption><thread><tr bgcolor="#8A0808" ><td><font color=white><b>Bits</b></font></td><td><font color=white><b>Field</b></font></td><td><font color=white><b>Descriptions</b></font></td></tr></thread><tbody>
<tr><td>
[0]</td><td>ZIEN0</td><td><div style="word-wrap: break-word;"><b>EPWM Zero Point Interrupt Enable Bits
</b><br>
0 = Zero point interrupt Disabled.
<br>
1 = Zero point interrupt Enabled.
<br>
Note: Odd channels will read always 0 at complementary mode.
<br>
</div></td></tr><tr><td>
[1]</td><td>ZIEN1</td><td><div style="word-wrap: break-word;"><b>EPWM Zero Point Interrupt Enable Bits
</b><br>
0 = Zero point interrupt Disabled.
<br>
1 = Zero point interrupt Enabled.
<br>
Note: Odd channels will read always 0 at complementary mode.
<br>
</div></td></tr><tr><td>
[2]</td><td>ZIEN2</td><td><div style="word-wrap: break-word;"><b>EPWM Zero Point Interrupt Enable Bits
</b><br>
0 = Zero point interrupt Disabled.
<br>
1 = Zero point interrupt Enabled.
<br>
Note: Odd channels will read always 0 at complementary mode.
<br>
</div></td></tr><tr><td>
[3]</td><td>ZIEN3</td><td><div style="word-wrap: break-word;"><b>EPWM Zero Point Interrupt Enable Bits
</b><br>
0 = Zero point interrupt Disabled.
<br>
1 = Zero point interrupt Enabled.
<br>
Note: Odd channels will read always 0 at complementary mode.
<br>
</div></td></tr><tr><td>
[4]</td><td>ZIEN4</td><td><div style="word-wrap: break-word;"><b>EPWM Zero Point Interrupt Enable Bits
</b><br>
0 = Zero point interrupt Disabled.
<br>
1 = Zero point interrupt Enabled.
<br>
Note: Odd channels will read always 0 at complementary mode.
<br>
</div></td></tr><tr><td>
[5]</td><td>ZIEN5</td><td><div style="word-wrap: break-word;"><b>EPWM Zero Point Interrupt Enable Bits
</b><br>
0 = Zero point interrupt Disabled.
<br>
1 = Zero point interrupt Enabled.
<br>
Note: Odd channels will read always 0 at complementary mode.
<br>
</div></td></tr><tr><td>
[8]</td><td>PIEN0</td><td><div style="word-wrap: break-word;"><b>EPWM Period Point Interrupt Enable Bits
</b><br>
0 = Period point interrupt Disabled.
<br>
1 = Period point interrupt Enabled.
<br>
Note1: When up-down counter type period point means center point.
<br>
Note2: Odd channels will read always 0 at complementary mode.
<br>
</div></td></tr><tr><td>
[9]</td><td>PIEN1</td><td><div style="word-wrap: break-word;"><b>EPWM Period Point Interrupt Enable Bits
</b><br>
0 = Period point interrupt Disabled.
<br>
1 = Period point interrupt Enabled.
<br>
Note1: When up-down counter type period point means center point.
<br>
Note2: Odd channels will read always 0 at complementary mode.
<br>
</div></td></tr><tr><td>
[10]</td><td>PIEN2</td><td><div style="word-wrap: break-word;"><b>EPWM Period Point Interrupt Enable Bits
</b><br>
0 = Period point interrupt Disabled.
<br>
1 = Period point interrupt Enabled.
<br>
Note1: When up-down counter type period point means center point.
<br>
Note2: Odd channels will read always 0 at complementary mode.
<br>
</div></td></tr><tr><td>
[11]</td><td>PIEN3</td><td><div style="word-wrap: break-word;"><b>EPWM Period Point Interrupt Enable Bits
</b><br>
0 = Period point interrupt Disabled.
<br>
1 = Period point interrupt Enabled.
<br>
Note1: When up-down counter type period point means center point.
<br>
Note2: Odd channels will read always 0 at complementary mode.
<br>
</div></td></tr><tr><td>
[12]</td><td>PIEN4</td><td><div style="word-wrap: break-word;"><b>EPWM Period Point Interrupt Enable Bits
</b><br>
0 = Period point interrupt Disabled.
<br>
1 = Period point interrupt Enabled.
<br>
Note1: When up-down counter type period point means center point.
<br>
Note2: Odd channels will read always 0 at complementary mode.
<br>
</div></td></tr><tr><td>
[13]</td><td>PIEN5</td><td><div style="word-wrap: break-word;"><b>EPWM Period Point Interrupt Enable Bits
</b><br>
0 = Period point interrupt Disabled.
<br>
1 = Period point interrupt Enabled.
<br>
Note1: When up-down counter type period point means center point.
<br>
Note2: Odd channels will read always 0 at complementary mode.
<br>
</div></td></tr><tr><td>
[16]</td><td>CMPUIEN0</td><td><div style="word-wrap: break-word;"><b>EPWM Compare Up Count Interrupt Enable Bits
</b><br>
0 = Compare up count interrupt Disabled.
<br>
1 = Compare up count interrupt Enabled.
<br>
Note: In complementary mode, CMPUIEN1, 3, 5 use as another CMPUIEN for channel 0, 2, 4.
<br>
</div></td></tr><tr><td>
[17]</td><td>CMPUIEN1</td><td><div style="word-wrap: break-word;"><b>EPWM Compare Up Count Interrupt Enable Bits
</b><br>
0 = Compare up count interrupt Disabled.
<br>
1 = Compare up count interrupt Enabled.
<br>
Note: In complementary mode, CMPUIEN1, 3, 5 use as another CMPUIEN for channel 0, 2, 4.
<br>
</div></td></tr><tr><td>
[18]</td><td>CMPUIEN2</td><td><div style="word-wrap: break-word;"><b>EPWM Compare Up Count Interrupt Enable Bits
</b><br>
0 = Compare up count interrupt Disabled.
<br>
1 = Compare up count interrupt Enabled.
<br>
Note: In complementary mode, CMPUIEN1, 3, 5 use as another CMPUIEN for channel 0, 2, 4.
<br>
</div></td></tr><tr><td>
[19]</td><td>CMPUIEN3</td><td><div style="word-wrap: break-word;"><b>EPWM Compare Up Count Interrupt Enable Bits
</b><br>
0 = Compare up count interrupt Disabled.
<br>
1 = Compare up count interrupt Enabled.
<br>
Note: In complementary mode, CMPUIEN1, 3, 5 use as another CMPUIEN for channel 0, 2, 4.
<br>
</div></td></tr><tr><td>
[20]</td><td>CMPUIEN4</td><td><div style="word-wrap: break-word;"><b>EPWM Compare Up Count Interrupt Enable Bits
</b><br>
0 = Compare up count interrupt Disabled.
<br>
1 = Compare up count interrupt Enabled.
<br>
Note: In complementary mode, CMPUIEN1, 3, 5 use as another CMPUIEN for channel 0, 2, 4.
<br>
</div></td></tr><tr><td>
[21]</td><td>CMPUIEN5</td><td><div style="word-wrap: break-word;"><b>EPWM Compare Up Count Interrupt Enable Bits
</b><br>
0 = Compare up count interrupt Disabled.
<br>
1 = Compare up count interrupt Enabled.
<br>
Note: In complementary mode, CMPUIEN1, 3, 5 use as another CMPUIEN for channel 0, 2, 4.
<br>
</div></td></tr><tr><td>
[24]</td><td>CMPDIEN0</td><td><div style="word-wrap: break-word;"><b>EPWM Compare Down Count Interrupt Enable Bits
</b><br>
0 = Compare down count interrupt Disabled.
<br>
1 = Compare down count interrupt Enabled.
<br>
Note: In complementary mode, CMPDIEN1, 3, 5 use as another CMPDIEN for channel 0, 2, 4.
<br>
</div></td></tr><tr><td>
[25]</td><td>CMPDIEN1</td><td><div style="word-wrap: break-word;"><b>EPWM Compare Down Count Interrupt Enable Bits
</b><br>
0 = Compare down count interrupt Disabled.
<br>
1 = Compare down count interrupt Enabled.
<br>
Note: In complementary mode, CMPDIEN1, 3, 5 use as another CMPDIEN for channel 0, 2, 4.
<br>
</div></td></tr><tr><td>
[26]</td><td>CMPDIEN2</td><td><div style="word-wrap: break-word;"><b>EPWM Compare Down Count Interrupt Enable Bits
</b><br>
0 = Compare down count interrupt Disabled.
<br>
1 = Compare down count interrupt Enabled.
<br>
Note: In complementary mode, CMPDIEN1, 3, 5 use as another CMPDIEN for channel 0, 2, 4.
<br>
</div></td></tr><tr><td>
[27]</td><td>CMPDIEN3</td><td><div style="word-wrap: break-word;"><b>EPWM Compare Down Count Interrupt Enable Bits
</b><br>
0 = Compare down count interrupt Disabled.
<br>
1 = Compare down count interrupt Enabled.
<br>
Note: In complementary mode, CMPDIEN1, 3, 5 use as another CMPDIEN for channel 0, 2, 4.
<br>
</div></td></tr><tr><td>
[28]</td><td>CMPDIEN4</td><td><div style="word-wrap: break-word;"><b>EPWM Compare Down Count Interrupt Enable Bits
</b><br>
0 = Compare down count interrupt Disabled.
<br>
1 = Compare down count interrupt Enabled.
<br>
Note: In complementary mode, CMPDIEN1, 3, 5 use as another CMPDIEN for channel 0, 2, 4.
<br>
</div></td></tr><tr><td>
[29]</td><td>CMPDIEN5</td><td><div style="word-wrap: break-word;"><b>EPWM Compare Down Count Interrupt Enable Bits
</b><br>
0 = Compare down count interrupt Disabled.
<br>
1 = Compare down count interrupt Enabled.
<br>
Note: In complementary mode, CMPDIEN1, 3, 5 use as another CMPDIEN for channel 0, 2, 4.
<br>
</div></td></tr></tbody></table></html>

 </p>

<p class="definition">Definition at line <a class="el" href="epwm__reg_8h_source.html#l04759">4759</a> of file <a class="el" href="epwm__reg_8h_source.html">epwm_reg.h</a>.</p>

</div>
</div>
<a id="a7f1f5c00628e57d5bd685ce576d0541e" name="a7f1f5c00628e57d5bd685ce576d0541e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7f1f5c00628e57d5bd685ce576d0541e">&#9670;&nbsp;</a></span>INTEN1</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">EPWM_T::INTEN1</td>
        </tr>
      </table>
</div><div class="memdoc">
<p >[0x00e4] EPWM Interrupt Enable Register 1 <br  />
</p>
<p > 

<html><table class="fixed" border="1" style="border-collapse:collapse;" borderColor=black ><col width="75px" /><col width="125px" /><col width="700px" /><caption align="left"><font size="3">INTEN1
</font><br><p> <font size="2">
Offset: 0xE4  EPWM Interrupt Enable Register 1
</font></caption><thread><tr bgcolor="#8A0808" ><td><font color=white><b>Bits</b></font></td><td><font color=white><b>Field</b></font></td><td><font color=white><b>Descriptions</b></font></td></tr></thread><tbody>
<tr><td>
[0]</td><td>BRKEIEN0_1</td><td><div style="word-wrap: break-word;"><b>EPWM Edge-detect Brake Interrupt Enable for Channel0/1 (Write Protect)
</b><br>
0 = Edge-detect Brake interrupt for channel0/1 Disabled.
<br>
1 = Edge-detect Brake interrupt for channel0/1 Enabled.
<br>
Note: This register is write protected. Refer toSYS_REGLCTL register.
<br>
</div></td></tr><tr><td>
[1]</td><td>BRKEIEN2_3</td><td><div style="word-wrap: break-word;"><b>EPWM Edge-detect Brake Interrupt Enable for Channel2/3 (Write Protect)
</b><br>
0 = Edge-detect Brake interrupt for channel2/3 Disabled.
<br>
1 = Edge-detect Brake interrupt for channel2/3 Enabled.
<br>
Note: This register is write protected. Refer toSYS_REGLCTL register.
<br>
</div></td></tr><tr><td>
[2]</td><td>BRKEIEN4_5</td><td><div style="word-wrap: break-word;"><b>EPWM Edge-detect Brake Interrupt Enable for Channel4/5 (Write Protect)
</b><br>
0 = Edge-detect Brake interrupt for channel4/5 Disabled.
<br>
1 = Edge-detect Brake interrupt for channel4/5 Enabled.
<br>
Note: This register is write protected. Refer toSYS_REGLCTL register.
<br>
</div></td></tr><tr><td>
[8]</td><td>BRKLIEN0_1</td><td><div style="word-wrap: break-word;"><b>EPWM Level-detect Brake Interrupt Enable for Channel0/1 (Write Protect)
</b><br>
0 = Level-detect Brake interrupt for channel0/1 Disabled.
<br>
1 = Level-detect Brake interrupt for channel0/1 Enabled.
<br>
Note: This register is write protected. Refer toSYS_REGLCTL register.
<br>
</div></td></tr><tr><td>
[9]</td><td>BRKLIEN2_3</td><td><div style="word-wrap: break-word;"><b>EPWM Level-detect Brake Interrupt Enable for Channel2/3 (Write Protect)
</b><br>
0 = Level-detect Brake interrupt for channel2/3 Disabled.
<br>
1 = Level-detect Brake interrupt for channel2/3 Enabled.
<br>
Note: This register is write protected. Refer toSYS_REGLCTL register.
<br>
</div></td></tr><tr><td>
[10]</td><td>BRKLIEN4_5</td><td><div style="word-wrap: break-word;"><b>EPWM Level-detect Brake Interrupt Enable for Channel4/5 (Write Protect)
</b><br>
0 = Level-detect Brake interrupt for channel4/5 Disabled.
<br>
1 = Level-detect Brake interrupt for channel4/5 Enabled.
<br>
Note: This register is write protected. Refer toSYS_REGLCTL register.
<br>
</div></td></tr></tbody></table></html>

 </p>

<p class="definition">Definition at line <a class="el" href="epwm__reg_8h_source.html#l04760">4760</a> of file <a class="el" href="epwm__reg_8h_source.html">epwm_reg.h</a>.</p>

</div>
</div>
<a id="ac4525812584da5c59bba9add04679d70" name="ac4525812584da5c59bba9add04679d70"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac4525812584da5c59bba9add04679d70">&#9670;&nbsp;</a></span>INTSTS0</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">EPWM_T::INTSTS0</td>
        </tr>
      </table>
</div><div class="memdoc">
<p >[0x00e8] EPWM Interrupt Flag Register 0 <br  />
</p>
<p > 

<html><table class="fixed" border="1" style="border-collapse:collapse;" borderColor=black ><col width="75px" /><col width="125px" /><col width="700px" /><caption align="left"><font size="3">INTSTS0
</font><br><p> <font size="2">
Offset: 0xE8  EPWM Interrupt Flag Register 0
</font></caption><thread><tr bgcolor="#8A0808" ><td><font color=white><b>Bits</b></font></td><td><font color=white><b>Field</b></font></td><td><font color=white><b>Descriptions</b></font></td></tr></thread><tbody>
<tr><td>
[0]</td><td>ZIF0</td><td><div style="word-wrap: break-word;"><b>EPWM Zero Point Interrupt Flag
</b><br>
This bit is set by hardware when EPWM counter reaches zero, software can write 1 to clear this bit to zero.
<br>
</div></td></tr><tr><td>
[1]</td><td>ZIF1</td><td><div style="word-wrap: break-word;"><b>EPWM Zero Point Interrupt Flag
</b><br>
This bit is set by hardware when EPWM counter reaches zero, software can write 1 to clear this bit to zero.
<br>
</div></td></tr><tr><td>
[2]</td><td>ZIF2</td><td><div style="word-wrap: break-word;"><b>EPWM Zero Point Interrupt Flag
</b><br>
This bit is set by hardware when EPWM counter reaches zero, software can write 1 to clear this bit to zero.
<br>
</div></td></tr><tr><td>
[3]</td><td>ZIF3</td><td><div style="word-wrap: break-word;"><b>EPWM Zero Point Interrupt Flag
</b><br>
This bit is set by hardware when EPWM counter reaches zero, software can write 1 to clear this bit to zero.
<br>
</div></td></tr><tr><td>
[4]</td><td>ZIF4</td><td><div style="word-wrap: break-word;"><b>EPWM Zero Point Interrupt Flag
</b><br>
This bit is set by hardware when EPWM counter reaches zero, software can write 1 to clear this bit to zero.
<br>
</div></td></tr><tr><td>
[5]</td><td>ZIF5</td><td><div style="word-wrap: break-word;"><b>EPWM Zero Point Interrupt Flag
</b><br>
This bit is set by hardware when EPWM counter reaches zero, software can write 1 to clear this bit to zero.
<br>
</div></td></tr><tr><td>
[8]</td><td>PIF0</td><td><div style="word-wrap: break-word;"><b>EPWM Period Point Interrupt Flag
</b><br>
This bit is set by hardware when EPWM counter reaches EPWM_PERIODn, software can write 1 to clear this bit to zero.
<br>
</div></td></tr><tr><td>
[9]</td><td>PIF1</td><td><div style="word-wrap: break-word;"><b>EPWM Period Point Interrupt Flag
</b><br>
This bit is set by hardware when EPWM counter reaches EPWM_PERIODn, software can write 1 to clear this bit to zero.
<br>
</div></td></tr><tr><td>
[10]</td><td>PIF2</td><td><div style="word-wrap: break-word;"><b>EPWM Period Point Interrupt Flag
</b><br>
This bit is set by hardware when EPWM counter reaches EPWM_PERIODn, software can write 1 to clear this bit to zero.
<br>
</div></td></tr><tr><td>
[11]</td><td>PIF3</td><td><div style="word-wrap: break-word;"><b>EPWM Period Point Interrupt Flag
</b><br>
This bit is set by hardware when EPWM counter reaches EPWM_PERIODn, software can write 1 to clear this bit to zero.
<br>
</div></td></tr><tr><td>
[12]</td><td>PIF4</td><td><div style="word-wrap: break-word;"><b>EPWM Period Point Interrupt Flag
</b><br>
This bit is set by hardware when EPWM counter reaches EPWM_PERIODn, software can write 1 to clear this bit to zero.
<br>
</div></td></tr><tr><td>
[13]</td><td>PIF5</td><td><div style="word-wrap: break-word;"><b>EPWM Period Point Interrupt Flag
</b><br>
This bit is set by hardware when EPWM counter reaches EPWM_PERIODn, software can write 1 to clear this bit to zero.
<br>
</div></td></tr><tr><td>
[16]</td><td>CMPUIF0</td><td><div style="word-wrap: break-word;"><b>EPWM Compare Up Count Interrupt Flag
</b><br>
Flag is set by hardware when EPWM counter up count and reaches EPWM_CMPDATn, software can clear this bit by writing 1 to it.
<br>
Note1: If CMPDAT equal to PERIOD, this flag is not working in up counter type selection.
<br>
Note2: In complementary mode, CMPUIF1, 3, 5 use as another CMPUIF for channel 0, 2, 4.
<br>
</div></td></tr><tr><td>
[17]</td><td>CMPUIF1</td><td><div style="word-wrap: break-word;"><b>EPWM Compare Up Count Interrupt Flag
</b><br>
Flag is set by hardware when EPWM counter up count and reaches EPWM_CMPDATn, software can clear this bit by writing 1 to it.
<br>
Note1: If CMPDAT equal to PERIOD, this flag is not working in up counter type selection.
<br>
Note2: In complementary mode, CMPUIF1, 3, 5 use as another CMPUIF for channel 0, 2, 4.
<br>
</div></td></tr><tr><td>
[18]</td><td>CMPUIF2</td><td><div style="word-wrap: break-word;"><b>EPWM Compare Up Count Interrupt Flag
</b><br>
Flag is set by hardware when EPWM counter up count and reaches EPWM_CMPDATn, software can clear this bit by writing 1 to it.
<br>
Note1: If CMPDAT equal to PERIOD, this flag is not working in up counter type selection.
<br>
Note2: In complementary mode, CMPUIF1, 3, 5 use as another CMPUIF for channel 0, 2, 4.
<br>
</div></td></tr><tr><td>
[19]</td><td>CMPUIF3</td><td><div style="word-wrap: break-word;"><b>EPWM Compare Up Count Interrupt Flag
</b><br>
Flag is set by hardware when EPWM counter up count and reaches EPWM_CMPDATn, software can clear this bit by writing 1 to it.
<br>
Note1: If CMPDAT equal to PERIOD, this flag is not working in up counter type selection.
<br>
Note2: In complementary mode, CMPUIF1, 3, 5 use as another CMPUIF for channel 0, 2, 4.
<br>
</div></td></tr><tr><td>
[20]</td><td>CMPUIF4</td><td><div style="word-wrap: break-word;"><b>EPWM Compare Up Count Interrupt Flag
</b><br>
Flag is set by hardware when EPWM counter up count and reaches EPWM_CMPDATn, software can clear this bit by writing 1 to it.
<br>
Note1: If CMPDAT equal to PERIOD, this flag is not working in up counter type selection.
<br>
Note2: In complementary mode, CMPUIF1, 3, 5 use as another CMPUIF for channel 0, 2, 4.
<br>
</div></td></tr><tr><td>
[21]</td><td>CMPUIF5</td><td><div style="word-wrap: break-word;"><b>EPWM Compare Up Count Interrupt Flag
</b><br>
Flag is set by hardware when EPWM counter up count and reaches EPWM_CMPDATn, software can clear this bit by writing 1 to it.
<br>
Note1: If CMPDAT equal to PERIOD, this flag is not working in up counter type selection.
<br>
Note2: In complementary mode, CMPUIF1, 3, 5 use as another CMPUIF for channel 0, 2, 4.
<br>
</div></td></tr><tr><td>
[24]</td><td>CMPDIF0</td><td><div style="word-wrap: break-word;"><b>EPWM Compare Down Count Interrupt Flag
</b><br>
Flag is set by hardware when EPWM counter down count and reaches EPWM_CMPDATn, software can clear this bit by writing 1 to it.
<br>
Note1: If CMPDAT equal to PERIOD, this flag is not working in down counter type selection.
<br>
Note2: In complementary mode, CMPDIF1, 3, 5 use as another CMPDIF for channel 0, 2, 4.
<br>
</div></td></tr><tr><td>
[25]</td><td>CMPDIF1</td><td><div style="word-wrap: break-word;"><b>EPWM Compare Down Count Interrupt Flag
</b><br>
Flag is set by hardware when EPWM counter down count and reaches EPWM_CMPDATn, software can clear this bit by writing 1 to it.
<br>
Note1: If CMPDAT equal to PERIOD, this flag is not working in down counter type selection.
<br>
Note2: In complementary mode, CMPDIF1, 3, 5 use as another CMPDIF for channel 0, 2, 4.
<br>
</div></td></tr><tr><td>
[26]</td><td>CMPDIF2</td><td><div style="word-wrap: break-word;"><b>EPWM Compare Down Count Interrupt Flag
</b><br>
Flag is set by hardware when EPWM counter down count and reaches EPWM_CMPDATn, software can clear this bit by writing 1 to it.
<br>
Note1: If CMPDAT equal to PERIOD, this flag is not working in down counter type selection.
<br>
Note2: In complementary mode, CMPDIF1, 3, 5 use as another CMPDIF for channel 0, 2, 4.
<br>
</div></td></tr><tr><td>
[27]</td><td>CMPDIF3</td><td><div style="word-wrap: break-word;"><b>EPWM Compare Down Count Interrupt Flag
</b><br>
Flag is set by hardware when EPWM counter down count and reaches EPWM_CMPDATn, software can clear this bit by writing 1 to it.
<br>
Note1: If CMPDAT equal to PERIOD, this flag is not working in down counter type selection.
<br>
Note2: In complementary mode, CMPDIF1, 3, 5 use as another CMPDIF for channel 0, 2, 4.
<br>
</div></td></tr><tr><td>
[28]</td><td>CMPDIF4</td><td><div style="word-wrap: break-word;"><b>EPWM Compare Down Count Interrupt Flag
</b><br>
Flag is set by hardware when EPWM counter down count and reaches EPWM_CMPDATn, software can clear this bit by writing 1 to it.
<br>
Note1: If CMPDAT equal to PERIOD, this flag is not working in down counter type selection.
<br>
Note2: In complementary mode, CMPDIF1, 3, 5 use as another CMPDIF for channel 0, 2, 4.
<br>
</div></td></tr><tr><td>
[29]</td><td>CMPDIF5</td><td><div style="word-wrap: break-word;"><b>EPWM Compare Down Count Interrupt Flag
</b><br>
Flag is set by hardware when EPWM counter down count and reaches EPWM_CMPDATn, software can clear this bit by writing 1 to it.
<br>
Note1: If CMPDAT equal to PERIOD, this flag is not working in down counter type selection.
<br>
Note2: In complementary mode, CMPDIF1, 3, 5 use as another CMPDIF for channel 0, 2, 4.
<br>
</div></td></tr></tbody></table></html>

 </p>

<p class="definition">Definition at line <a class="el" href="epwm__reg_8h_source.html#l04761">4761</a> of file <a class="el" href="epwm__reg_8h_source.html">epwm_reg.h</a>.</p>

</div>
</div>
<a id="a69ed3ad4bafb67436be2ec1bcefbdc20" name="a69ed3ad4bafb67436be2ec1bcefbdc20"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a69ed3ad4bafb67436be2ec1bcefbdc20">&#9670;&nbsp;</a></span>INTSTS1</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">EPWM_T::INTSTS1</td>
        </tr>
      </table>
</div><div class="memdoc">
<p >[0x00ec] EPWM Interrupt Flag Register 1 <br  />
</p>
<p > 

<html><table class="fixed" border="1" style="border-collapse:collapse;" borderColor=black ><col width="75px" /><col width="125px" /><col width="700px" /><caption align="left"><font size="3">INTSTS1
</font><br><p> <font size="2">
Offset: 0xEC  EPWM Interrupt Flag Register 1
</font></caption><thread><tr bgcolor="#8A0808" ><td><font color=white><b>Bits</b></font></td><td><font color=white><b>Field</b></font></td><td><font color=white><b>Descriptions</b></font></td></tr></thread><tbody>
<tr><td>
[0]</td><td>BRKEIF0</td><td><div style="word-wrap: break-word;"><b>EPWM Channel0 Edge-detect Brake Interrupt Flag (Write Protect)
</b><br>
0 = EPWM channel0 edge-detect brake event do not happened.
<br>
1 = When EPWM channel0 edge-detect brake event happened, this bit is set to 1, writing 1 to clear.
<br>
Note: This register is write protected. Refer toSYS_REGLCTL register.
<br>
</div></td></tr><tr><td>
[1]</td><td>BRKEIF1</td><td><div style="word-wrap: break-word;"><b>EPWM Channel1 Edge-detect Brake Interrupt Flag (Write Protect)
</b><br>
0 = EPWM channel1 edge-detect brake event do not happened.
<br>
1 = When EPWM channel1 edge-detect brake event happened, this bit is set to 1, writing 1 to clear.
<br>
Note: This register is write protected. Refer toSYS_REGLCTL register.
<br>
</div></td></tr><tr><td>
[2]</td><td>BRKEIF2</td><td><div style="word-wrap: break-word;"><b>EPWM Channel2 Edge-detect Brake Interrupt Flag (Write Protect)
</b><br>
0 = EPWM channel2 edge-detect brake event do not happened.
<br>
1 = When EPWM channel2 edge-detect brake event happened, this bit is set to 1, writing 1 to clear.
<br>
Note: This register is write protected. Refer toSYS_REGLCTL register.
<br>
</div></td></tr><tr><td>
[3]</td><td>BRKEIF3</td><td><div style="word-wrap: break-word;"><b>EPWM Channel3 Edge-detect Brake Interrupt Flag (Write Protect)
</b><br>
0 = EPWM channel3 edge-detect brake event do not happened.
<br>
1 = When EPWM channel3 edge-detect brake event happened, this bit is set to 1, writing 1 to clear.
<br>
Note: This register is write protected. Refer toSYS_REGLCTL register.
<br>
</div></td></tr><tr><td>
[4]</td><td>BRKEIF4</td><td><div style="word-wrap: break-word;"><b>EPWM Channel4 Edge-detect Brake Interrupt Flag (Write Protect)
</b><br>
0 = EPWM channel4 edge-detect brake event do not happened.
<br>
1 = When EPWM channel4 edge-detect brake event happened, this bit is set to 1, writing 1 to clear.
<br>
Note: This register is write protected. Refer toSYS_REGLCTL register.
<br>
</div></td></tr><tr><td>
[5]</td><td>BRKEIF5</td><td><div style="word-wrap: break-word;"><b>EPWM Channel5 Edge-detect Brake Interrupt Flag (Write Protect)
</b><br>
0 = EPWM channel5 edge-detect brake event do not happened.
<br>
1 = When EPWM channel5 edge-detect brake event happened, this bit is set to 1, writing 1 to clear.
<br>
Note: This register is write protected. Refer toSYS_REGLCTL register.
<br>
</div></td></tr><tr><td>
[8]</td><td>BRKLIF0</td><td><div style="word-wrap: break-word;"><b>EPWM Channel0 Level-detect Brake Interrupt Flag (Write Protect)
</b><br>
0 = EPWM channel0 level-detect brake event do not happened.
<br>
1 = When EPWM channel0 level-detect brake event happened, this bit is set to 1, writing 1 to clear.
<br>
Note: This register is write protected. Refer toSYS_REGLCTL register.
<br>
</div></td></tr><tr><td>
[9]</td><td>BRKLIF1</td><td><div style="word-wrap: break-word;"><b>EPWM Channel1 Level-detect Brake Interrupt Flag (Write Protect)
</b><br>
0 = EPWM channel1 level-detect brake event do not happened.
<br>
1 = When EPWM channel1 level-detect brake event happened, this bit is set to 1, writing 1 to clear.
<br>
Note: This register is write protected. Refer toSYS_REGLCTL register.
<br>
</div></td></tr><tr><td>
[10]</td><td>BRKLIF2</td><td><div style="word-wrap: break-word;"><b>EPWM Channel2 Level-detect Brake Interrupt Flag (Write Protect)
</b><br>
0 = EPWM channel2 level-detect brake event do not happened.
<br>
1 = When EPWM channel2 level-detect brake event happened, this bit is set to 1, writing 1 to clear.
<br>
Note: This register is write protected. Refer toSYS_REGLCTL register.
<br>
</div></td></tr><tr><td>
[11]</td><td>BRKLIF3</td><td><div style="word-wrap: break-word;"><b>EPWM Channel3 Level-detect Brake Interrupt Flag (Write Protect)
</b><br>
0 = EPWM channel3 level-detect brake event do not happened.
<br>
1 = When EPWM channel3 level-detect brake event happened, this bit is set to 1, writing 1 to clear.
<br>
Note: This register is write protected. Refer toSYS_REGLCTL register.
<br>
</div></td></tr><tr><td>
[12]</td><td>BRKLIF4</td><td><div style="word-wrap: break-word;"><b>EPWM Channel4 Level-detect Brake Interrupt Flag (Write Protect)
</b><br>
0 = EPWM channel4 level-detect brake event do not happened.
<br>
1 = When EPWM channel4 level-detect brake event happened, this bit is set to 1, writing 1 to clear.
<br>
Note: This register is write protected. Refer toSYS_REGLCTL register.
<br>
</div></td></tr><tr><td>
[13]</td><td>BRKLIF5</td><td><div style="word-wrap: break-word;"><b>EPWM Channel5 Level-detect Brake Interrupt Flag (Write Protect)
</b><br>
0 = EPWM channel5 level-detect brake event do not happened.
<br>
1 = When EEPWM channel5 level-detect brake event happened, this bit is set to 1, writing 1 to clear.
<br>
Note: This register is write protected. Refer toSYS_REGLCTL register.
<br>
</div></td></tr><tr><td>
[16]</td><td>BRKESTS0</td><td><div style="word-wrap: break-word;"><b>EPWM Channel0 Edge-detect Brake Status (Read Only)
</b><br>
0 = EPWM channel0 edge-detect brake state is released.
<br>
1 = When EPWM channel0 edge-detect brake detects a falling edge of any enabled brake source; this flag will be set to indicate the EPWM channel0 at brake state, writing 1 to clear.
<br>
</div></td></tr><tr><td>
[17]</td><td>BRKESTS1</td><td><div style="word-wrap: break-word;"><b>EPWM Channel1 Edge-detect Brake Status (Read Only)
</b><br>
0 = EPWM channel1 edge-detect brake state is released.
<br>
1 = When EPWM channel1 edge-detect brake detects a falling edge of any enabled brake source; this flag will be set to indicate the EPWM channel1 at brake state, writing 1 to clear.
<br>
</div></td></tr><tr><td>
[18]</td><td>BRKESTS2</td><td><div style="word-wrap: break-word;"><b>EPWM Channel2 Edge-detect Brake Status (Read Only)
</b><br>
0 = EPWM channel2 edge-detect brake state is released.
<br>
1 = When EPWM channel2 edge-detect brake detects a falling edge of any enabled brake source; this flag will be set to indicate the EPWM channel2 at brake state, writing 1 to clear.
<br>
</div></td></tr><tr><td>
[19]</td><td>BRKESTS3</td><td><div style="word-wrap: break-word;"><b>EPWM Channel3 Edge-detect Brake Status (Read Only)
</b><br>
0 = EPWM channel3 edge-detect brake state is released.
<br>
1 = When EPWM channel3 edge-detect brake detects a falling edge of any enabled brake source; this flag will be set to indicate the EPWM channel3 at brake state, writing 1 to clear.
<br>
</div></td></tr><tr><td>
[20]</td><td>BRKESTS4</td><td><div style="word-wrap: break-word;"><b>EPWM Channel4 Edge-detect Brake Status (Read Only)
</b><br>
0 = EPWM channel4 edge-detect brake state is released.
<br>
1 = When EPWM channel4 edge-detect brake detects a falling edge of any enabled brake source; this flag will be set to indicate the EPWM channel4 at brake state, writing 1 to clear.
<br>
</div></td></tr><tr><td>
[21]</td><td>BRKESTS5</td><td><div style="word-wrap: break-word;"><b>EPWM Channel5 Edge-detect Brake Status (Read Only)
</b><br>
0 = EPWM channel5 edge-detect brake state is released.
<br>
1 = When EPWM channel5 edge-detect brake detects a falling edge of any enabled brake source; this flag will be set to indicate the EPWM channel5 at brake state, writing 1 to clear.
<br>
</div></td></tr><tr><td>
[24]</td><td>BRKLSTS0</td><td><div style="word-wrap: break-word;"><b>EPWM Channel0 Level-detect Brake Status (Read Only)
</b><br>
0 = EPWM channel0 level-detect brake state is released.
<br>
1 = When EPWM channel0 level-detect brake detects a falling edge of any enabled brake source; this flag will be set to indicate the EPWM channel0 at brake state.
<br>
Note: This bit is read only and auto cleared by hardware
<br>
When enabled brake source return to high level, EPWM will release brake state until current EPWM period finished
<br>
The EPWM waveform will start output from next full EPWM period.
<br>
</div></td></tr><tr><td>
[25]</td><td>BRKLSTS1</td><td><div style="word-wrap: break-word;"><b>EPWM Channel1 Level-detect Brake Status (Read Only)
</b><br>
0 = EPWM channel1 level-detect brake state is released.
<br>
1 = When EPWM channel1 level-detect brake detects a falling edge of any enabled brake source; this flag will be set to indicate the EPWM channel1 at brake state.
<br>
Note: This bit is read only and auto cleared by hardware
<br>
When enabled brake source return to high level, EPWM will release brake state until current EPWM period finished
<br>
The EPWM waveform will start output from next full EPWM period.
<br>
</div></td></tr><tr><td>
[26]</td><td>BRKLSTS2</td><td><div style="word-wrap: break-word;"><b>EPWM Channel2 Level-detect Brake Status (Read Only)
</b><br>
0 = EPWM channel2 level-detect brake state is released.
<br>
1 = When EPWM channel2 level-detect brake detects a falling edge of any enabled brake source; this flag will be set to indicate the EPWM channel2 at brake state.
<br>
Note: This bit is read only and auto cleared by hardware
<br>
When enabled brake source return to high level, EPWM will release brake state until current EPWM period finished
<br>
The EPWM waveform will start output from next full EPWM period.
<br>
</div></td></tr><tr><td>
[27]</td><td>BRKLSTS3</td><td><div style="word-wrap: break-word;"><b>EPWM Channel3 Level-detect Brake Status (Read Only)
</b><br>
0 = EPWM channel3 level-detect brake state is released.
<br>
1 = When EPWM channel3 level-detect brake detects a falling edge of any enabled brake source; this flag will be set to indicate the EPWM channel3 at brake state.
<br>
Note: This bit is read only and auto cleared by hardware
<br>
When enabled brake source return to high level, EPWM will release brake state until current EPWM period finished
<br>
The EPWM waveform will start output from next full EPWM period.
<br>
</div></td></tr><tr><td>
[28]</td><td>BRKLSTS4</td><td><div style="word-wrap: break-word;"><b>EPWM Channel4 Level-detect Brake Status (Read Only)
</b><br>
0 = EPWM channel4 level-detect brake state is released.
<br>
1 = When EPWM channel4 level-detect brake detects a falling edge of any enabled brake source; this flag will be set to indicate the EPWM channel4 at brake state.
<br>
Note: This bit is read only and auto cleared by hardware
<br>
When enabled brake source return to high level, EPWM will release brake state until current EPWM period finished
<br>
The EPWM waveform will start output from next full EPWM period.
<br>
</div></td></tr><tr><td>
[29]</td><td>BRKLSTS5</td><td><div style="word-wrap: break-word;"><b>EPWM Channel5 Level-detect Brake Status (Read Only)
</b><br>
0 = EPWM channel5 level-detect brake state is released.
<br>
1 = When EPWM channel5 level-detect brake detects a falling edge of any enabled brake source; this flag will be set to indicate the EPWM channel5 at brake state.
<br>
Note: This bit is read only and auto cleared by hardware
<br>
When enabled brake source return to high level, EPWM will release brake state until current EPWM period finished
<br>
The EPWM waveform will start output from next full EPWM period.
<br>
</div></td></tr></tbody></table></html>

 </p>

<p class="definition">Definition at line <a class="el" href="epwm__reg_8h_source.html#l04762">4762</a> of file <a class="el" href="epwm__reg_8h_source.html">epwm_reg.h</a>.</p>

</div>
</div>
<a id="a65d0bfd62ef05ecc6a83efd597e7ccb1" name="a65d0bfd62ef05ecc6a83efd597e7ccb1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a65d0bfd62ef05ecc6a83efd597e7ccb1">&#9670;&nbsp;</a></span>LEBCNT</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">EPWM_T::LEBCNT</td>
        </tr>
      </table>
</div><div class="memdoc">
<p >[0x011c] EPWM Leading Edge Blanking Counter Register <br  />
</p>
<p > 

<html><table class="fixed" border="1" style="border-collapse:collapse;" borderColor=black ><col width="75px" /><col width="125px" /><col width="700px" /><caption align="left"><font size="3">LEBCNT
</font><br><p> <font size="2">
Offset: 0x11C  EPWM Leading Edge Blanking Counter Register
</font></caption><thread><tr bgcolor="#8A0808" ><td><font color=white><b>Bits</b></font></td><td><font color=white><b>Field</b></font></td><td><font color=white><b>Descriptions</b></font></td></tr></thread><tbody>
<tr><td>
[8:0]</td><td>LEBCNT</td><td><div style="word-wrap: break-word;"><b>EPWM Leading Edge Blanking Counter
</b><br>
This counter value decides leading edge blanking window size
<br>
Blanking window size = LEBCNT+1, and LEB counter clock base is ECLK.
<br>
</div></td></tr></tbody></table></html>

 </p>

<p class="definition">Definition at line <a class="el" href="epwm__reg_8h_source.html#l04776">4776</a> of file <a class="el" href="epwm__reg_8h_source.html">epwm_reg.h</a>.</p>

</div>
</div>
<a id="ad29b3637bb7bb5ad0e28268be133fc47" name="ad29b3637bb7bb5ad0e28268be133fc47"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad29b3637bb7bb5ad0e28268be133fc47">&#9670;&nbsp;</a></span>LEBCTL</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">EPWM_T::LEBCTL</td>
        </tr>
      </table>
</div><div class="memdoc">
<p >[0x0118] EPWM Leading Edge Blanking Control Register <br  />
</p>
<p > 

<html><table class="fixed" border="1" style="border-collapse:collapse;" borderColor=black ><col width="75px" /><col width="125px" /><col width="700px" /><caption align="left"><font size="3">LEBCTL
</font><br><p> <font size="2">
Offset: 0x118  EPWM Leading Edge Blanking Control Register
</font></caption><thread><tr bgcolor="#8A0808" ><td><font color=white><b>Bits</b></font></td><td><font color=white><b>Field</b></font></td><td><font color=white><b>Descriptions</b></font></td></tr></thread><tbody>
<tr><td>
[0]</td><td>LEBEN</td><td><div style="word-wrap: break-word;"><b>EPWM Leading Edge Blanking Enable Bit
</b><br>
0 = EPWM Leading Edge Blanking Disabled.
<br>
1 = EPWM Leading Edge Blanking Enabled.
<br>
</div></td></tr><tr><td>
[8]</td><td>SRCEN0</td><td><div style="word-wrap: break-word;"><b>EPWM Leading Edge Blanking Source From EPWM_CH0 Enable Bit
</b><br>
0 = EPWM Leading Edge Blanking Source from EPWM_CH0 Disabled.
<br>
1 = EPWM Leading Edge Blanking Source from EPWM_CH0 Enabled.
<br>
</div></td></tr><tr><td>
[9]</td><td>SRCEN2</td><td><div style="word-wrap: break-word;"><b>EPWM Leading Edge Blanking Source From EPWM_CH2 Enable Bit
</b><br>
0 = EPWM Leading Edge Blanking Source from EPWM_CH2 Disabled.
<br>
1 = EPWM Leading Edge Blanking Source from EPWM_CH2 Enabled.
<br>
</div></td></tr><tr><td>
[10]</td><td>SRCEN4</td><td><div style="word-wrap: break-word;"><b>EPWM Leading Edge Blanking Source From EPWM_CH4 Enable Bit
</b><br>
0 = EPWM Leading Edge Blanking Source from EPWM_CH4 Disabled.
<br>
1 = EPWM Leading Edge Blanking Source from EPWM_CH4 Enabled.
<br>
</div></td></tr><tr><td>
[17:16]</td><td>TRGTYPE</td><td><div style="word-wrap: break-word;"><b>EPWM Leading Edge Blanking Trigger Type
</b><br>
0 = When detect leading edge blanking source rising edge, blanking counter start counting.
<br>
1 = When detect leading edge blanking source falling edge, blanking counter start counting.
<br>
2 = When detect leading edge blanking source rising or falling edge, blanking counter start counting.
<br>
3 = Reserved.
<br>
</div></td></tr></tbody></table></html>

 </p>

<p class="definition">Definition at line <a class="el" href="epwm__reg_8h_source.html#l04775">4775</a> of file <a class="el" href="epwm__reg_8h_source.html">epwm_reg.h</a>.</p>

</div>
</div>
<a id="a95d88226a73492d643da5cd80af46b22" name="a95d88226a73492d643da5cd80af46b22"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a95d88226a73492d643da5cd80af46b22">&#9670;&nbsp;</a></span>LOAD</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">EPWM_T::LOAD</td>
        </tr>
      </table>
</div><div class="memdoc">
<p >[0x0028] EPWM Load Register <br  />
</p>
<p > 

<html><table class="fixed" border="1" style="border-collapse:collapse;" borderColor=black ><col width="75px" /><col width="125px" /><col width="700px" /><caption align="left"><font size="3">LOAD
</font><br><p> <font size="2">
Offset: 0x28  EPWM Load Register
</font></caption><thread><tr bgcolor="#8A0808" ><td><font color=white><b>Bits</b></font></td><td><font color=white><b>Field</b></font></td><td><font color=white><b>Descriptions</b></font></td></tr></thread><tbody>
<tr><td>
[0]</td><td>LOAD0</td><td><div style="word-wrap: break-word;"><b>Re-load EPWM Comparator Register (CMPDAT) Control Bit
</b><br>
This bit is software write, hardware clear when current EPWM period end.
<br>
Write Operation:
<br>
0 = No effect.
<br>
1 = Set load window of window loading mode.
<br>
Read Operation:
<br>
0 = No load window is set.
<br>
1 = Load window is set.
<br>
Note: This bit only use in window loading mode, WINLDENn(EPWM_CTL0[13:8]) = 1.
<br>
</div></td></tr><tr><td>
[1]</td><td>LOAD1</td><td><div style="word-wrap: break-word;"><b>Re-load EPWM Comparator Register (CMPDAT) Control Bit
</b><br>
This bit is software write, hardware clear when current EPWM period end.
<br>
Write Operation:
<br>
0 = No effect.
<br>
1 = Set load window of window loading mode.
<br>
Read Operation:
<br>
0 = No load window is set.
<br>
1 = Load window is set.
<br>
Note: This bit only use in window loading mode, WINLDENn(EPWM_CTL0[13:8]) = 1.
<br>
</div></td></tr><tr><td>
[2]</td><td>LOAD2</td><td><div style="word-wrap: break-word;"><b>Re-load EPWM Comparator Register (CMPDAT) Control Bit
</b><br>
This bit is software write, hardware clear when current EPWM period end.
<br>
Write Operation:
<br>
0 = No effect.
<br>
1 = Set load window of window loading mode.
<br>
Read Operation:
<br>
0 = No load window is set.
<br>
1 = Load window is set.
<br>
Note: This bit only use in window loading mode, WINLDENn(EPWM_CTL0[13:8]) = 1.
<br>
</div></td></tr><tr><td>
[3]</td><td>LOAD3</td><td><div style="word-wrap: break-word;"><b>Re-load EPWM Comparator Register (CMPDAT) Control Bit
</b><br>
This bit is software write, hardware clear when current EPWM period end.
<br>
Write Operation:
<br>
0 = No effect.
<br>
1 = Set load window of window loading mode.
<br>
Read Operation:
<br>
0 = No load window is set.
<br>
1 = Load window is set.
<br>
Note: This bit only use in window loading mode, WINLDENn(EPWM_CTL0[13:8]) = 1.
<br>
</div></td></tr><tr><td>
[4]</td><td>LOAD4</td><td><div style="word-wrap: break-word;"><b>Re-load EPWM Comparator Register (CMPDAT) Control Bit
</b><br>
This bit is software write, hardware clear when current EPWM period end.
<br>
Write Operation:
<br>
0 = No effect.
<br>
1 = Set load window of window loading mode.
<br>
Read Operation:
<br>
0 = No load window is set.
<br>
1 = Load window is set.
<br>
Note: This bit only use in window loading mode, WINLDENn(EPWM_CTL0[13:8]) = 1.
<br>
</div></td></tr><tr><td>
[5]</td><td>LOAD5</td><td><div style="word-wrap: break-word;"><b>Re-load EPWM Comparator Register (CMPDAT) Control Bit
</b><br>
This bit is software write, hardware clear when current EPWM period end.
<br>
Write Operation:
<br>
0 = No effect.
<br>
1 = Set load window of window loading mode.
<br>
Read Operation:
<br>
0 = No load window is set.
<br>
1 = Load window is set.
<br>
Note: This bit only use in window loading mode, WINLDENn(EPWM_CTL0[13:8]) = 1.
<br>
</div></td></tr></tbody></table></html>

 </p>

<p class="definition">Definition at line <a class="el" href="epwm__reg_8h_source.html#l04725">4725</a> of file <a class="el" href="epwm__reg_8h_source.html">epwm_reg.h</a>.</p>

</div>
</div>
<a id="a3a8ad62b46e87f2f426324392b2bcdeb" name="a3a8ad62b46e87f2f426324392b2bcdeb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3a8ad62b46e87f2f426324392b2bcdeb">&#9670;&nbsp;</a></span>MSK</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">EPWM_T::MSK</td>
        </tr>
      </table>
</div><div class="memdoc">
<p >[0x00bc] EPWM Mask Data Register <br  />
</p>
<p > 

<html><table class="fixed" border="1" style="border-collapse:collapse;" borderColor=black ><col width="75px" /><col width="125px" /><col width="700px" /><caption align="left"><font size="3">MSK
</font><br><p> <font size="2">
Offset: 0xBC  EPWM Mask Data Register
</font></caption><thread><tr bgcolor="#8A0808" ><td><font color=white><b>Bits</b></font></td><td><font color=white><b>Field</b></font></td><td><font color=white><b>Descriptions</b></font></td></tr></thread><tbody>
<tr><td>
[0]</td><td>MSKDAT0</td><td><div style="word-wrap: break-word;"><b>EPWM Mask Data Bit
</b><br>
This data bit control the state of EPWMn output pin, if corresponding mask function is enabled.
<br>
0 = Output logic low to EPWM channel n.
<br>
1 = Output logic high to EPWM channel n.
<br>
</div></td></tr><tr><td>
[1]</td><td>MSKDAT1</td><td><div style="word-wrap: break-word;"><b>EPWM Mask Data Bit
</b><br>
This data bit control the state of EPWMn output pin, if corresponding mask function is enabled.
<br>
0 = Output logic low to EPWM channel n.
<br>
1 = Output logic high to EPWM channel n.
<br>
</div></td></tr><tr><td>
[2]</td><td>MSKDAT2</td><td><div style="word-wrap: break-word;"><b>EPWM Mask Data Bit
</b><br>
This data bit control the state of EPWMn output pin, if corresponding mask function is enabled.
<br>
0 = Output logic low to EPWM channel n.
<br>
1 = Output logic high to EPWM channel n.
<br>
</div></td></tr><tr><td>
[3]</td><td>MSKDAT3</td><td><div style="word-wrap: break-word;"><b>EPWM Mask Data Bit
</b><br>
This data bit control the state of EPWMn output pin, if corresponding mask function is enabled.
<br>
0 = Output logic low to EPWM channel n.
<br>
1 = Output logic high to EPWM channel n.
<br>
</div></td></tr><tr><td>
[4]</td><td>MSKDAT4</td><td><div style="word-wrap: break-word;"><b>EPWM Mask Data Bit
</b><br>
This data bit control the state of EPWMn output pin, if corresponding mask function is enabled.
<br>
0 = Output logic low to EPWM channel n.
<br>
1 = Output logic high to EPWM channel n.
<br>
</div></td></tr><tr><td>
[5]</td><td>MSKDAT5</td><td><div style="word-wrap: break-word;"><b>EPWM Mask Data Bit
</b><br>
This data bit control the state of EPWMn output pin, if corresponding mask function is enabled.
<br>
0 = Output logic low to EPWM channel n.
<br>
1 = Output logic high to EPWM channel n.
<br>
</div></td></tr></tbody></table></html>

 </p>

<p class="definition">Definition at line <a class="el" href="epwm__reg_8h_source.html#l04752">4752</a> of file <a class="el" href="epwm__reg_8h_source.html">epwm_reg.h</a>.</p>

</div>
</div>
<a id="a823c55123442bc4ae77bdec636747ff8" name="a823c55123442bc4ae77bdec636747ff8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a823c55123442bc4ae77bdec636747ff8">&#9670;&nbsp;</a></span>MSKEN</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">EPWM_T::MSKEN</td>
        </tr>
      </table>
</div><div class="memdoc">
<p >[0x00b8] EPWM Mask Enable Register <br  />
</p>
<p > 

<html><table class="fixed" border="1" style="border-collapse:collapse;" borderColor=black ><col width="75px" /><col width="125px" /><col width="700px" /><caption align="left"><font size="3">MSKEN
</font><br><p> <font size="2">
Offset: 0xB8  EPWM Mask Enable Register
</font></caption><thread><tr bgcolor="#8A0808" ><td><font color=white><b>Bits</b></font></td><td><font color=white><b>Field</b></font></td><td><font color=white><b>Descriptions</b></font></td></tr></thread><tbody>
<tr><td>
[0]</td><td>MSKEN0</td><td><div style="word-wrap: break-word;"><b>EPWM Mask Enable Bits
</b><br>
The EPWM output signal will be masked when this bit is enabled
<br>
The corresponding EPWM channel n will output MSKDATn (EPWM_MSK[5:0]) data.
<br>
0 = EPWM output signal is non-masked.
<br>
1 = EPWM output signal is masked and output MSKDATn data.
<br>
</div></td></tr><tr><td>
[1]</td><td>MSKEN1</td><td><div style="word-wrap: break-word;"><b>EPWM Mask Enable Bits
</b><br>
The EPWM output signal will be masked when this bit is enabled
<br>
The corresponding EPWM channel n will output MSKDATn (EPWM_MSK[5:0]) data.
<br>
0 = EPWM output signal is non-masked.
<br>
1 = EPWM output signal is masked and output MSKDATn data.
<br>
</div></td></tr><tr><td>
[2]</td><td>MSKEN2</td><td><div style="word-wrap: break-word;"><b>EPWM Mask Enable Bits
</b><br>
The EPWM output signal will be masked when this bit is enabled
<br>
The corresponding EPWM channel n will output MSKDATn (EPWM_MSK[5:0]) data.
<br>
0 = EPWM output signal is non-masked.
<br>
1 = EPWM output signal is masked and output MSKDATn data.
<br>
</div></td></tr><tr><td>
[3]</td><td>MSKEN3</td><td><div style="word-wrap: break-word;"><b>EPWM Mask Enable Bits
</b><br>
The EPWM output signal will be masked when this bit is enabled
<br>
The corresponding EPWM channel n will output MSKDATn (EPWM_MSK[5:0]) data.
<br>
0 = EPWM output signal is non-masked.
<br>
1 = EPWM output signal is masked and output MSKDATn data.
<br>
</div></td></tr><tr><td>
[4]</td><td>MSKEN4</td><td><div style="word-wrap: break-word;"><b>EPWM Mask Enable Bits
</b><br>
The EPWM output signal will be masked when this bit is enabled
<br>
The corresponding EPWM channel n will output MSKDATn (EPWM_MSK[5:0]) data.
<br>
0 = EPWM output signal is non-masked.
<br>
1 = EPWM output signal is masked and output MSKDATn data.
<br>
</div></td></tr><tr><td>
[5]</td><td>MSKEN5</td><td><div style="word-wrap: break-word;"><b>EPWM Mask Enable Bits
</b><br>
The EPWM output signal will be masked when this bit is enabled
<br>
The corresponding EPWM channel n will output MSKDATn (EPWM_MSK[5:0]) data.
<br>
0 = EPWM output signal is non-masked.
<br>
1 = EPWM output signal is masked and output MSKDATn data.
<br>
</div></td></tr></tbody></table></html>

 </p>

<p class="definition">Definition at line <a class="el" href="epwm__reg_8h_source.html#l04751">4751</a> of file <a class="el" href="epwm__reg_8h_source.html">epwm_reg.h</a>.</p>

</div>
</div>
<a id="a32ffeb6169978057756e218ef00b4f5b" name="a32ffeb6169978057756e218ef00b4f5b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a32ffeb6169978057756e218ef00b4f5b">&#9670;&nbsp;</a></span>PBUF</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">EPWM_T::PBUF[6]</td>
        </tr>
      </table>
</div><div class="memdoc">
<p >[0x0304] EPWM PERIOD0~5 Buffer <br  />
</p>
<p > 

<html><table class="fixed" border="1" style="border-collapse:collapse;" borderColor=black ><col width="75px" /><col width="125px" /><col width="700px" /><caption align="left"><font size="3">PBUF[6]
</font><br><p> <font size="2">
Offset: 0x304  EPWM PERIOD0~5 Buffer
</font></caption><thread><tr bgcolor="#8A0808" ><td><font color=white><b>Bits</b></font></td><td><font color=white><b>Field</b></font></td><td><font color=white><b>Descriptions</b></font></td></tr></thread><tbody>
<tr><td>
[15:0]</td><td>PBUF</td><td><div style="word-wrap: break-word;"><b>EPWM Period Register Buffer (Read Only)
</b><br>
Used as PERIOD active register.
<br>
</div></td></tr></tbody></table></html>

 </p>

<p class="definition">Definition at line <a class="el" href="epwm__reg_8h_source.html#l04817">4817</a> of file <a class="el" href="epwm__reg_8h_source.html">epwm_reg.h</a>.</p>

</div>
</div>
<a id="a26262c3ffe1ddffdb647adf86ab5e7af" name="a26262c3ffe1ddffdb647adf86ab5e7af"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a26262c3ffe1ddffdb647adf86ab5e7af">&#9670;&nbsp;</a></span>PDMACAP</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">EPWM_T::PDMACAP[3]</td>
        </tr>
      </table>
</div><div class="memdoc">
<p >[0x0240] EPWM Capture Channel 01,23,45 PDMA Register <br  />
</p>
<p > 

<html><table class="fixed" border="1" style="border-collapse:collapse;" borderColor=black ><col width="75px" /><col width="125px" /><col width="700px" /><caption align="left"><font size="3">PDMACAP[3]
</font><br><p> <font size="2">
Offset: 0x240  EPWM Capture Channel 01 PDMA Register
</font></caption><thread><tr bgcolor="#8A0808" ><td><font color=white><b>Bits</b></font></td><td><font color=white><b>Field</b></font></td><td><font color=white><b>Descriptions</b></font></td></tr></thread><tbody>
<tr><td>
[15:0]</td><td>CAPBUF</td><td><div style="word-wrap: break-word;"><b>EPWM Capture PDMA Register (Read Only)
</b><br>
This register is use as a buffer to transfer EPWM capture rising or falling data to memory by PDMA.
<br>
</div></td></tr></tbody></table></html>

 </p>

<p class="definition">Definition at line <a class="el" href="epwm__reg_8h_source.html#l04808">4808</a> of file <a class="el" href="epwm__reg_8h_source.html">epwm_reg.h</a>.</p>

</div>
</div>
<a id="a55410e119fe4361458132632c70526ab" name="a55410e119fe4361458132632c70526ab"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a55410e119fe4361458132632c70526ab">&#9670;&nbsp;</a></span>PDMACTL</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">EPWM_T::PDMACTL</td>
        </tr>
      </table>
</div><div class="memdoc">
<p >[0x023c] EPWM PDMA Control Register <br  />
</p>
<p > 

<html><table class="fixed" border="1" style="border-collapse:collapse;" borderColor=black ><col width="75px" /><col width="125px" /><col width="700px" /><caption align="left"><font size="3">PDMACTL
</font><br><p> <font size="2">
Offset: 0x23C  EPWM PDMA Control Register
</font></caption><thread><tr bgcolor="#8A0808" ><td><font color=white><b>Bits</b></font></td><td><font color=white><b>Field</b></font></td><td><font color=white><b>Descriptions</b></font></td></tr></thread><tbody>
<tr><td>
[0]</td><td>CHEN0_1</td><td><div style="word-wrap: break-word;"><b>Channel 0/1 PDMA Enable
</b><br>
0 = Channel 0/1 PDMA function Disabled.
<br>
1 = Channel 0/1 PDMA function Enabled for the channel 0/1 captured data and transfer to memory.
<br>
</div></td></tr><tr><td>
[2:1]</td><td>CAPMOD0_1</td><td><div style="word-wrap: break-word;"><b>Select EPWM_RCAPDAT0/1 or EPWM_FCAPDAT0/1 to Do PDMA Transfer
</b><br>
00 = Reserved.
<br>
01 = EPWM_RCAPDAT0/1.
<br>
10 = EPWM_FCAPDAT0/1.
<br>
11 = Both EPWM_RCAPDAT0/1 and EPWM_FCAPDAT0/1.
<br>
</div></td></tr><tr><td>
[3]</td><td>CAPORD0_1</td><td><div style="word-wrap: break-word;"><b>Capture Channel 0/1 Rising/Falling Order
</b><br>
Set this bit to determine whether the EPWM_RCAPDAT0/1 or EPWM_FCAPDAT0/1 is the first captured data transferred to memory through PDMA when CAPMOD0_1 =11.
<br>
0 = EPWM_FCAPDAT0/1 is the first captured data to memory.
<br>
1 = EPWM_RCAPDAT0/1 is the first captured data to memory.
<br>
</div></td></tr><tr><td>
[4]</td><td>CHSEL0_1</td><td><div style="word-wrap: break-word;"><b>Select Channel 0/1 to Do PDMA Transfer
</b><br>
0 = Channel0.
<br>
1 = Channel1.
<br>
</div></td></tr><tr><td>
[8]</td><td>CHEN2_3</td><td><div style="word-wrap: break-word;"><b>Channel 2/3 PDMA Enable
</b><br>
0 = Channel 2/3 PDMA function Disabled.
<br>
1 = Channel 2/3 PDMA function Enabled for the channel 2/3 captured data and transfer to memory.
<br>
</div></td></tr><tr><td>
[10:9]</td><td>CAPMOD2_3</td><td><div style="word-wrap: break-word;"><b>Select EPWM_RCAPDAT2/3 or EPWM_FCAODAT2/3 to Do PDMA Transfer
</b><br>
00 = Reserved.
<br>
01 = EPWM_RCAPDAT2/3.
<br>
10 = EPWM_FCAPDAT2/3.
<br>
11 = Both EPWM_RCAPDAT2/3 and EPWM_FCAPDAT2/3.
<br>
</div></td></tr><tr><td>
[11]</td><td>CAPORD2_3</td><td><div style="word-wrap: break-word;"><b>Capture Channel 2/3 Rising/Falling Order
</b><br>
Set this bit to determine whether the EPWM_RCAPDAT2/3 or EPWM_FCAPDAT2/3 is the first captured data transferred to memory through PDMA when CAPMOD2_3 =11.
<br>
0 = EPWM_FCAPDAT2/3 is the first captured data to memory.
<br>
1 = EPWM_RCAPDAT2/3 is the first captured data to memory.
<br>
</div></td></tr><tr><td>
[12]</td><td>CHSEL2_3</td><td><div style="word-wrap: break-word;"><b>Select Channel 2/3 to Do PDMA Transfer
</b><br>
0 = Channel2.
<br>
1 = Channel3.
<br>
</div></td></tr><tr><td>
[16]</td><td>CHEN4_5</td><td><div style="word-wrap: break-word;"><b>Channel 4/5 PDMA Enable
</b><br>
0 = Channel 4/5 PDMA function Disabled.
<br>
1 = Channel 4/5 PDMA function Enabled for the channel 4/5 captured data and transfer to memory.
<br>
</div></td></tr><tr><td>
[18:17]</td><td>CAPMOD4_5</td><td><div style="word-wrap: break-word;"><b>Select EPWM_RCAPDAT4/5 or EPWM_FCAPDAT4/5 to Do PDMA Transfer
</b><br>
00 = Reserved.
<br>
01 = EPWM_RCAPDAT4/5.
<br>
10 = EPWM_FCAPDAT4/5.
<br>
11 = Both EPWM_RCAPDAT4/5 and EPWM_FCAPDAT4/5.
<br>
</div></td></tr><tr><td>
[19]</td><td>CAPORD4_5</td><td><div style="word-wrap: break-word;"><b>Capture Channel 4/5 Rising/Falling Order
</b><br>
Set this bit to determine whether the EPWM_RCAPDAT4/5 or EPWM_FCAPDAT4/5 is the first captured data transferred to memory through PDMA when CAPMOD4_5 =11.
<br>
0 = EPWM_FCAPDAT4/5 is the first captured data to memory.
<br>
1 = EPWM_RCAPDAT4/5 is the first captured data to memory.
<br>
</div></td></tr><tr><td>
[20]</td><td>CHSEL4_5</td><td><div style="word-wrap: break-word;"><b>Select Channel 4/5 to Do PDMA Transfer
</b><br>
0 = Channel4.
<br>
1 = Channel5.
<br>
</div></td></tr></tbody></table></html>

 </p>

<p class="definition">Definition at line <a class="el" href="epwm__reg_8h_source.html#l04807">4807</a> of file <a class="el" href="epwm__reg_8h_source.html">epwm_reg.h</a>.</p>

</div>
</div>
<a id="aef471688e87b595cdcee3a8476b52837" name="aef471688e87b595cdcee3a8476b52837"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aef471688e87b595cdcee3a8476b52837">&#9670;&nbsp;</a></span>PERIOD</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">EPWM_T::PERIOD[6]</td>
        </tr>
      </table>
</div><div class="memdoc">
<p >[0x0030] EPWM Period Register 0~5 <br  />
</p>
<p > 

<html><table class="fixed" border="1" style="border-collapse:collapse;" borderColor=black ><col width="75px" /><col width="125px" /><col width="700px" /><caption align="left"><font size="3">PERIOD[6]
</font><br><p> <font size="2">
Offset: 0x30  EPWM Period Register 0~5
</font></caption><thread><tr bgcolor="#8A0808" ><td><font color=white><b>Bits</b></font></td><td><font color=white><b>Field</b></font></td><td><font color=white><b>Descriptions</b></font></td></tr></thread><tbody>
<tr><td>
[15:0]</td><td>PERIOD</td><td><div style="word-wrap: break-word;"><b>EPWM Period Register
</b><br>
Up-Count mode: In this mode, EPWM counter counts from 0 to PERIOD, and restarts from 0.
<br>
Down-Count mode: In this mode, EPWM counter counts from PERIOD to 0, and restarts from PERIOD.
<br>
EPWM period time = (PERIOD+1) * EPWM_CLK period.
<br>
Up-Down-Count mode: In this mode, EPWM counter counts from 0 to PERIOD, then decrements to 0 and repeats again.
<br>
EPWM period time = 2 * PERIOD * EPWM_CLK period.
<br>
</div></td></tr></tbody></table></html>

 </p>

<p class="definition">Definition at line <a class="el" href="epwm__reg_8h_source.html#l04729">4729</a> of file <a class="el" href="epwm__reg_8h_source.html">epwm_reg.h</a>.</p>

</div>
</div>
<a id="a83a42ab29cc1a0187c204d9a49366cc7" name="a83a42ab29cc1a0187c204d9a49366cc7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a83a42ab29cc1a0187c204d9a49366cc7">&#9670;&nbsp;</a></span>PHS</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">EPWM_T::PHS[3]</td>
        </tr>
      </table>
</div><div class="memdoc">
<p >[0x0080] EPWM Counter Phase Register 0/1,2/3,4/5 <br  />
</p>
<p > 

<html><table class="fixed" border="1" style="border-collapse:collapse;" borderColor=black ><col width="75px" /><col width="125px" /><col width="700px" /><caption align="left"><font size="3">PHS[3]
</font><br><p> <font size="2">
Offset: 0x80  EPWM Counter Phase Register 0/1,2/3,4/5
</font></caption><thread><tr bgcolor="#8A0808" ><td><font color=white><b>Bits</b></font></td><td><font color=white><b>Field</b></font></td><td><font color=white><b>Descriptions</b></font></td></tr></thread><tbody>
<tr><td>
[15:0]</td><td>PHS</td><td><div style="word-wrap: break-word;"><b>EPWM Synchronous Start Phase Bits
</b><br>
PHS determines the EPWM synchronous start phase value. These bits only use in synchronous function.
<br>
</div></td></tr></tbody></table></html>

 </p>

<p class="definition">Definition at line <a class="el" href="epwm__reg_8h_source.html#l04741">4741</a> of file <a class="el" href="epwm__reg_8h_source.html">epwm_reg.h</a>.</p>

</div>
</div>
<a id="ad4c7e260588d0c804f659dae62f38c3a" name="ad4c7e260588d0c804f659dae62f38c3a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad4c7e260588d0c804f659dae62f38c3a">&#9670;&nbsp;</a></span>POEN</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">EPWM_T::POEN</td>
        </tr>
      </table>
</div><div class="memdoc">
<p >[0x00d8] EPWM Output Enable Register <br  />
</p>
<p > 

<html><table class="fixed" border="1" style="border-collapse:collapse;" borderColor=black ><col width="75px" /><col width="125px" /><col width="700px" /><caption align="left"><font size="3">POEN
</font><br><p> <font size="2">
Offset: 0xD8  EPWM Output Enable Register
</font></caption><thread><tr bgcolor="#8A0808" ><td><font color=white><b>Bits</b></font></td><td><font color=white><b>Field</b></font></td><td><font color=white><b>Descriptions</b></font></td></tr></thread><tbody>
<tr><td>
[0]</td><td>POEN0</td><td><div style="word-wrap: break-word;"><b>EPWM Pin Output Enable Bits
</b><br>
0 = EPWM pin at tri-state.
<br>
1 = EPWM pin in output mode.
<br>
</div></td></tr><tr><td>
[1]</td><td>POEN1</td><td><div style="word-wrap: break-word;"><b>EPWM Pin Output Enable Bits
</b><br>
0 = EPWM pin at tri-state.
<br>
1 = EPWM pin in output mode.
<br>
</div></td></tr><tr><td>
[2]</td><td>POEN2</td><td><div style="word-wrap: break-word;"><b>EPWM Pin Output Enable Bits
</b><br>
0 = EPWM pin at tri-state.
<br>
1 = EPWM pin in output mode.
<br>
</div></td></tr><tr><td>
[3]</td><td>POEN3</td><td><div style="word-wrap: break-word;"><b>EPWM Pin Output Enable Bits
</b><br>
0 = EPWM pin at tri-state.
<br>
1 = EPWM pin in output mode.
<br>
</div></td></tr><tr><td>
[4]</td><td>POEN4</td><td><div style="word-wrap: break-word;"><b>EPWM Pin Output Enable Bits
</b><br>
0 = EPWM pin at tri-state.
<br>
1 = EPWM pin in output mode.
<br>
</div></td></tr><tr><td>
[5]</td><td>POEN5</td><td><div style="word-wrap: break-word;"><b>EPWM Pin Output Enable Bits
</b><br>
0 = EPWM pin at tri-state.
<br>
1 = EPWM pin in output mode.
<br>
</div></td></tr></tbody></table></html>

 </p>

<p class="definition">Definition at line <a class="el" href="epwm__reg_8h_source.html#l04757">4757</a> of file <a class="el" href="epwm__reg_8h_source.html">epwm_reg.h</a>.</p>

</div>
</div>
<a id="a9ce1aa1a288b7373fadfba292fcadde6" name="a9ce1aa1a288b7373fadfba292fcadde6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9ce1aa1a288b7373fadfba292fcadde6">&#9670;&nbsp;</a></span>POLCTL</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">EPWM_T::POLCTL</td>
        </tr>
      </table>
</div><div class="memdoc">
<p >[0x00d4] EPWM Pin Polar Inverse Register <br  />
</p>
<p > 

<html><table class="fixed" border="1" style="border-collapse:collapse;" borderColor=black ><col width="75px" /><col width="125px" /><col width="700px" /><caption align="left"><font size="3">POLCTL
</font><br><p> <font size="2">
Offset: 0xD4  EPWM Pin Polar Inverse Register
</font></caption><thread><tr bgcolor="#8A0808" ><td><font color=white><b>Bits</b></font></td><td><font color=white><b>Field</b></font></td><td><font color=white><b>Descriptions</b></font></td></tr></thread><tbody>
<tr><td>
[0]</td><td>PINV0</td><td><div style="word-wrap: break-word;"><b>EPWM PIN Polar Inverse Control
</b><br>
The register controls polarity state of EPWM output.
<br>
0 = EPWM output polar inverse Disabled.
<br>
1 = EPWM output polar inverse Enabled.
<br>
</div></td></tr><tr><td>
[1]</td><td>PINV1</td><td><div style="word-wrap: break-word;"><b>EPWM PIN Polar Inverse Control
</b><br>
The register controls polarity state of EPWM output.
<br>
0 = EPWM output polar inverse Disabled.
<br>
1 = EPWM output polar inverse Enabled.
<br>
</div></td></tr><tr><td>
[2]</td><td>PINV2</td><td><div style="word-wrap: break-word;"><b>EPWM PIN Polar Inverse Control
</b><br>
The register controls polarity state of EPWM output.
<br>
0 = EPWM output polar inverse Disabled.
<br>
1 = EPWM output polar inverse Enabled.
<br>
</div></td></tr><tr><td>
[3]</td><td>PINV3</td><td><div style="word-wrap: break-word;"><b>EPWM PIN Polar Inverse Control
</b><br>
The register controls polarity state of EPWM output.
<br>
0 = EPWM output polar inverse Disabled.
<br>
1 = EPWM output polar inverse Enabled.
<br>
</div></td></tr><tr><td>
[4]</td><td>PINV4</td><td><div style="word-wrap: break-word;"><b>EPWM PIN Polar Inverse Control
</b><br>
The register controls polarity state of EPWM output.
<br>
0 = EPWM output polar inverse Disabled.
<br>
1 = EPWM output polar inverse Enabled.
<br>
</div></td></tr><tr><td>
[5]</td><td>PINV5</td><td><div style="word-wrap: break-word;"><b>EPWM PIN Polar Inverse Control
</b><br>
The register controls polarity state of EPWM output.
<br>
0 = EPWM output polar inverse Disabled.
<br>
1 = EPWM output polar inverse Enabled.
<br>
</div></td></tr></tbody></table></html>

 </p>

<p class="definition">Definition at line <a class="el" href="epwm__reg_8h_source.html#l04756">4756</a> of file <a class="el" href="epwm__reg_8h_source.html">epwm_reg.h</a>.</p>

</div>
</div>
<a id="a9a66b72e270c7892f93f0683d05cc3cd" name="a9a66b72e270c7892f93f0683d05cc3cd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9a66b72e270c7892f93f0683d05cc3cd">&#9670;&nbsp;</a></span>SSCTL</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">EPWM_T::SSCTL</td>
        </tr>
      </table>
</div><div class="memdoc">
<p >[0x0110] EPWM Synchronous Start Control Register <br  />
</p>
<p > 

<html><table class="fixed" border="1" style="border-collapse:collapse;" borderColor=black ><col width="75px" /><col width="125px" /><col width="700px" /><caption align="left"><font size="3">SSCTL
</font><br><p> <font size="2">
Offset: 0x110  EPWM Synchronous Start Control Register
</font></caption><thread><tr bgcolor="#8A0808" ><td><font color=white><b>Bits</b></font></td><td><font color=white><b>Field</b></font></td><td><font color=white><b>Descriptions</b></font></td></tr></thread><tbody>
<tr><td>
[0]</td><td>SSEN0</td><td><div style="word-wrap: break-word;"><b>EPWM Synchronous Start Function Enable Bits
</b><br>
When synchronous start function is enabled, the EPWM counter enable register (EPWM_CNTEN) can be enabled by writing EPWM synchronous start trigger bit (CNTSEN).
<br>
0 = EPWM synchronous start function Disabled.
<br>
1 = EPWM synchronous start function Enabled.
<br>
</div></td></tr><tr><td>
[1]</td><td>SSEN1</td><td><div style="word-wrap: break-word;"><b>EPWM Synchronous Start Function Enable Bits
</b><br>
When synchronous start function is enabled, the EPWM counter enable register (EPWM_CNTEN) can be enabled by writing EPWM synchronous start trigger bit (CNTSEN).
<br>
0 = EPWM synchronous start function Disabled.
<br>
1 = EPWM synchronous start function Enabled.
<br>
</div></td></tr><tr><td>
[2]</td><td>SSEN2</td><td><div style="word-wrap: break-word;"><b>EPWM Synchronous Start Function Enable Bits
</b><br>
When synchronous start function is enabled, the EPWM counter enable register (EPWM_CNTEN) can be enabled by writing EPWM synchronous start trigger bit (CNTSEN).
<br>
0 = EPWM synchronous start function Disabled.
<br>
1 = EPWM synchronous start function Enabled.
<br>
</div></td></tr><tr><td>
[3]</td><td>SSEN3</td><td><div style="word-wrap: break-word;"><b>EPWM Synchronous Start Function Enable Bits
</b><br>
When synchronous start function is enabled, the EPWM counter enable register (EPWM_CNTEN) can be enabled by writing EPWM synchronous start trigger bit (CNTSEN).
<br>
0 = EPWM synchronous start function Disabled.
<br>
1 = EPWM synchronous start function Enabled.
<br>
</div></td></tr><tr><td>
[4]</td><td>SSEN4</td><td><div style="word-wrap: break-word;"><b>EPWM Synchronous Start Function Enable Bits
</b><br>
When synchronous start function is enabled, the EPWM counter enable register (EPWM_CNTEN) can be enabled by writing EPWM synchronous start trigger bit (CNTSEN).
<br>
0 = EPWM synchronous start function Disabled.
<br>
1 = EPWM synchronous start function Enabled.
<br>
</div></td></tr><tr><td>
[5]</td><td>SSEN5</td><td><div style="word-wrap: break-word;"><b>EPWM Synchronous Start Function Enable Bits
</b><br>
When synchronous start function is enabled, the EPWM counter enable register (EPWM_CNTEN) can be enabled by writing EPWM synchronous start trigger bit (CNTSEN).
<br>
0 = EPWM synchronous start function Disabled.
<br>
1 = EPWM synchronous start function Enabled.
<br>
</div></td></tr><tr><td>
[9:8]</td><td>SSRC</td><td><div style="word-wrap: break-word;"><b>EPWM Synchronous Start Source Select Bits
</b><br>
00 = Synchronous start source come from EPWM0.
<br>
01 = Synchronous start source come from EPWM1.
<br>
10 = Synchronous start source come from BPWM0.
<br>
11 = Synchronous start source come from BPWM1.
<br>
</div></td></tr></tbody></table></html>

 </p>

<p class="definition">Definition at line <a class="el" href="epwm__reg_8h_source.html#l04773">4773</a> of file <a class="el" href="epwm__reg_8h_source.html">epwm_reg.h</a>.</p>

</div>
</div>
<a id="a936f9d8b8d66fe11ec36955fb058af66" name="a936f9d8b8d66fe11ec36955fb058af66"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a936f9d8b8d66fe11ec36955fb058af66">&#9670;&nbsp;</a></span>SSTRG</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">EPWM_T::SSTRG</td>
        </tr>
      </table>
</div><div class="memdoc">
<p >[0x0114] EPWM Synchronous Start Trigger Register <br  />
</p>
<p > 

<html><table class="fixed" border="1" style="border-collapse:collapse;" borderColor=black ><col width="75px" /><col width="125px" /><col width="700px" /><caption align="left"><font size="3">SSTRG
</font><br><p> <font size="2">
Offset: 0x114  EPWM Synchronous Start Trigger Register
</font></caption><thread><tr bgcolor="#8A0808" ><td><font color=white><b>Bits</b></font></td><td><font color=white><b>Field</b></font></td><td><font color=white><b>Descriptions</b></font></td></tr></thread><tbody>
<tr><td>
[0]</td><td>CNTSEN</td><td><div style="word-wrap: break-word;"><b>EPWM Counter Synchronous Start Enable (Write Only)
</b><br>
PMW counter synchronous enable function is used to make selected EPWM channels (include EPWM0_CHx and EPWM1_CHx) start counting at the same time.
<br>
Writing this bit to 1 will also set the counter enable bit (CNTENn, n denotes channel 0 to 5) if correlated EPWM channel counter synchronous start function is enabled.
<br>
</div></td></tr></tbody></table></html>

 </p>

<p class="definition">Definition at line <a class="el" href="epwm__reg_8h_source.html#l04774">4774</a> of file <a class="el" href="epwm__reg_8h_source.html">epwm_reg.h</a>.</p>

</div>
</div>
<a id="a31307aa536101540e378d3546911cb17" name="a31307aa536101540e378d3546911cb17"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a31307aa536101540e378d3546911cb17">&#9670;&nbsp;</a></span>STATUS</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">EPWM_T::STATUS</td>
        </tr>
      </table>
</div><div class="memdoc">
<p >[0x0120] EPWM Status Register <br  />
</p>
<p > 

<html><table class="fixed" border="1" style="border-collapse:collapse;" borderColor=black ><col width="75px" /><col width="125px" /><col width="700px" /><caption align="left"><font size="3">STATUS
</font><br><p> <font size="2">
Offset: 0x120  EPWM Status Register
</font></caption><thread><tr bgcolor="#8A0808" ><td><font color=white><b>Bits</b></font></td><td><font color=white><b>Field</b></font></td><td><font color=white><b>Descriptions</b></font></td></tr></thread><tbody>
<tr><td>
[0]</td><td>CNTMAXF0</td><td><div style="word-wrap: break-word;"><b>Time-base Counter Equal to 0xFFFF Latched Flag
</b><br>
0 = indicates the time-base counter never reached its maximum value 0xFFFF.
<br>
1 = indicates the time-base counter reached its maximum value, software can write 1 to clear this bit.
<br>
</div></td></tr><tr><td>
[1]</td><td>CNTMAXF1</td><td><div style="word-wrap: break-word;"><b>Time-base Counter Equal to 0xFFFF Latched Flag
</b><br>
0 = indicates the time-base counter never reached its maximum value 0xFFFF.
<br>
1 = indicates the time-base counter reached its maximum value, software can write 1 to clear this bit.
<br>
</div></td></tr><tr><td>
[2]</td><td>CNTMAXF2</td><td><div style="word-wrap: break-word;"><b>Time-base Counter Equal to 0xFFFF Latched Flag
</b><br>
0 = indicates the time-base counter never reached its maximum value 0xFFFF.
<br>
1 = indicates the time-base counter reached its maximum value, software can write 1 to clear this bit.
<br>
</div></td></tr><tr><td>
[3]</td><td>CNTMAXF3</td><td><div style="word-wrap: break-word;"><b>Time-base Counter Equal to 0xFFFF Latched Flag
</b><br>
0 = indicates the time-base counter never reached its maximum value 0xFFFF.
<br>
1 = indicates the time-base counter reached its maximum value, software can write 1 to clear this bit.
<br>
</div></td></tr><tr><td>
[4]</td><td>CNTMAXF4</td><td><div style="word-wrap: break-word;"><b>Time-base Counter Equal to 0xFFFF Latched Flag
</b><br>
0 = indicates the time-base counter never reached its maximum value 0xFFFF.
<br>
1 = indicates the time-base counter reached its maximum value, software can write 1 to clear this bit.
<br>
</div></td></tr><tr><td>
[5]</td><td>CNTMAXF5</td><td><div style="word-wrap: break-word;"><b>Time-base Counter Equal to 0xFFFF Latched Flag
</b><br>
0 = indicates the time-base counter never reached its maximum value 0xFFFF.
<br>
1 = indicates the time-base counter reached its maximum value, software can write 1 to clear this bit.
<br>
</div></td></tr><tr><td>
[8]</td><td>SYNCINF0</td><td><div style="word-wrap: break-word;"><b>Input Synchronization Latched Flag
</b><br>
0 = Indicates no SYNC_IN event has occurred.
<br>
1 = Indicates an SYNC_IN event has occurred, software can write 1 to clear this bit.
<br>
</div></td></tr><tr><td>
[9]</td><td>SYNCINF2</td><td><div style="word-wrap: break-word;"><b>Input Synchronization Latched Flag
</b><br>
0 = Indicates no SYNC_IN event has occurred.
<br>
1 = Indicates an SYNC_IN event has occurred, software can write 1 to clear this bit.
<br>
</div></td></tr><tr><td>
[10]</td><td>SYNCINF4</td><td><div style="word-wrap: break-word;"><b>Input Synchronization Latched Flag
</b><br>
0 = Indicates no SYNC_IN event has occurred.
<br>
1 = Indicates an SYNC_IN event has occurred, software can write 1 to clear this bit.
<br>
</div></td></tr><tr><td>
[16]</td><td>EADCTRGF0</td><td><div style="word-wrap: break-word;"><b>EADC Start of Conversion Flag
</b><br>
0 = Indicates no EADC start of conversion trigger event has occurred.
<br>
1 = Indicates an EADC start of conversion trigger event has occurred, software can write 1 to clear this bit.
<br>
</div></td></tr><tr><td>
[17]</td><td>EADCTRGF1</td><td><div style="word-wrap: break-word;"><b>EADC Start of Conversion Flag
</b><br>
0 = Indicates no EADC start of conversion trigger event has occurred.
<br>
1 = Indicates an EADC start of conversion trigger event has occurred, software can write 1 to clear this bit.
<br>
</div></td></tr><tr><td>
[18]</td><td>EADCTRGF2</td><td><div style="word-wrap: break-word;"><b>EADC Start of Conversion Flag
</b><br>
0 = Indicates no EADC start of conversion trigger event has occurred.
<br>
1 = Indicates an EADC start of conversion trigger event has occurred, software can write 1 to clear this bit.
<br>
</div></td></tr><tr><td>
[19]</td><td>EADCTRGF3</td><td><div style="word-wrap: break-word;"><b>EADC Start of Conversion Flag
</b><br>
0 = Indicates no EADC start of conversion trigger event has occurred.
<br>
1 = Indicates an EADC start of conversion trigger event has occurred, software can write 1 to clear this bit.
<br>
</div></td></tr><tr><td>
[20]</td><td>EADCTRGF4</td><td><div style="word-wrap: break-word;"><b>EADC Start of Conversion Flag
</b><br>
0 = Indicates no EADC start of conversion trigger event has occurred.
<br>
1 = Indicates an EADC start of conversion trigger event has occurred, software can write 1 to clear this bit.
<br>
</div></td></tr><tr><td>
[21]</td><td>EADCTRGF5</td><td><div style="word-wrap: break-word;"><b>EADC Start of Conversion Flag
</b><br>
0 = Indicates no EADC start of conversion trigger event has occurred.
<br>
1 = Indicates an EADC start of conversion trigger event has occurred, software can write 1 to clear this bit.
<br>
</div></td></tr><tr><td>
[24]</td><td>DACTRGF</td><td><div style="word-wrap: break-word;"><b>DAC Start of Conversion Flag
</b><br>
0 = Indicates no DAC start of conversion trigger event has occurred.
<br>
1 = Indicates an DAC start of conversion trigger event has occurred, software can write 1 to clear this bit
<br>
</div></td></tr></tbody></table></html>

 </p>

<p class="definition">Definition at line <a class="el" href="epwm__reg_8h_source.html#l04777">4777</a> of file <a class="el" href="epwm__reg_8h_source.html">epwm_reg.h</a>.</p>

</div>
</div>
<a id="a1c8f2c8f367831306338ff64af27dd4d" name="a1c8f2c8f367831306338ff64af27dd4d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1c8f2c8f367831306338ff64af27dd4d">&#9670;&nbsp;</a></span>SWBRK</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">EPWM_T::SWBRK</td>
        </tr>
      </table>
</div><div class="memdoc">
<p >[0x00dc] EPWM Software Brake Control Register <br  />
</p>
<p > 

<html><table class="fixed" border="1" style="border-collapse:collapse;" borderColor=black ><col width="75px" /><col width="125px" /><col width="700px" /><caption align="left"><font size="3">SWBRK
</font><br><p> <font size="2">
Offset: 0xDC  EPWM Software Brake Control Register
</font></caption><thread><tr bgcolor="#8A0808" ><td><font color=white><b>Bits</b></font></td><td><font color=white><b>Field</b></font></td><td><font color=white><b>Descriptions</b></font></td></tr></thread><tbody>
<tr><td>
[0]</td><td>BRKETRG0</td><td><div style="word-wrap: break-word;"><b>EPWM Edge Brake Software Trigger (Write Only) (Write Protect)
</b><br>
Write 1 to this bit will trigger edge brake, and set BRKEIFn to 1 in EPWM_INTSTS1 register.
<br>
Note: This register is write protected. Refer toSYS_REGLCTL register.
<br>
</div></td></tr><tr><td>
[1]</td><td>BRKETRG2</td><td><div style="word-wrap: break-word;"><b>EPWM Edge Brake Software Trigger (Write Only) (Write Protect)
</b><br>
Write 1 to this bit will trigger edge brake, and set BRKEIFn to 1 in EPWM_INTSTS1 register.
<br>
Note: This register is write protected. Refer toSYS_REGLCTL register.
<br>
</div></td></tr><tr><td>
[2]</td><td>BRKETRG4</td><td><div style="word-wrap: break-word;"><b>EPWM Edge Brake Software Trigger (Write Only) (Write Protect)
</b><br>
Write 1 to this bit will trigger edge brake, and set BRKEIFn to 1 in EPWM_INTSTS1 register.
<br>
Note: This register is write protected. Refer toSYS_REGLCTL register.
<br>
</div></td></tr><tr><td>
[8]</td><td>BRKLTRG0</td><td><div style="word-wrap: break-word;"><b>EPWM Level Brake Software Trigger (Write Only) (Write Protect)
</b><br>
Write 1 to this bit will trigger level brake, and set BRKLIFn to 1 in EPWM_INTSTS1 register.
<br>
Note: This register is write protected. Refer toSYS_REGLCTL register.
<br>
</div></td></tr><tr><td>
[9]</td><td>BRKLTRG2</td><td><div style="word-wrap: break-word;"><b>EPWM Level Brake Software Trigger (Write Only) (Write Protect)
</b><br>
Write 1 to this bit will trigger level brake, and set BRKLIFn to 1 in EPWM_INTSTS1 register.
<br>
Note: This register is write protected. Refer toSYS_REGLCTL register.
<br>
</div></td></tr><tr><td>
[10]</td><td>BRKLTRG4</td><td><div style="word-wrap: break-word;"><b>EPWM Level Brake Software Trigger (Write Only) (Write Protect)
</b><br>
Write 1 to this bit will trigger level brake, and set BRKLIFn to 1 in EPWM_INTSTS1 register.
<br>
Note: This register is write protected. Refer toSYS_REGLCTL register.
<br>
</div></td></tr></tbody></table></html>

 </p>

<p class="definition">Definition at line <a class="el" href="epwm__reg_8h_source.html#l04758">4758</a> of file <a class="el" href="epwm__reg_8h_source.html">epwm_reg.h</a>.</p>

</div>
</div>
<a id="a2685e3adfb6e8b9ead4d16c4e4d4a027" name="a2685e3adfb6e8b9ead4d16c4e4d4a027"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2685e3adfb6e8b9ead4d16c4e4d4a027">&#9670;&nbsp;</a></span>SWSYNC</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">EPWM_T::SWSYNC</td>
        </tr>
      </table>
</div><div class="memdoc">
<p >[0x000c] EPWM Software Control Synchronization Register <br  />
</p>
<p > 

<html><table class="fixed" border="1" style="border-collapse:collapse;" borderColor=black ><col width="75px" /><col width="125px" /><col width="700px" /><caption align="left"><font size="3">SWSYNC
</font><br><p> <font size="2">
Offset: 0x0C  EPWM Software Control Synchronization Register
</font></caption><thread><tr bgcolor="#8A0808" ><td><font color=white><b>Bits</b></font></td><td><font color=white><b>Field</b></font></td><td><font color=white><b>Descriptions</b></font></td></tr></thread><tbody>
<tr><td>
[0]</td><td>SWSYNC0</td><td><div style="word-wrap: break-word;"><b>Software SYNC Function
</b><br>
When SINSRCn (EPWM_SYNC[13:8]) is selected to 0, SYNC_OUT source is come from SYNC_IN or this bit.
<br>
</div></td></tr><tr><td>
[1]</td><td>SWSYNC2</td><td><div style="word-wrap: break-word;"><b>Software SYNC Function
</b><br>
When SINSRCn (EPWM_SYNC[13:8]) is selected to 0, SYNC_OUT source is come from SYNC_IN or this bit.
<br>
</div></td></tr><tr><td>
[2]</td><td>SWSYNC4</td><td><div style="word-wrap: break-word;"><b>Software SYNC Function
</b><br>
When SINSRCn (EPWM_SYNC[13:8]) is selected to 0, SYNC_OUT source is come from SYNC_IN or this bit.
<br>
</div></td></tr></tbody></table></html>

 </p>

<p class="definition">Definition at line <a class="el" href="epwm__reg_8h_source.html#l04720">4720</a> of file <a class="el" href="epwm__reg_8h_source.html">epwm_reg.h</a>.</p>

</div>
</div>
<a id="ac41f21d8583921ac8b3543ed6b75e848" name="ac41f21d8583921ac8b3543ed6b75e848"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac41f21d8583921ac8b3543ed6b75e848">&#9670;&nbsp;</a></span>SYNC</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">EPWM_T::SYNC</td>
        </tr>
      </table>
</div><div class="memdoc">
<p >[0x0008] EPWM Synchronization Register <br  />
</p>
<p > 

<html><table class="fixed" border="1" style="border-collapse:collapse;" borderColor=black ><col width="75px" /><col width="125px" /><col width="700px" /><caption align="left"><font size="3">SYNC
</font><br><p> <font size="2">
Offset: 0x08  EPWM Synchronization Register
</font></caption><thread><tr bgcolor="#8A0808" ><td><font color=white><b>Bits</b></font></td><td><font color=white><b>Field</b></font></td><td><font color=white><b>Descriptions</b></font></td></tr></thread><tbody>
<tr><td>
[0]</td><td>PHSEN0</td><td><div style="word-wrap: break-word;"><b>SYNC Phase Enable Bits
</b><br>
0 = EPWM counter disable to load PHS value.
<br>
1 = EPWM counter enable to load PHS value.
<br>
</div></td></tr><tr><td>
[1]</td><td>PHSEN2</td><td><div style="word-wrap: break-word;"><b>SYNC Phase Enable Bits
</b><br>
0 = EPWM counter disable to load PHS value.
<br>
1 = EPWM counter enable to load PHS value.
<br>
</div></td></tr><tr><td>
[2]</td><td>PHSEN4</td><td><div style="word-wrap: break-word;"><b>SYNC Phase Enable Bits
</b><br>
0 = EPWM counter disable to load PHS value.
<br>
1 = EPWM counter enable to load PHS value.
<br>
</div></td></tr><tr><td>
[9:8]</td><td>SINSRC0</td><td><div style="word-wrap: break-word;"><b>EPWM0_SYNC_IN Source Selection
</b><br>
00 = Synchronize source from SYNC_IN or SWSYNC.
<br>
01 = Counter equal to 0.
<br>
10 = Counter equal to EPWM_CMPDATm, m denotes 1, 3, 5.
<br>
11 = SYNC_OUT will not be generated.
<br>
</div></td></tr><tr><td>
[11:10]</td><td>SINSRC2</td><td><div style="word-wrap: break-word;"><b>EPWM0_SYNC_IN Source Selection
</b><br>
00 = Synchronize source from SYNC_IN or SWSYNC.
<br>
01 = Counter equal to 0.
<br>
10 = Counter equal to EPWM_CMPDATm, m denotes 1, 3, 5.
<br>
11 = SYNC_OUT will not be generated.
<br>
</div></td></tr><tr><td>
[13:12]</td><td>SINSRC4</td><td><div style="word-wrap: break-word;"><b>EPWM0_SYNC_IN Source Selection
</b><br>
00 = Synchronize source from SYNC_IN or SWSYNC.
<br>
01 = Counter equal to 0.
<br>
10 = Counter equal to EPWM_CMPDATm, m denotes 1, 3, 5.
<br>
11 = SYNC_OUT will not be generated.
<br>
</div></td></tr><tr><td>
[16]</td><td>SNFLTEN</td><td><div style="word-wrap: break-word;"><b>EPWM0_SYNC_IN Noise Filter Enable Bits
</b><br>
0 = Noise filter of input pin EPWM0_SYNC_IN is Disabled.
<br>
1 = Noise filter of input pin EPWM0_SYNC_IN is Enabled.
<br>
</div></td></tr><tr><td>
[19:17]</td><td>SFLTCSEL</td><td><div style="word-wrap: break-word;"><b>SYNC Edge Detector Filter Clock Selection
</b><br>
000 = Filter clock = HCLK.
<br>
001 = Filter clock = HCLK/2.
<br>
010 = Filter clock = HCLK/4.
<br>
011 = Filter clock = HCLK/8.
<br>
100 = Filter clock = HCLK/16.
<br>
101 = Filter clock = HCLK/32.
<br>
110 = Filter clock = HCLK/64.
<br>
111 = Filter clock = HCLK/128.
<br>
</div></td></tr><tr><td>
[22:20]</td><td>SFLTCNT</td><td><div style="word-wrap: break-word;"><b>SYNC Edge Detector Filter Count
</b><br>
The register bits control the counter number of edge detector.
<br>
</div></td></tr><tr><td>
[23]</td><td>SINPINV</td><td><div style="word-wrap: break-word;"><b>SYNC Input Pin Inverse
</b><br>
0 = The state of pin SYNC is passed to the negative edge detector.
<br>
1 = The inversed state of pin SYNC is passed to the negative edge detector.
<br>
</div></td></tr><tr><td>
[24]</td><td>PHSDIR0</td><td><div style="word-wrap: break-word;"><b>EPWM Phase Direction Control
</b><br>
0 = Control EPWM counter count decrement after synchronizing.
<br>
1 = Control EPWM counter count increment after synchronizing.
<br>
</div></td></tr><tr><td>
[25]</td><td>PHSDIR2</td><td><div style="word-wrap: break-word;"><b>EPWM Phase Direction Control
</b><br>
0 = Control EPWM counter count decrement after synchronizing.
<br>
1 = Control EPWM counter count increment after synchronizing.
<br>
</div></td></tr><tr><td>
[26]</td><td>PHSDIR4</td><td><div style="word-wrap: break-word;"><b>EPWM Phase Direction Control
</b><br>
0 = Control EPWM counter count decrement after synchronizing.
<br>
1 = Control EPWM counter count increment after synchronizing.
<br>
</div></td></tr></tbody></table></html>

 </p>

<p class="definition">Definition at line <a class="el" href="epwm__reg_8h_source.html#l04719">4719</a> of file <a class="el" href="epwm__reg_8h_source.html">epwm_reg.h</a>.</p>

</div>
</div>
<a id="a7bc270fb354c810fd8f2dd4bbc871ddb" name="a7bc270fb354c810fd8f2dd4bbc871ddb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7bc270fb354c810fd8f2dd4bbc871ddb">&#9670;&nbsp;</a></span>WGCTL0</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">EPWM_T::WGCTL0</td>
        </tr>
      </table>
</div><div class="memdoc">
<p >[0x00b0] EPWM Generation Register 0 <br  />
</p>
<p > 

<html><table class="fixed" border="1" style="border-collapse:collapse;" borderColor=black ><col width="75px" /><col width="125px" /><col width="700px" /><caption align="left"><font size="3">WGCTL0
</font><br><p> <font size="2">
Offset: 0xB0  EPWM Generation Register 0
</font></caption><thread><tr bgcolor="#8A0808" ><td><font color=white><b>Bits</b></font></td><td><font color=white><b>Field</b></font></td><td><font color=white><b>Descriptions</b></font></td></tr></thread><tbody>
<tr><td>
[1:0]</td><td>ZPCTL0</td><td><div style="word-wrap: break-word;"><b>EPWM Zero Point Control
</b><br>
00 = Do nothing.
<br>
01 = EPWM zero point output Low.
<br>
10 = EPWM zero point output High.
<br>
11 = EPWM zero point output Toggle.
<br>
EPWM can control output level when EPWM counter count to zero.
<br>
</div></td></tr><tr><td>
[3:2]</td><td>ZPCTL1</td><td><div style="word-wrap: break-word;"><b>EPWM Zero Point Control
</b><br>
00 = Do nothing.
<br>
01 = EPWM zero point output Low.
<br>
10 = EPWM zero point output High.
<br>
11 = EPWM zero point output Toggle.
<br>
EPWM can control output level when EPWM counter count to zero.
<br>
</div></td></tr><tr><td>
[5:4]</td><td>ZPCTL2</td><td><div style="word-wrap: break-word;"><b>EPWM Zero Point Control
</b><br>
00 = Do nothing.
<br>
01 = EPWM zero point output Low.
<br>
10 = EPWM zero point output High.
<br>
11 = EPWM zero point output Toggle.
<br>
EPWM can control output level when EPWM counter count to zero.
<br>
</div></td></tr><tr><td>
[7:6]</td><td>ZPCTL3</td><td><div style="word-wrap: break-word;"><b>EPWM Zero Point Control
</b><br>
00 = Do nothing.
<br>
01 = EPWM zero point output Low.
<br>
10 = EPWM zero point output High.
<br>
11 = EPWM zero point output Toggle.
<br>
EPWM can control output level when EPWM counter count to zero.
<br>
</div></td></tr><tr><td>
[9:8]</td><td>ZPCTL4</td><td><div style="word-wrap: break-word;"><b>EPWM Zero Point Control
</b><br>
00 = Do nothing.
<br>
01 = EPWM zero point output Low.
<br>
10 = EPWM zero point output High.
<br>
11 = EPWM zero point output Toggle.
<br>
EPWM can control output level when EPWM counter count to zero.
<br>
</div></td></tr><tr><td>
[11:10]</td><td>ZPCTL5</td><td><div style="word-wrap: break-word;"><b>EPWM Zero Point Control
</b><br>
00 = Do nothing.
<br>
01 = EPWM zero point output Low.
<br>
10 = EPWM zero point output High.
<br>
11 = EPWM zero point output Toggle.
<br>
EPWM can control output level when EPWM counter count to zero.
<br>
</div></td></tr><tr><td>
[17:16]</td><td>PRDPCTL0</td><td><div style="word-wrap: break-word;"><b>EPWM Period (Center) Point Control
</b><br>
00 = Do nothing.
<br>
01 = EPWM period (center) point output Low.
<br>
10 = EPWM period (center) point output High.
<br>
11 = EPWM period (center) point output Toggle.
<br>
EPWM can control output level when EPWM counter count to (PERIODn+1).
<br>
Note: This bit is center point control when EPWM counter operating in up-down counter type.
<br>
</div></td></tr><tr><td>
[19:18]</td><td>PRDPCTL1</td><td><div style="word-wrap: break-word;"><b>EPWM Period (Center) Point Control
</b><br>
00 = Do nothing.
<br>
01 = EPWM period (center) point output Low.
<br>
10 = EPWM period (center) point output High.
<br>
11 = EPWM period (center) point output Toggle.
<br>
EPWM can control output level when EPWM counter count to (PERIODn+1).
<br>
Note: This bit is center point control when EPWM counter operating in up-down counter type.
<br>
</div></td></tr><tr><td>
[21:20]</td><td>PRDPCTL2</td><td><div style="word-wrap: break-word;"><b>EPWM Period (Center) Point Control
</b><br>
00 = Do nothing.
<br>
01 = EPWM period (center) point output Low.
<br>
10 = EPWM period (center) point output High.
<br>
11 = EPWM period (center) point output Toggle.
<br>
EPWM can control output level when EPWM counter count to (PERIODn+1).
<br>
Note: This bit is center point control when EPWM counter operating in up-down counter type.
<br>
</div></td></tr><tr><td>
[23:22]</td><td>PRDPCTL3</td><td><div style="word-wrap: break-word;"><b>EPWM Period (Center) Point Control
</b><br>
00 = Do nothing.
<br>
01 = EPWM period (center) point output Low.
<br>
10 = EPWM period (center) point output High.
<br>
11 = EPWM period (center) point output Toggle.
<br>
EPWM can control output level when EPWM counter count to (PERIODn+1).
<br>
Note: This bit is center point control when EPWM counter operating in up-down counter type.
<br>
</div></td></tr><tr><td>
[25:24]</td><td>PRDPCTL4</td><td><div style="word-wrap: break-word;"><b>EPWM Period (Center) Point Control
</b><br>
00 = Do nothing.
<br>
01 = EPWM period (center) point output Low.
<br>
10 = EPWM period (center) point output High.
<br>
11 = EPWM period (center) point output Toggle.
<br>
EPWM can control output level when EPWM counter count to (PERIODn+1).
<br>
Note: This bit is center point control when EPWM counter operating in up-down counter type.
<br>
</div></td></tr><tr><td>
[27:26]</td><td>PRDPCTL5</td><td><div style="word-wrap: break-word;"><b>EPWM Period (Center) Point Control
</b><br>
00 = Do nothing.
<br>
01 = EPWM period (center) point output Low.
<br>
10 = EPWM period (center) point output High.
<br>
11 = EPWM period (center) point output Toggle.
<br>
EPWM can control output level when EPWM counter count to (PERIODn+1).
<br>
Note: This bit is center point control when EPWM counter operating in up-down counter type.
<br>
</div></td></tr></tbody></table></html>

 </p>

<p class="definition">Definition at line <a class="el" href="epwm__reg_8h_source.html#l04749">4749</a> of file <a class="el" href="epwm__reg_8h_source.html">epwm_reg.h</a>.</p>

</div>
</div>
<a id="a2907994515eb17ac1a1a3879022bc0bc" name="a2907994515eb17ac1a1a3879022bc0bc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2907994515eb17ac1a1a3879022bc0bc">&#9670;&nbsp;</a></span>WGCTL1</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">EPWM_T::WGCTL1</td>
        </tr>
      </table>
</div><div class="memdoc">
<p >[0x00b4] EPWM Generation Register 1 <br  />
</p>
<p > 

<html><table class="fixed" border="1" style="border-collapse:collapse;" borderColor=black ><col width="75px" /><col width="125px" /><col width="700px" /><caption align="left"><font size="3">WGCTL1
</font><br><p> <font size="2">
Offset: 0xB4  EPWM Generation Register 1
</font></caption><thread><tr bgcolor="#8A0808" ><td><font color=white><b>Bits</b></font></td><td><font color=white><b>Field</b></font></td><td><font color=white><b>Descriptions</b></font></td></tr></thread><tbody>
<tr><td>
[1:0]</td><td>CMPUCTL0</td><td><div style="word-wrap: break-word;"><b>EPWM Compare Up Point Control
</b><br>
00 = Do nothing.
<br>
01 = EPWM compare up point output Low.
<br>
10 = EPWM compare up point output High.
<br>
11 = EPWM compare up point output Toggle.
<br>
EPWM can control output level when EPWM counter up count to CMPDAT.
<br>
Note: In complementary mode, CMPUCTL1, 3, 5 use as another CMPUCTL for channel 0, 2, 4.
<br>
</div></td></tr><tr><td>
[3:2]</td><td>CMPUCTL1</td><td><div style="word-wrap: break-word;"><b>EPWM Compare Up Point Control
</b><br>
00 = Do nothing.
<br>
01 = EPWM compare up point output Low.
<br>
10 = EPWM compare up point output High.
<br>
11 = EPWM compare up point output Toggle.
<br>
EPWM can control output level when EPWM counter up count to CMPDAT.
<br>
Note: In complementary mode, CMPUCTL1, 3, 5 use as another CMPUCTL for channel 0, 2, 4.
<br>
</div></td></tr><tr><td>
[5:4]</td><td>CMPUCTL2</td><td><div style="word-wrap: break-word;"><b>EPWM Compare Up Point Control
</b><br>
00 = Do nothing.
<br>
01 = EPWM compare up point output Low.
<br>
10 = EPWM compare up point output High.
<br>
11 = EPWM compare up point output Toggle.
<br>
EPWM can control output level when EPWM counter up count to CMPDAT.
<br>
Note: In complementary mode, CMPUCTL1, 3, 5 use as another CMPUCTL for channel 0, 2, 4.
<br>
</div></td></tr><tr><td>
[7:6]</td><td>CMPUCTL3</td><td><div style="word-wrap: break-word;"><b>EPWM Compare Up Point Control
</b><br>
00 = Do nothing.
<br>
01 = EPWM compare up point output Low.
<br>
10 = EPWM compare up point output High.
<br>
11 = EPWM compare up point output Toggle.
<br>
EPWM can control output level when EPWM counter up count to CMPDAT.
<br>
Note: In complementary mode, CMPUCTL1, 3, 5 use as another CMPUCTL for channel 0, 2, 4.
<br>
</div></td></tr><tr><td>
[9:8]</td><td>CMPUCTL4</td><td><div style="word-wrap: break-word;"><b>EPWM Compare Up Point Control
</b><br>
00 = Do nothing.
<br>
01 = EPWM compare up point output Low.
<br>
10 = EPWM compare up point output High.
<br>
11 = EPWM compare up point output Toggle.
<br>
EPWM can control output level when EPWM counter up count to CMPDAT.
<br>
Note: In complementary mode, CMPUCTL1, 3, 5 use as another CMPUCTL for channel 0, 2, 4.
<br>
</div></td></tr><tr><td>
[11:10]</td><td>CMPUCTL5</td><td><div style="word-wrap: break-word;"><b>EPWM Compare Up Point Control
</b><br>
00 = Do nothing.
<br>
01 = EPWM compare up point output Low.
<br>
10 = EPWM compare up point output High.
<br>
11 = EPWM compare up point output Toggle.
<br>
EPWM can control output level when EPWM counter up count to CMPDAT.
<br>
Note: In complementary mode, CMPUCTL1, 3, 5 use as another CMPUCTL for channel 0, 2, 4.
<br>
</div></td></tr><tr><td>
[17:16]</td><td>CMPDCTL0</td><td><div style="word-wrap: break-word;"><b>EPWM Compare Down Point Control
</b><br>
00 = Do nothing.
<br>
01 = EPWM compare down point output Low.
<br>
10 = EPWM compare down point output High.
<br>
11 = EPWM compare down point output Toggle.
<br>
EPWM can control output level when EPWM counter down count to CMPDAT.
<br>
Note: In complementary mode, CMPDCTL1, 3, 5 use as another CMPDCTL for channel 0, 2, 4.
<br>
</div></td></tr><tr><td>
[19:18]</td><td>CMPDCTL1</td><td><div style="word-wrap: break-word;"><b>EPWM Compare Down Point Control
</b><br>
00 = Do nothing.
<br>
01 = EPWM compare down point output Low.
<br>
10 = EPWM compare down point output High.
<br>
11 = EPWM compare down point output Toggle.
<br>
EPWM can control output level when EPWM counter down count to CMPDAT.
<br>
Note: In complementary mode, CMPDCTL1, 3, 5 use as another CMPDCTL for channel 0, 2, 4.
<br>
</div></td></tr><tr><td>
[21:20]</td><td>CMPDCTL2</td><td><div style="word-wrap: break-word;"><b>EPWM Compare Down Point Control
</b><br>
00 = Do nothing.
<br>
01 = EPWM compare down point output Low.
<br>
10 = EPWM compare down point output High.
<br>
11 = EPWM compare down point output Toggle.
<br>
EPWM can control output level when EPWM counter down count to CMPDAT.
<br>
Note: In complementary mode, CMPDCTL1, 3, 5 use as another CMPDCTL for channel 0, 2, 4.
<br>
</div></td></tr><tr><td>
[23:22]</td><td>CMPDCTL3</td><td><div style="word-wrap: break-word;"><b>EPWM Compare Down Point Control
</b><br>
00 = Do nothing.
<br>
01 = EPWM compare down point output Low.
<br>
10 = EPWM compare down point output High.
<br>
11 = EPWM compare down point output Toggle.
<br>
EPWM can control output level when EPWM counter down count to CMPDAT.
<br>
Note: In complementary mode, CMPDCTL1, 3, 5 use as another CMPDCTL for channel 0, 2, 4.
<br>
</div></td></tr><tr><td>
[25:24]</td><td>CMPDCTL4</td><td><div style="word-wrap: break-word;"><b>EPWM Compare Down Point Control
</b><br>
00 = Do nothing.
<br>
01 = EPWM compare down point output Low.
<br>
10 = EPWM compare down point output High.
<br>
11 = EPWM compare down point output Toggle.
<br>
EPWM can control output level when EPWM counter down count to CMPDAT.
<br>
Note: In complementary mode, CMPDCTL1, 3, 5 use as another CMPDCTL for channel 0, 2, 4.
<br>
</div></td></tr><tr><td>
[27:26]</td><td>CMPDCTL5</td><td><div style="word-wrap: break-word;"><b>EPWM Compare Down Point Control
</b><br>
00 = Do nothing.
<br>
01 = EPWM compare down point output Low.
<br>
10 = EPWM compare down point output High.
<br>
11 = EPWM compare down point output Toggle.
<br>
EPWM can control output level when EPWM counter down count to CMPDAT.
<br>
Note: In complementary mode, CMPDCTL1, 3, 5 use as another CMPDCTL for channel 0, 2, 4.
<br>
</div></td></tr></tbody></table></html>

 </p>

<p class="definition">Definition at line <a class="el" href="epwm__reg_8h_source.html#l04750">4750</a> of file <a class="el" href="epwm__reg_8h_source.html">epwm_reg.h</a>.</p>

</div>
</div>
<hr/>The documentation for this struct was generated from the following file:<ul>
<li>C:/Project/M4/M480/temp/bsp/Library/Device/Nuvoton/M480/Include/<a class="el" href="epwm__reg_8h_source.html">epwm_reg.h</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Mon Oct 14 2024 12:22:09 for M480 BSP by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.3
</small></address>
</body>
</html>
